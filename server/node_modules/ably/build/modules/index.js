/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)

Ably JavaScript Library v1.2.40
https://github.com/ably/ably-js

Released under the Apache Licence v2.0*/
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/common/platform.ts
var Platform = class {
};

// src/common/lib/util/logger.ts
var globalObject = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : self;
function pad(timeSegment, three) {
  return `${timeSegment}`.padStart(three ? 3 : 2, "0");
}
function getHandler(logger) {
  return Platform.Config.logTimestamps ? function(msg) {
    const time = /* @__PURE__ */ new Date();
    logger(
      pad(time.getHours()) + ":" + pad(time.getMinutes()) + ":" + pad(time.getSeconds()) + "." + pad(time.getMilliseconds(), 1) + " " + msg
    );
  } : logger;
}
var getDefaultLoggers = () => {
  var _a2, _b;
  let consoleLogger;
  let errorLogger;
  if (typeof Window === "undefined" && typeof WorkerGlobalScope === "undefined" || typeof ((_b = (_a2 = globalObject == null ? void 0 : globalObject.console) == null ? void 0 : _a2.log) == null ? void 0 : _b.apply) === "function") {
    consoleLogger = function(...args) {
      console.log.apply(console, args);
    };
    errorLogger = console.warn ? function(...args) {
      console.warn.apply(console, args);
    } : consoleLogger;
  } else if (globalObject == null ? void 0 : globalObject.console.log) {
    consoleLogger = errorLogger = function() {
      Function.prototype.apply.call(console.log, console, arguments);
    };
  } else {
    consoleLogger = errorLogger = function() {
    };
  }
  return [consoleLogger, errorLogger].map(getHandler);
};
var _Logger = class _Logger {
  constructor() {
    _Logger.logLevel = _Logger.LOG_DEFAULT;
  }
  static initLogHandlers() {
    const [logHandler, logErrorHandler] = getDefaultLoggers();
    this.logHandler = logHandler;
    this.logErrorHandler = logErrorHandler;
  }
};
_Logger.logLevel = 1 /* Error */;
// public constants
_Logger.LOG_NONE = 0 /* None */;
_Logger.LOG_ERROR = 1 /* Error */;
_Logger.LOG_MAJOR = 2 /* Major */;
_Logger.LOG_MINOR = 3 /* Minor */;
_Logger.LOG_MICRO = 4 /* Micro */;
// aliases
_Logger.LOG_DEFAULT = 1 /* Error */;
_Logger.LOG_DEBUG = 4 /* Micro */;
/* public static functions */
_Logger.logAction = (level, action, message) => {
  if (_Logger.shouldLog(level)) {
    (level === 1 /* Error */ ? _Logger.logErrorHandler : _Logger.logHandler)("Ably: " + action + ": " + message);
  }
};
/* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent
  the object being serialised if the log level will not output the message */
_Logger.shouldLog = (level) => {
  return level <= _Logger.logLevel;
};
_Logger.setLog = (level, handler) => {
  if (level !== void 0)
    _Logger.logLevel = level;
  if (handler !== void 0)
    _Logger.logHandler = _Logger.logErrorHandler = handler;
};
var Logger = _Logger;
var logger_default = Logger;

// src/common/lib/types/errorinfo.ts
function toString(err) {
  let result = "[" + err.constructor.name;
  if (err.message)
    result += ": " + err.message;
  if (err.statusCode)
    result += "; statusCode=" + err.statusCode;
  if (err.code)
    result += "; code=" + err.code;
  if (err.cause)
    result += "; cause=" + inspectError(err.cause);
  if (err.href && !(err.message && err.message.indexOf("help.ably.io") > -1))
    result += "; see " + err.href + " ";
  result += "]";
  return result;
}
var ErrorInfo = class _ErrorInfo extends Error {
  constructor(message, code, statusCode, cause) {
    super(message);
    if (typeof Object.setPrototypeOf !== "undefined") {
      Object.setPrototypeOf(this, _ErrorInfo.prototype);
    }
    this.code = code;
    this.statusCode = statusCode;
    this.cause = cause;
  }
  toString() {
    return toString(this);
  }
  static fromValues(values) {
    const { message, code, statusCode } = values;
    if (typeof message !== "string" || typeof code !== "number" || typeof statusCode !== "number") {
      throw new Error("ErrorInfo.fromValues(): invalid values: " + Platform.Config.inspect(values));
    }
    const result = Object.assign(new _ErrorInfo(message, code, statusCode), values);
    if (result.code && !result.href) {
      result.href = "https://help.ably.io/error/" + result.code;
    }
    return result;
  }
};
var PartialErrorInfo = class _PartialErrorInfo extends Error {
  constructor(message, code, statusCode, cause) {
    super(message);
    if (typeof Object.setPrototypeOf !== "undefined") {
      Object.setPrototypeOf(this, _PartialErrorInfo.prototype);
    }
    this.code = code;
    this.statusCode = statusCode;
    this.cause = cause;
  }
  toString() {
    return toString(this);
  }
};

// src/common/lib/util/utils.ts
function randomPosn(arrOrStr) {
  return Math.floor(Math.random() * arrOrStr.length);
}
function mixin(target, ...args) {
  for (let i = 0; i < args.length; i++) {
    const source = args[i];
    if (!source) {
      break;
    }
    const hasOwnProperty = Object.prototype.hasOwnProperty;
    for (const key in source) {
      if (!hasOwnProperty || hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
}
function copy(src) {
  return mixin({}, src);
}
var isArray = Array.isArray || function(value) {
  return Object.prototype.toString.call(value) == "[object Array]";
};
function ensureArray(obj) {
  if (isEmptyArg(obj)) {
    return [];
  }
  if (isArray(obj)) {
    return obj;
  }
  return [obj];
}
function isObject(ob) {
  return Object.prototype.toString.call(ob) == "[object Object]";
}
function isEmptyArg(arg) {
  return arg === null || arg === void 0;
}
var arrIndexOf = Array.prototype.indexOf ? function(arr, elem, fromIndex) {
  return arr.indexOf(elem, fromIndex);
} : function(arr, elem, fromIndex) {
  fromIndex = fromIndex || 0;
  const len = arr.length;
  for (; fromIndex < len; fromIndex++) {
    if (arr[fromIndex] === elem) {
      return fromIndex;
    }
  }
  return -1;
};
function arrIn(arr, val) {
  return arrIndexOf(arr, val) !== -1;
}
function keysArray(ob, ownOnly) {
  const result = [];
  for (const prop in ob) {
    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))
      continue;
    result.push(prop);
  }
  return result;
}
function forInOwnNonNullProperties(ob, fn) {
  for (const prop in ob) {
    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {
      fn(prop);
    }
  }
}
var arrForEach = Array.prototype.forEach ? function(arr, fn) {
  arr.forEach(fn);
} : function(arr, fn) {
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    fn(arr[i], i, arr);
  }
};
var arrMap = Array.prototype.map ? function(arr, fn) {
  return arr.map(fn);
} : function(arr, fn) {
  const result = [];
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    result.push(fn(arr[i], i, arr));
  }
  return result;
};
var arrFilter = Array.prototype.filter ? function(arr, fn) {
  return arr.filter(fn);
} : function(arr, fn) {
  const result = [], len = arr.length;
  for (let i = 0; i < len; i++) {
    if (fn(arr[i])) {
      result.push(arr[i]);
    }
  }
  return result;
};
var arrEvery = Array.prototype.every ? function(arr, fn) {
  return arr.every(fn);
} : function(arr, fn) {
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    if (!fn(arr[i], i, arr)) {
      return false;
    }
  }
  return true;
};
function arrPopRandomElement(arr) {
  return arr.splice(randomPosn(arr), 1)[0];
}
function toQueryString(params) {
  const parts = [];
  if (params) {
    for (const key in params)
      parts.push(encodeURIComponent(key) + "=" + encodeURIComponent(params[key]));
  }
  return parts.length ? "?" + parts.join("&") : "";
}
function parseQueryString(query) {
  let match;
  const search = /([^?&=]+)=?([^&]*)/g;
  const result = {};
  while (match = search.exec(query))
    result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);
  return result;
}
var now = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function isErrorInfoOrPartialErrorInfo(err) {
  return typeof err == "object" && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);
}
function inspectError(err) {
  var _a2, _b;
  if (err instanceof Error || ((_a2 = err == null ? void 0 : err.constructor) == null ? void 0 : _a2.name) === "ErrorInfo" || ((_b = err == null ? void 0 : err.constructor) == null ? void 0 : _b.name) === "PartialErrorInfo")
    return Platform.Config.inspect(err);
  return err.toString();
}
function inspectBody(body) {
  if (Platform.BufferUtils.isBuffer(body)) {
    return body.toString();
  } else if (typeof body === "string") {
    return body;
  } else {
    return Platform.Config.inspect(body);
  }
}
function dataSizeBytes(data) {
  if (Platform.BufferUtils.isBuffer(data)) {
    return Platform.BufferUtils.byteLength(data);
  }
  if (typeof data === "string") {
    return Platform.Config.stringByteSize(data);
  }
  throw new Error("Expected input of Utils.dataSizeBytes to be a buffer or string, but was: " + typeof data);
}
function cheapRandStr() {
  return String(Math.random()).substr(2);
}
var randomString = (numBytes) => {
  if (Platform.Config.getRandomValues && typeof Uint8Array !== "undefined") {
    const uIntArr = new Uint8Array(numBytes);
    Platform.Config.getRandomValues(uIntArr);
    return Platform.BufferUtils.base64Encode(uIntArr);
  }
  const charset = Platform.BufferUtils.base64CharSet;
  const length = Math.round(numBytes * 4 / 3);
  let result = "";
  for (let i = 0; i < length; i++) {
    result += charset[randomPosn(charset)];
  }
  return result;
};
function arrChooseN(arr, n2) {
  const numItems = Math.min(n2, arr.length), mutableArr = arr.slice(), result = [];
  for (let i = 0; i < numItems; i++) {
    result.push(arrPopRandomElement(mutableArr));
  }
  return result;
}
var trim = String.prototype.trim ? function(str) {
  return str.trim();
} : function(str) {
  return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
};
function promisify(ob, fnName, args) {
  return new Promise(function(resolve, reject) {
    ob[fnName](...args, function(err, res) {
      err ? reject(err) : resolve(res);
    });
  });
}
function decodeBody(body, format) {
  return format == "msgpack" ? Platform.Config.msgpack.decode(body) : JSON.parse(String(body));
}
function encodeBody(body, format) {
  return format == "msgpack" ? Platform.Config.msgpack.encode(body, true) : JSON.stringify(body);
}
function allToLowerCase(arr) {
  return arr.map(function(element) {
    return element && element.toLowerCase();
  });
}
function getGlobalObject() {
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  return self;
}
function toBase64(str) {
  const bufferUtils = Platform.BufferUtils;
  const textBuffer = bufferUtils.utf8Encode(str);
  return bufferUtils.base64Encode(textBuffer);
}
function isRealtime(client) {
  return !!client.connection;
}

// package.json
var version = "1.2.40";

// src/common/lib/util/defaults.ts
var agent = "ably-js/" + version;
var Defaults = {
  ENVIRONMENT: "",
  REST_HOST: "rest.ably.io",
  REALTIME_HOST: "realtime.ably.io",
  FALLBACK_HOSTS: [
    "A.ably-realtime.com",
    "B.ably-realtime.com",
    "C.ably-realtime.com",
    "D.ably-realtime.com",
    "E.ably-realtime.com"
  ],
  PORT: 80,
  TLS_PORT: 443,
  TIMEOUTS: {
    /* Documented as options params: */
    disconnectedRetryTimeout: 15e3,
    suspendedRetryTimeout: 3e4,
    /* Undocumented, but part of the api and can be used by customers: */
    httpRequestTimeout: 15e3,
    channelRetryTimeout: 15e3,
    fallbackRetryTimeout: 6e5,
    /* For internal / test use only: */
    connectionStateTtl: 12e4,
    realtimeRequestTimeout: 1e4,
    recvTimeout: 9e4,
    preferenceConnectTimeout: 6e3,
    parallelUpgradeDelay: 6e3
  },
  httpMaxRetryCount: 3,
  maxMessageSize: 65536,
  version,
  protocolVersion: 2,
  agent,
  getHost,
  getPort,
  getHttpScheme,
  environmentFallbackHosts,
  getFallbackHosts,
  getHosts,
  checkHost,
  objectifyOptions,
  normaliseOptions,
  defaultGetHeaders,
  defaultPostHeaders
};
function getHost(options, host, ws) {
  if (ws)
    host = host == options.restHost && options.realtimeHost || host || options.realtimeHost;
  else
    host = host || options.restHost;
  return host;
}
function getPort(options, tls) {
  return tls || options.tls ? options.tlsPort : options.port;
}
function getHttpScheme(options) {
  return options.tls ? "https://" : "http://";
}
function environmentFallbackHosts(environment) {
  return [
    environment + "-a-fallback.ably-realtime.com",
    environment + "-b-fallback.ably-realtime.com",
    environment + "-c-fallback.ably-realtime.com",
    environment + "-d-fallback.ably-realtime.com",
    environment + "-e-fallback.ably-realtime.com"
  ];
}
function getFallbackHosts(options) {
  const fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== "undefined" ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;
  return fallbackHosts ? arrChooseN(fallbackHosts, httpMaxRetryCount) : [];
}
function getHosts(options) {
  return [options.restHost].concat(getFallbackHosts(options));
}
function checkHost(host) {
  if (typeof host !== "string") {
    throw new ErrorInfo("host must be a string; was a " + typeof host, 4e4, 400);
  }
  if (!host.length) {
    throw new ErrorInfo("host must not be zero-length", 4e4, 400);
  }
}
function getRealtimeHost(options, production, environment) {
  if (options.realtimeHost)
    return options.realtimeHost;
  if (options.restHost) {
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "Defaults.normaliseOptions",
      'restHost is set to "' + options.restHost + '" but realtimeHost is not set, so setting realtimeHost to "' + options.restHost + '" too. If this is not what you want, please set realtimeHost explicitly.'
    );
    return options.restHost;
  }
  return production ? Defaults.REALTIME_HOST : environment + "-" + Defaults.REALTIME_HOST;
}
function getTimeouts(options) {
  const timeouts = {};
  for (const prop in Defaults.TIMEOUTS) {
    timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];
  }
  return timeouts;
}
function getAgentString(options) {
  let agentStr = Defaults.agent;
  if (options.agents) {
    for (var agent2 in options.agents) {
      agentStr += " " + agent2 + "/" + options.agents[agent2];
    }
  }
  return agentStr;
}
function objectifyOptions(options) {
  if (typeof options == "string") {
    return options.indexOf(":") == -1 ? { token: options } : { key: options };
  }
  return options;
}
function normaliseOptions(options) {
  var _a2;
  if (typeof options.recover === "function" && options.closeOnUnload === true) {
    logger_default.logAction(
      logger_default.LOG_ERROR,
      "Defaults.normaliseOptions",
      "closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter"
    );
    options.recover = void 0;
  }
  if (!("closeOnUnload" in options)) {
    options.closeOnUnload = !options.recover;
  }
  if (!("queueMessages" in options))
    options.queueMessages = true;
  const environment = options.environment && String(options.environment).toLowerCase() || Defaults.ENVIRONMENT;
  const production = !environment || environment === "production";
  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {
    options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);
  }
  const restHost = options.restHost || (production ? Defaults.REST_HOST : environment + "-" + Defaults.REST_HOST);
  const realtimeHost = getRealtimeHost(options, production, environment);
  arrForEach((options.fallbackHosts || []).concat(restHost, realtimeHost), checkHost);
  options.port = options.port || Defaults.PORT;
  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;
  if (!("tls" in options))
    options.tls = true;
  const timeouts = getTimeouts(options);
  if ("useBinaryProtocol" in options) {
    options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;
  } else {
    options.useBinaryProtocol = Platform.Config.preferBinary;
  }
  const headers = {};
  if (options.clientId) {
    headers["X-Ably-ClientId"] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));
  }
  if (!("idempotentRestPublishing" in options)) {
    options.idempotentRestPublishing = true;
  }
  let connectivityCheckParams = null;
  let connectivityCheckUrl = options.connectivityCheckUrl;
  if (options.connectivityCheckUrl) {
    let [uri, qs] = options.connectivityCheckUrl.split("?");
    connectivityCheckParams = qs ? parseQueryString(qs) : {};
    if (uri.indexOf("://") === -1) {
      uri = "https://" + uri;
    }
    connectivityCheckUrl = uri;
  }
  return __spreadProps(__spreadValues({}, options), {
    useBinaryProtocol: "useBinaryProtocol" in options ? Platform.Config.supportsBinary && options.useBinaryProtocol : Platform.Config.preferBinary,
    realtimeHost,
    restHost,
    maxMessageSize: ((_a2 = options.internal) == null ? void 0 : _a2.maxMessageSize) || Defaults.maxMessageSize,
    timeouts,
    connectivityCheckParams,
    connectivityCheckUrl,
    headers
  });
}
var contentTypes = {
  json: "application/json",
  xml: "application/xml",
  html: "text/html",
  msgpack: "application/x-msgpack"
};
var defaultHeadersOptions = {
  format: "json" /* json */,
  protocolVersion: Defaults.protocolVersion
};
function defaultGetHeaders(options, {
  format = defaultHeadersOptions.format,
  protocolVersion = defaultHeadersOptions.protocolVersion
} = {}) {
  const accept = contentTypes[format];
  return {
    accept,
    "X-Ably-Version": protocolVersion.toString(),
    "Ably-Agent": getAgentString(options)
  };
}
function defaultPostHeaders(options, {
  format = defaultHeadersOptions.format,
  protocolVersion = defaultHeadersOptions.protocolVersion
} = {}) {
  let contentType;
  const accept = contentType = contentTypes[format];
  return {
    accept,
    "content-type": contentType,
    "X-Ably-Version": protocolVersion.toString(),
    "Ably-Agent": getAgentString(options)
  };
}
var defaults_default = Defaults;
function getDefaults(platformDefaults) {
  return Object.assign(Defaults, platformDefaults);
}

// src/common/lib/util/multicaster.ts
var Multicaster = class _Multicaster {
  // Private constructor; use static Multicaster.create instead
  constructor(members) {
    this.members = members || [];
  }
  call(...args) {
    for (const member of this.members) {
      if (member) {
        try {
          member(...args);
        } catch (e) {
          logger_default.logAction(
            logger_default.LOG_ERROR,
            "Multicaster multiple callback handler",
            "Unexpected exception: " + e + "; stack = " + e.stack
          );
        }
      }
    }
  }
  push(...args) {
    this.members.push(...args);
  }
  static create(members) {
    const instance = new _Multicaster(members);
    return Object.assign((...args) => instance.call(...args), {
      push: (fn) => instance.push(fn)
    });
  }
};
var multicaster_default = Multicaster;

// src/common/constants/HttpMethods.ts
var HttpMethods = /* @__PURE__ */ ((HttpMethods2) => {
  HttpMethods2["Get"] = "get";
  HttpMethods2["Delete"] = "delete";
  HttpMethods2["Post"] = "post";
  HttpMethods2["Put"] = "put";
  HttpMethods2["Patch"] = "patch";
  return HttpMethods2;
})(HttpMethods || {});
var HttpMethods_default = HttpMethods;

// src/common/lib/client/auth.ts
var MAX_TOKEN_LENGTH = Math.pow(2, 17);
function noop() {
}
function random() {
  return ("000000" + Math.floor(Math.random() * 1e16)).slice(-16);
}
function normaliseAuthcallbackError(err) {
  if (!isErrorInfoOrPartialErrorInfo(err)) {
    return new ErrorInfo(inspectError(err), err.code || 40170, err.statusCode || 401);
  }
  if (!err.code) {
    if (err.statusCode === 403) {
      err.code = 40300;
    } else {
      err.code = 40170;
      err.statusCode = 401;
    }
  }
  return err;
}
var hmac = (text, key) => {
  const bufferUtils = Platform.BufferUtils;
  const textBuffer = bufferUtils.utf8Encode(text);
  const keyBuffer = bufferUtils.utf8Encode(key);
  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);
  return bufferUtils.base64Encode(digest);
};
function c14n(capability) {
  if (!capability)
    return "";
  if (typeof capability == "string")
    capability = JSON.parse(capability);
  const c14nCapability = /* @__PURE__ */ Object.create(null);
  const keys = keysArray(capability, true);
  if (!keys)
    return "";
  keys.sort();
  for (let i = 0; i < keys.length; i++) {
    c14nCapability[keys[i]] = capability[keys[i]].sort();
  }
  return JSON.stringify(c14nCapability);
}
function logAndValidateTokenAuthMethod(authOptions) {
  if (authOptions.authCallback) {
    logger_default.logAction(logger_default.LOG_MINOR, "Auth()", "using token auth with authCallback");
  } else if (authOptions.authUrl) {
    logger_default.logAction(logger_default.LOG_MINOR, "Auth()", "using token auth with authUrl");
  } else if (authOptions.key) {
    logger_default.logAction(logger_default.LOG_MINOR, "Auth()", "using token auth with client-side signing");
  } else if (authOptions.tokenDetails) {
    logger_default.logAction(logger_default.LOG_MINOR, "Auth()", "using token auth with supplied token only");
  } else {
    const msg = "authOptions must include valid authentication parameters";
    logger_default.logAction(logger_default.LOG_ERROR, "Auth()", msg);
    throw new Error(msg);
  }
}
function basicAuthForced(options) {
  return "useTokenAuth" in options && !options.useTokenAuth;
}
function useTokenAuth(options) {
  return options.useTokenAuth || !basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails);
}
function noWayToRenew(options) {
  return !options.key && !options.authCallback && !options.authUrl;
}
var trId = 0;
function getTokenRequestId() {
  return trId++;
}
var Auth = class {
  constructor(client, options) {
    // This initialization is always overwritten and only used to prevent a TypeScript compiler error
    this.authOptions = {};
    this.client = client;
    this.tokenParams = options.defaultTokenParams || {};
    this.currentTokenRequestId = null;
    this.waitingForTokenRequest = null;
    if (useTokenAuth(options)) {
      if (noWayToRenew(options)) {
        logger_default.logAction(
          logger_default.LOG_ERROR,
          "Auth()",
          "Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help"
        );
      }
      this._saveTokenOptions(options.defaultTokenParams, options);
      logAndValidateTokenAuthMethod(this.authOptions);
    } else {
      if (!options.key) {
        const msg = "No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)";
        logger_default.logAction(logger_default.LOG_ERROR, "Auth()", msg);
        throw new ErrorInfo(msg, 40160, 401);
      }
      logger_default.logAction(logger_default.LOG_MINOR, "Auth()", "anonymous, using basic auth");
      this._saveBasicOptions(options);
    }
  }
  authorize(tokenParams, authOptions, callback) {
    let _authOptions;
    if (typeof tokenParams == "function" && !callback) {
      callback = tokenParams;
      _authOptions = tokenParams = null;
    } else if (typeof authOptions == "function" && !callback) {
      callback = authOptions;
      _authOptions = null;
    } else {
      _authOptions = authOptions;
    }
    if (!callback) {
      return promisify(this, "authorize", arguments);
    }
    if (_authOptions && _authOptions.key && this.authOptions.key !== _authOptions.key) {
      throw new ErrorInfo("Unable to update auth options with incompatible key", 40102, 401);
    }
    this._forceNewToken(
      tokenParams,
      _authOptions,
      (err, tokenDetails) => {
        if (err) {
          if (isRealtime(this.client)) {
            this.client.connection.connectionManager.actOnErrorFromAuthorize(err);
          }
          callback == null ? void 0 : callback(err);
          return;
        }
        if (isRealtime(this.client)) {
          this.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback || noop);
        } else {
          callback == null ? void 0 : callback(null, tokenDetails);
        }
      }
    );
  }
  /* For internal use, eg by connectionManager - useful when want to call back
   * as soon as we have the new token, rather than waiting for it to take
   * effect on the connection as #authorize does */
  _forceNewToken(tokenParams, authOptions, callback) {
    this.tokenDetails = null;
    this._saveTokenOptions(tokenParams, authOptions);
    logAndValidateTokenAuthMethod(this.authOptions);
    this._ensureValidAuthCredentials(true, (err, tokenDetails) => {
      delete this.tokenParams.timestamp;
      delete this.authOptions.queryTime;
      callback(err, tokenDetails);
    });
  }
  requestToken(tokenParams, authOptions, callback) {
    if (typeof tokenParams == "function" && !callback) {
      callback = tokenParams;
      authOptions = tokenParams = null;
    } else if (typeof authOptions == "function" && !callback) {
      callback = authOptions;
      authOptions = null;
    }
    if (!callback) {
      return promisify(this, "requestToken", arguments);
    }
    authOptions = authOptions || this.authOptions;
    tokenParams = tokenParams || copy(this.tokenParams);
    const _callback = callback || noop;
    let tokenRequestCallback, client = this.client;
    if (authOptions.authCallback) {
      logger_default.logAction(logger_default.LOG_MINOR, "Auth.requestToken()", "using token auth with authCallback");
      tokenRequestCallback = authOptions.authCallback;
    } else if (authOptions.authUrl) {
      logger_default.logAction(logger_default.LOG_MINOR, "Auth.requestToken()", "using token auth with authUrl");
      tokenRequestCallback = (params, cb) => {
        const authHeaders = mixin({ accept: "application/json, text/plain" }, authOptions.authHeaders);
        const usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === "post";
        let providedQsParams;
        const queryIdx = authOptions.authUrl.indexOf("?");
        if (queryIdx > -1) {
          providedQsParams = parseQueryString(authOptions.authUrl.slice(queryIdx));
          authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);
          if (!usePost) {
            authOptions.authParams = mixin(providedQsParams, authOptions.authParams);
          }
        }
        const authParams = mixin({}, authOptions.authParams || {}, params);
        const authUrlRequestCallback = function(err, body, headers, unpacked) {
          let contentType;
          if (err) {
            logger_default.logAction(
              logger_default.LOG_MICRO,
              "Auth.requestToken().tokenRequestCallback",
              "Received Error: " + inspectError(err)
            );
          } else {
            contentType = headers["content-type"];
            logger_default.logAction(
              logger_default.LOG_MICRO,
              "Auth.requestToken().tokenRequestCallback",
              "Received; content-type: " + contentType + "; body: " + inspectBody(body)
            );
          }
          if (err || unpacked)
            return cb(err, body);
          if (Platform.BufferUtils.isBuffer(body))
            body = body.toString();
          if (!contentType) {
            cb(new ErrorInfo("authUrl response is missing a content-type header", 40170, 401));
            return;
          }
          const json = contentType.indexOf("application/json") > -1, text = contentType.indexOf("text/plain") > -1 || contentType.indexOf("application/jwt") > -1;
          if (!json && !text) {
            cb(
              new ErrorInfo(
                "authUrl responded with unacceptable content-type " + contentType + ", should be either text/plain, application/jwt or application/json",
                40170,
                401
              )
            );
            return;
          }
          if (json) {
            if (body.length > MAX_TOKEN_LENGTH) {
              cb(new ErrorInfo("authUrl response exceeded max permitted length", 40170, 401));
              return;
            }
            try {
              body = JSON.parse(body);
            } catch (e) {
              cb(
                new ErrorInfo("Unexpected error processing authURL response; err = " + e.message, 40170, 401)
              );
              return;
            }
          }
          cb(null, body, contentType);
        };
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "Auth.requestToken().tokenRequestCallback",
          "Requesting token from " + authOptions.authUrl + "; Params: " + JSON.stringify(authParams) + "; method: " + (usePost ? "POST" : "GET")
        );
        if (usePost) {
          const headers = authHeaders || {};
          headers["content-type"] = "application/x-www-form-urlencoded";
          const body = toQueryString(authParams).slice(1);
          this.client.http.doUri(
            HttpMethods_default.Post,
            client,
            authOptions.authUrl,
            headers,
            body,
            providedQsParams,
            authUrlRequestCallback
          );
        } else {
          this.client.http.doUri(
            HttpMethods_default.Get,
            client,
            authOptions.authUrl,
            authHeaders || {},
            null,
            authParams,
            authUrlRequestCallback
          );
        }
      };
    } else if (authOptions.key) {
      logger_default.logAction(logger_default.LOG_MINOR, "Auth.requestToken()", "using token auth with client-side signing");
      tokenRequestCallback = (params, cb) => {
        this.createTokenRequest(params, authOptions, cb);
      };
    } else {
      const msg = "Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)";
      logger_default.logAction(
        logger_default.LOG_ERROR,
        "Auth()",
        "library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help"
      );
      _callback(new ErrorInfo(msg, 40171, 403));
      return;
    }
    if ("capability" in tokenParams)
      tokenParams.capability = c14n(tokenParams.capability);
    const tokenRequest = (signedTokenParams, tokenCb) => {
      const keyName = signedTokenParams.keyName, path = "/keys/" + keyName + "/requestToken", tokenUri = function(host) {
        return client.baseUri(host) + path;
      };
      const requestHeaders = defaults_default.defaultPostHeaders(this.client.options);
      if (authOptions.requestHeaders)
        mixin(requestHeaders, authOptions.requestHeaders);
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "Auth.requestToken().requestToken",
        "Sending POST to " + path + "; Token params: " + JSON.stringify(signedTokenParams)
      );
      this.client.http.do(
        HttpMethods_default.Post,
        client,
        tokenUri,
        requestHeaders,
        JSON.stringify(signedTokenParams),
        null,
        tokenCb
      );
    };
    let tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(function() {
      tokenRequestCallbackTimeoutExpired = true;
      const msg = "Token request callback timed out after " + timeoutLength / 1e3 + " seconds";
      logger_default.logAction(logger_default.LOG_ERROR, "Auth.requestToken()", msg);
      _callback(new ErrorInfo(msg, 40170, 401));
    }, timeoutLength);
    tokenRequestCallback(tokenParams, function(err, tokenRequestOrDetails, contentType) {
      if (tokenRequestCallbackTimeoutExpired)
        return;
      clearTimeout(tokenRequestCallbackTimeout);
      if (err) {
        logger_default.logAction(
          logger_default.LOG_ERROR,
          "Auth.requestToken()",
          "token request signing call returned error; err = " + inspectError(err)
        );
        _callback(normaliseAuthcallbackError(err));
        return;
      }
      if (typeof tokenRequestOrDetails === "string") {
        if (tokenRequestOrDetails.length === 0) {
          _callback(new ErrorInfo("Token string is empty", 40170, 401));
        } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {
          _callback(
            new ErrorInfo(
              "Token string exceeded max permitted length (was " + tokenRequestOrDetails.length + " bytes)",
              40170,
              401
            )
          );
        } else if (tokenRequestOrDetails === "undefined" || tokenRequestOrDetails === "null") {
          _callback(new ErrorInfo("Token string was literal null/undefined", 40170, 401));
        } else if (tokenRequestOrDetails[0] === "{" && !(contentType && contentType.indexOf("application/jwt") > -1)) {
          _callback(
            new ErrorInfo(
              "Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details",
              40170,
              401
            )
          );
        } else {
          _callback(null, { token: tokenRequestOrDetails });
        }
        return;
      }
      if (typeof tokenRequestOrDetails !== "object") {
        const msg = "Expected token request callback to call back with a token string or token request/details object, but got a " + typeof tokenRequestOrDetails;
        logger_default.logAction(logger_default.LOG_ERROR, "Auth.requestToken()", msg);
        _callback(new ErrorInfo(msg, 40170, 401));
        return;
      }
      const objectSize = JSON.stringify(tokenRequestOrDetails).length;
      if (objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {
        _callback(
          new ErrorInfo(
            "Token request/details object exceeded max permitted stringified size (was " + objectSize + " bytes)",
            40170,
            401
          )
        );
        return;
      }
      if ("issued" in tokenRequestOrDetails) {
        _callback(null, tokenRequestOrDetails);
        return;
      }
      if (!("keyName" in tokenRequestOrDetails)) {
        const msg = "Expected token request callback to call back with a token string, token request object, or token details object";
        logger_default.logAction(logger_default.LOG_ERROR, "Auth.requestToken()", msg);
        _callback(new ErrorInfo(msg, 40170, 401));
        return;
      }
      tokenRequest(
        tokenRequestOrDetails,
        function(err2, tokenResponse, headers, unpacked) {
          if (err2) {
            logger_default.logAction(
              logger_default.LOG_ERROR,
              "Auth.requestToken()",
              "token request API call returned error; err = " + inspectError(err2)
            );
            _callback(normaliseAuthcallbackError(err2));
            return;
          }
          if (!unpacked)
            tokenResponse = JSON.parse(tokenResponse);
          logger_default.logAction(logger_default.LOG_MINOR, "Auth.getToken()", "token received");
          _callback(null, tokenResponse);
        }
      );
    });
  }
  /**
   * Create and sign a token request based on the given options.
   * NOTE this can only be used when the key value is available locally.
   * Otherwise, signed token requests must be obtained from the key
   * owner (either using the token request callback or url).
   *
   * @param authOptions
   * an object containing the request options:
   * - key:           the key to use. If not specified, a key passed in constructing
   *                  the Rest interface will be used
   *
   * - queryTime      (optional) boolean indicating that the ably system should be
   *                  queried for the current time when none is specified explicitly
   *
   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
   *                  requestToken request
   *
   * @param tokenParams
   * an object containing the parameters for the requested token:
   * - ttl:       (optional) the requested life of the token in ms. If none is specified
   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
   *                  exceeding that lifetime will be rejected with an error.
   *
   * - capability:    (optional) the capability to associate with the access token.
   *                  If none is specified, a token will be requested with all of the
   *                  capabilities of the specified key.
   *
   * - clientId:      (optional) a client ID to associate with the token; if not
   *                  specified, a clientId passed in constructing the Rest interface will be used
   *
   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
   *                  the system will be queried for a time value to use.
   *
   * @param callback
   */
  createTokenRequest(tokenParams, authOptions, callback) {
    if (typeof tokenParams == "function" && !callback) {
      callback = tokenParams;
      authOptions = tokenParams = null;
    } else if (typeof authOptions == "function" && !callback) {
      callback = authOptions;
      authOptions = null;
    }
    if (!callback) {
      return promisify(this, "createTokenRequest", arguments);
    }
    authOptions = authOptions || this.authOptions;
    tokenParams = tokenParams || copy(this.tokenParams);
    const key = authOptions.key;
    if (!key) {
      callback(new ErrorInfo("No key specified", 40101, 403));
      return;
    }
    const keyParts = key.split(":"), keyName = keyParts[0], keySecret = keyParts[1];
    if (!keySecret) {
      callback(new ErrorInfo("Invalid key specified", 40101, 403));
      return;
    }
    if (tokenParams.clientId === "") {
      callback(new ErrorInfo("clientId can\u2019t be an empty string", 40012, 400));
      return;
    }
    if ("capability" in tokenParams) {
      tokenParams.capability = c14n(tokenParams.capability);
    }
    const request = mixin({ keyName }, tokenParams), clientId = tokenParams.clientId || "", ttl = tokenParams.ttl || "", capability = tokenParams.capability || "";
    ((authoriseCb) => {
      if (request.timestamp) {
        authoriseCb();
        return;
      }
      this.getTimestamp(authOptions && authOptions.queryTime, function(err, time) {
        if (err) {
          callback(err);
          return;
        }
        request.timestamp = time;
        authoriseCb();
      });
    })(function() {
      const nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;
      const signText = request.keyName + "\n" + ttl + "\n" + capability + "\n" + clientId + "\n" + timestamp + "\n" + nonce + "\n";
      request.mac = request.mac || hmac(signText, keySecret);
      logger_default.logAction(logger_default.LOG_MINOR, "Auth.getTokenRequest()", "generated signed request");
      callback(null, request);
    });
  }
  /**
   * Get the auth query params to use for a websocket connection,
   * based on the current auth parameters
   */
  getAuthParams(callback) {
    if (this.method == "basic")
      callback(null, { key: this.key });
    else
      this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
        if (err) {
          callback(err);
          return;
        }
        if (!tokenDetails) {
          throw new Error("Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails");
        }
        callback(null, { access_token: tokenDetails.token });
      });
  }
  /**
   * Get the authorization header to use for a REST or comet request,
   * based on the current auth parameters
   */
  getAuthHeaders(callback) {
    if (this.method == "basic") {
      callback(null, { authorization: "Basic " + this.basicKey });
    } else {
      this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
        if (err) {
          callback(err);
          return;
        }
        if (!tokenDetails) {
          throw new Error("Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails");
        }
        callback(null, { authorization: "Bearer " + toBase64(tokenDetails.token) });
      });
    }
  }
  /**
   * Get the current time based on the local clock,
   * or if the option queryTime is true, return the server time.
   * The server time offset from the local time is stored so that
   * only one request to the server to get the time is ever needed
   */
  getTimestamp(queryTime, callback) {
    if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {
      this.client.time(callback);
    } else {
      callback(null, this.getTimestampUsingOffset());
    }
  }
  getTimestampUsingOffset() {
    return now() + (this.client.serverTimeOffset || 0);
  }
  isTimeOffsetSet() {
    return this.client.serverTimeOffset !== null;
  }
  _saveBasicOptions(authOptions) {
    this.method = "basic";
    this.key = authOptions.key;
    this.basicKey = toBase64(authOptions.key);
    this.authOptions = authOptions || {};
    if ("clientId" in authOptions) {
      this._userSetClientId(authOptions.clientId);
    }
  }
  _saveTokenOptions(tokenParams, authOptions) {
    this.method = "token";
    if (tokenParams) {
      this.tokenParams = tokenParams;
    }
    if (authOptions) {
      if (authOptions.token) {
        authOptions.tokenDetails = typeof authOptions.token === "string" ? { token: authOptions.token } : authOptions.token;
      }
      if (authOptions.tokenDetails) {
        this.tokenDetails = authOptions.tokenDetails;
      }
      if ("clientId" in authOptions) {
        this._userSetClientId(authOptions.clientId);
      }
      this.authOptions = authOptions;
    }
  }
  /* @param forceSupersede: force a new token request even if there's one in
   * progress, making all pending callbacks wait for the new one */
  _ensureValidAuthCredentials(forceSupersede, callback) {
    const token = this.tokenDetails;
    if (token) {
      if (this._tokenClientIdMismatch(token.clientId)) {
        callback(
          new ErrorInfo(
            "Mismatch between clientId in token (" + token.clientId + ") and current clientId (" + this.clientId + ")",
            40102,
            403
          )
        );
        return;
      }
      if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {
        logger_default.logAction(logger_default.LOG_MINOR, "Auth.getToken()", "using cached token; expires = " + token.expires);
        callback(null, token);
        return;
      }
      logger_default.logAction(logger_default.LOG_MINOR, "Auth.getToken()", "deleting expired token");
      this.tokenDetails = null;
    }
    (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_default.create())).push(callback);
    if (this.currentTokenRequestId !== null && !forceSupersede) {
      return;
    }
    const tokenRequestId = this.currentTokenRequestId = getTokenRequestId();
    this.requestToken(this.tokenParams, this.authOptions, (err, tokenResponse) => {
      if (this.currentTokenRequestId > tokenRequestId) {
        logger_default.logAction(
          logger_default.LOG_MINOR,
          "Auth._ensureValidAuthCredentials()",
          "Discarding token request response; overtaken by newer one"
        );
        return;
      }
      this.currentTokenRequestId = null;
      const callbacks = this.waitingForTokenRequest || noop;
      this.waitingForTokenRequest = null;
      if (err) {
        callbacks(err);
        return;
      }
      callbacks(null, this.tokenDetails = tokenResponse);
    });
  }
  /* User-set: check types, '*' is disallowed, throw any errors */
  _userSetClientId(clientId) {
    if (!(typeof clientId === "string" || clientId === null)) {
      throw new ErrorInfo("clientId must be either a string or null", 40012, 400);
    } else if (clientId === "*") {
      throw new ErrorInfo(
        'Can\u2019t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: "*"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: "*"}, authOptions)',
        40012,
        400
      );
    } else {
      const err = this._uncheckedSetClientId(clientId);
      if (err)
        throw err;
    }
  }
  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */
  _uncheckedSetClientId(clientId) {
    if (this._tokenClientIdMismatch(clientId)) {
      const msg = "Unexpected clientId mismatch: client has " + this.clientId + ", requested " + clientId;
      const err = new ErrorInfo(msg, 40102, 401);
      logger_default.logAction(logger_default.LOG_ERROR, "Auth._uncheckedSetClientId()", msg);
      return err;
    } else {
      this.clientId = this.tokenParams.clientId = clientId;
      return null;
    }
  }
  _tokenClientIdMismatch(tokenClientId) {
    return !!(this.clientId && this.clientId !== "*" && tokenClientId && tokenClientId !== "*" && this.clientId !== tokenClientId);
  }
  static isTokenErr(error) {
    return error.code && error.code >= 40140 && error.code < 40150;
  }
};
var auth_default = Auth;

// src/common/lib/client/baseclient.ts
var BaseClient = class {
  constructor(options, modules) {
    if (!options) {
      const msg = "no options provided";
      logger_default.logAction(logger_default.LOG_ERROR, "Rest()", msg);
      throw new Error(msg);
    }
    const optionsObj = defaults_default.objectifyOptions(options);
    logger_default.setLog(optionsObj.logLevel, optionsObj.logHandler);
    logger_default.logAction(logger_default.LOG_MICRO, "Rest()", "initialized with clientOptions " + Platform.Config.inspect(options));
    const normalOptions = this.options = defaults_default.normaliseOptions(optionsObj);
    if (normalOptions.key) {
      const keyMatch = normalOptions.key.match(/^([^:\s]+):([^:.\s]+)$/);
      if (!keyMatch) {
        const msg = "invalid key parameter";
        logger_default.logAction(logger_default.LOG_ERROR, "Rest()", msg);
        throw new ErrorInfo(msg, 40400, 404);
      }
      normalOptions.keyName = keyMatch[1];
      normalOptions.keySecret = keyMatch[2];
    }
    if ("clientId" in normalOptions) {
      if (!(typeof normalOptions.clientId === "string" || normalOptions.clientId === null))
        throw new ErrorInfo("clientId must be either a string or null", 40012, 400);
      else if (normalOptions.clientId === "*")
        throw new ErrorInfo(
          'Can\u2019t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: "*"}})',
          40012,
          400
        );
    }
    logger_default.logAction(logger_default.LOG_MINOR, "Rest()", "started; version = " + defaults_default.version);
    this.baseUri = this.authority = function(host) {
      return defaults_default.getHttpScheme(normalOptions) + host + ":" + defaults_default.getPort(normalOptions, false);
    };
    this._currentFallback = null;
    this.serverTimeOffset = null;
    this.http = new Platform.Http(normalOptions);
    this.auth = new auth_default(this, normalOptions);
    if (modules == null ? void 0 : modules.Rest) {
      this._rest = new modules.Rest(this);
    }
  }
  get rest() {
    if (!this._rest) {
      throw new ErrorInfo("Rest module not provided", 400, 4e4);
    }
    return this._rest;
  }
  get channels() {
    return this.rest.channels;
  }
  get push() {
    return this.rest.push;
  }
  stats(params, callback) {
    return this.rest.stats(params, callback);
  }
  time(params, callback) {
    return this.rest.time(params, callback);
  }
  request(method, path, version2, params, body, customHeaders, callback) {
    return this.rest.request(method, path, version2, params, body, customHeaders, callback);
  }
  setLog(logOptions) {
    logger_default.setLog(logOptions.level, logOptions.handler);
  }
};
BaseClient.Platform = Platform;

// src/common/lib/types/devicedetails.ts
var _DeviceDetails = class _DeviceDetails {
  toJSON() {
    var _a2, _b, _c;
    return {
      id: this.id,
      deviceSecret: this.deviceSecret,
      platform: this.platform,
      formFactor: this.formFactor,
      clientId: this.clientId,
      metadata: this.metadata,
      deviceIdentityToken: this.deviceIdentityToken,
      push: {
        recipient: (_a2 = this.push) == null ? void 0 : _a2.recipient,
        state: (_b = this.push) == null ? void 0 : _b.state,
        error: (_c = this.push) == null ? void 0 : _c.error
      }
    };
  }
  toString() {
    var _a2, _b, _c, _d;
    let result = "[DeviceDetails";
    if (this.id)
      result += "; id=" + this.id;
    if (this.platform)
      result += "; platform=" + this.platform;
    if (this.formFactor)
      result += "; formFactor=" + this.formFactor;
    if (this.clientId)
      result += "; clientId=" + this.clientId;
    if (this.metadata)
      result += "; metadata=" + this.metadata;
    if (this.deviceIdentityToken)
      result += "; deviceIdentityToken=" + JSON.stringify(this.deviceIdentityToken);
    if ((_a2 = this.push) == null ? void 0 : _a2.recipient)
      result += "; push.recipient=" + JSON.stringify(this.push.recipient);
    if ((_b = this.push) == null ? void 0 : _b.state)
      result += "; push.state=" + this.push.state;
    if ((_c = this.push) == null ? void 0 : _c.error)
      result += "; push.error=" + JSON.stringify(this.push.error);
    if ((_d = this.push) == null ? void 0 : _d.metadata)
      result += "; push.metadata=" + this.push.metadata;
    result += "]";
    return result;
  }
  static fromResponseBody(body, format) {
    if (format) {
      body = decodeBody(body, format);
    }
    if (isArray(body)) {
      return _DeviceDetails.fromValuesArray(body);
    } else {
      return _DeviceDetails.fromValues(body);
    }
  }
  static fromValues(values) {
    values.error = values.error && ErrorInfo.fromValues(values.error);
    return Object.assign(new _DeviceDetails(), values);
  }
  static fromValuesArray(values) {
    const count = values.length, result = new Array(count);
    for (let i = 0; i < count; i++)
      result[i] = _DeviceDetails.fromValues(values[i]);
    return result;
  }
};
_DeviceDetails.toRequestBody = encodeBody;
var DeviceDetails = _DeviceDetails;
var devicedetails_default = DeviceDetails;

// src/common/lib/client/resource.ts
function withAuthDetails(client, headers, params, errCallback, opCallback) {
  if (client.http.supportsAuthHeaders) {
    client.auth.getAuthHeaders(function(err, authHeaders) {
      if (err)
        errCallback(err);
      else
        opCallback(mixin(authHeaders, headers), params);
    });
  } else {
    client.auth.getAuthParams(function(err, authParams) {
      if (err)
        errCallback(err);
      else
        opCallback(headers, mixin(authParams, params));
    });
  }
}
function unenvelope(callback, format) {
  return (err, body, outerHeaders, unpacked, outerStatusCode) => {
    if (err && !body) {
      callback(err);
      return;
    }
    if (!unpacked) {
      try {
        body = decodeBody(body, format);
      } catch (e) {
        if (isErrorInfoOrPartialErrorInfo(e)) {
          callback(e);
        } else {
          callback(new PartialErrorInfo(inspectError(e), null));
        }
        return;
      }
    }
    if (!body) {
      callback(new PartialErrorInfo("unenvelope(): Response body is missing", null));
      return;
    }
    const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body;
    if (wrappedStatusCode === void 0) {
      callback(err, body, outerHeaders, true, outerStatusCode);
      return;
    }
    if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {
      let wrappedErr = response && response.error || err;
      if (!wrappedErr) {
        wrappedErr = new Error("Error in unenveloping " + body);
        wrappedErr.statusCode = wrappedStatusCode;
      }
      callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);
      return;
    }
    callback(err, response, wrappedHeaders, true, wrappedStatusCode);
  };
}
function paramString(params) {
  const paramPairs = [];
  if (params) {
    for (const needle in params) {
      paramPairs.push(needle + "=" + params[needle]);
    }
  }
  return paramPairs.join("&");
}
function urlFromPathAndParams(path, params) {
  return path + (params ? "?" : "") + paramString(params);
}
function logResponseHandler(callback, method, path, params) {
  return (err, body, headers, unpacked, statusCode) => {
    if (err) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "Resource." + method + "()",
        "Received Error; " + urlFromPathAndParams(path, params) + "; Error: " + inspectError(err)
      );
    } else {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "Resource." + method + "()",
        "Received; " + urlFromPathAndParams(path, params) + "; Headers: " + paramString(headers) + "; StatusCode: " + statusCode + "; Body: " + (Platform.BufferUtils.isBuffer(body) ? body.toString() : body)
      );
    }
    if (callback) {
      callback(err, body, headers, unpacked, statusCode);
    }
  };
}
var Resource = class _Resource {
  static get(client, path, headers, params, envelope, callback) {
    _Resource.do(HttpMethods_default.Get, client, path, null, headers, params, envelope, callback);
  }
  static delete(client, path, headers, params, envelope, callback) {
    _Resource.do(HttpMethods_default.Delete, client, path, null, headers, params, envelope, callback);
  }
  static post(client, path, body, headers, params, envelope, callback) {
    _Resource.do(HttpMethods_default.Post, client, path, body, headers, params, envelope, callback);
  }
  static patch(client, path, body, headers, params, envelope, callback) {
    _Resource.do(HttpMethods_default.Patch, client, path, body, headers, params, envelope, callback);
  }
  static put(client, path, body, headers, params, envelope, callback) {
    _Resource.do(HttpMethods_default.Put, client, path, body, headers, params, envelope, callback);
  }
  static do(method, client, path, body, headers, params, envelope, callback) {
    if (logger_default.shouldLog(logger_default.LOG_MICRO)) {
      callback = logResponseHandler(callback, method, path, params);
    }
    if (envelope) {
      callback = callback && unenvelope(callback, envelope);
      (params = params || {})["envelope"] = envelope;
    }
    function doRequest(headers2, params2) {
      var _a2;
      if (logger_default.shouldLog(logger_default.LOG_MICRO)) {
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "Resource." + method + "()",
          "Sending; " + urlFromPathAndParams(path, params2)
        );
      }
      if (logger_default.shouldLog(logger_default.LOG_MICRO)) {
        let decodedBody = body;
        if (((_a2 = headers2["content-type"]) == null ? void 0 : _a2.indexOf("msgpack")) > 0) {
          try {
            decodedBody = Platform.Config.msgpack.decode(body);
          } catch (decodeErr) {
            logger_default.logAction(
              logger_default.LOG_MICRO,
              "Resource." + method + "()",
              "Sending MsgPack Decoding Error: " + inspectError(decodeErr)
            );
          }
        }
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "Resource." + method + "()",
          "Sending; " + urlFromPathAndParams(path, params2) + "; Body: " + decodedBody
        );
      }
      client.http.do(
        method,
        client,
        path,
        headers2,
        body,
        params2,
        function(err, res, headers3, unpacked, statusCode) {
          if (err && auth_default.isTokenErr(err)) {
            client.auth.authorize(null, null, function(err2) {
              if (err2) {
                callback(err2);
                return;
              }
              withAuthDetails(client, headers3, params2, callback, doRequest);
            });
            return;
          }
          callback(err, res, headers3, unpacked, statusCode);
        }
      );
    }
    withAuthDetails(client, headers, params, callback, doRequest);
  }
};
var resource_default = Resource;

// src/common/lib/client/paginatedresource.ts
function getRelParams(linkUrl) {
  const urlMatch = linkUrl.match(/^\.\/(\w+)\?(.*)$/);
  return urlMatch && urlMatch[2] && parseQueryString(urlMatch[2]);
}
function parseRelLinks(linkHeader) {
  if (typeof linkHeader == "string")
    linkHeader = linkHeader.split(",");
  const relParams = {};
  for (let i = 0; i < linkHeader.length; i++) {
    const linkMatch = linkHeader[i].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
    if (linkMatch) {
      const params = getRelParams(linkMatch[1]);
      if (params)
        relParams[linkMatch[2]] = params;
    }
  }
  return relParams;
}
function returnErrOnly(err, body, useHPR) {
  return !(useHPR && (body || typeof err.code === "number"));
}
var PaginatedResource = class {
  constructor(client, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {
    this.client = client;
    this.path = path;
    this.headers = headers;
    this.envelope = envelope != null ? envelope : null;
    this.bodyHandler = bodyHandler;
    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;
  }
  get(params, callback) {
    resource_default.get(
      this.client,
      this.path,
      this.headers,
      params,
      this.envelope,
      (err, body, headers, unpacked, statusCode) => {
        this.handlePage(err, body, headers, unpacked, statusCode, callback);
      }
    );
  }
  delete(params, callback) {
    resource_default.delete(
      this.client,
      this.path,
      this.headers,
      params,
      this.envelope,
      (err, body, headers, unpacked, statusCode) => {
        this.handlePage(err, body, headers, unpacked, statusCode, callback);
      }
    );
  }
  post(params, body, callback) {
    resource_default.post(
      this.client,
      this.path,
      body,
      this.headers,
      params,
      this.envelope,
      (err, responseBody, headers, unpacked, statusCode) => {
        if (callback) {
          this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
        }
      }
    );
  }
  put(params, body, callback) {
    resource_default.put(
      this.client,
      this.path,
      body,
      this.headers,
      params,
      this.envelope,
      (err, responseBody, headers, unpacked, statusCode) => {
        if (callback) {
          this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
        }
      }
    );
  }
  patch(params, body, callback) {
    resource_default.patch(
      this.client,
      this.path,
      body,
      this.headers,
      params,
      this.envelope,
      (err, responseBody, headers, unpacked, statusCode) => {
        if (callback) {
          this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
        }
      }
    );
  }
  handlePage(err, body, headers, unpacked, statusCode, callback) {
    if (err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {
      logger_default.logAction(
        logger_default.LOG_ERROR,
        "PaginatedResource.handlePage()",
        "Unexpected error getting resource: err = " + inspectError(err)
      );
      callback == null ? void 0 : callback(err);
      return;
    }
    const handleBody = () => __async(this, null, function* () {
      let items, linkHeader, relParams;
      try {
        items = yield this.bodyHandler(body, headers || {}, unpacked);
      } catch (e) {
        throw err || e;
      }
      if (headers && (linkHeader = headers["Link"] || headers["link"])) {
        relParams = parseRelLinks(linkHeader);
      }
      if (this.useHttpPaginatedResponse) {
        return new HttpPaginatedResponse(this, items, headers || {}, statusCode, relParams, err);
      } else {
        return new PaginatedResult(this, items, relParams);
      }
    });
    handleBody().then((result) => callback(null, result)).catch((err2) => callback(err2, null));
  }
};
var PaginatedResult = class {
  constructor(resource, items, relParams) {
    this.resource = resource;
    this.items = items;
    const self2 = this;
    if (relParams) {
      if ("first" in relParams) {
        this.first = function(callback) {
          if (!callback) {
            return promisify(self2, "first", []);
          }
          self2.get(relParams.first, callback);
        };
      }
      if ("current" in relParams) {
        this.current = function(callback) {
          if (!callback) {
            return promisify(self2, "current", []);
          }
          self2.get(relParams.current, callback);
        };
      }
      this.next = function(callback) {
        if (!callback) {
          return promisify(self2, "next", []);
        }
        if ("next" in relParams) {
          self2.get(relParams.next, callback);
        } else {
          callback(null);
        }
      };
      this.hasNext = function() {
        return "next" in relParams;
      };
      this.isLast = () => {
        var _a2;
        return !((_a2 = this.hasNext) == null ? void 0 : _a2.call(this));
      };
    }
  }
  /* We assume that only the initial request can be a POST, and that accessing
   * the rest of a multipage set of results can always be done with GET */
  get(params, callback) {
    const res = this.resource;
    resource_default.get(
      res.client,
      res.path,
      res.headers,
      params,
      res.envelope,
      function(err, body, headers, unpacked, statusCode) {
        res.handlePage(err, body, headers, unpacked, statusCode, callback);
      }
    );
  }
};
var HttpPaginatedResponse = class extends PaginatedResult {
  constructor(resource, items, headers, statusCode, relParams, err) {
    super(resource, items, relParams);
    this.statusCode = statusCode;
    this.success = statusCode < 300 && statusCode >= 200;
    this.headers = headers;
    this.errorCode = err && err.code;
    this.errorMessage = err && err.message;
  }
  toJSON() {
    return {
      items: this.items,
      statusCode: this.statusCode,
      success: this.success,
      headers: this.headers,
      errorCode: this.errorCode,
      errorMessage: this.errorMessage
    };
  }
};
var paginatedresource_default = PaginatedResource;

// src/common/lib/types/pushchannelsubscription.ts
var _PushChannelSubscription = class _PushChannelSubscription {
  /**
   * Overload toJSON() to intercept JSON.stringify()
   * @return {*}
   */
  toJSON() {
    return {
      channel: this.channel,
      deviceId: this.deviceId,
      clientId: this.clientId
    };
  }
  toString() {
    let result = "[PushChannelSubscription";
    if (this.channel)
      result += "; channel=" + this.channel;
    if (this.deviceId)
      result += "; deviceId=" + this.deviceId;
    if (this.clientId)
      result += "; clientId=" + this.clientId;
    result += "]";
    return result;
  }
  static fromResponseBody(body, format) {
    if (format) {
      body = decodeBody(body, format);
    }
    if (isArray(body)) {
      return _PushChannelSubscription.fromValuesArray(body);
    } else {
      return _PushChannelSubscription.fromValues(body);
    }
  }
  static fromValues(values) {
    return Object.assign(new _PushChannelSubscription(), values);
  }
  static fromValuesArray(values) {
    const count = values.length, result = new Array(count);
    for (let i = 0; i < count; i++)
      result[i] = _PushChannelSubscription.fromValues(values[i]);
    return result;
  }
};
_PushChannelSubscription.toRequestBody = encodeBody;
var PushChannelSubscription = _PushChannelSubscription;
var pushchannelsubscription_default = PushChannelSubscription;

// src/common/lib/client/push.ts
var Push = class {
  constructor(rest) {
    this.rest = rest;
    this.admin = new Admin(rest);
  }
};
var Admin = class {
  constructor(rest) {
    this.rest = rest;
    this.deviceRegistrations = new DeviceRegistrations(rest);
    this.channelSubscriptions = new ChannelSubscriptions(rest);
  }
  publish(recipient, payload, callback) {
    const rest = this.rest;
    const format = rest.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultPostHeaders(rest.options, { format }), params = {};
    const body = mixin({ recipient }, payload);
    if (typeof callback !== "function") {
      return promisify(this, "publish", arguments);
    }
    mixin(headers, rest.options.headers);
    if (rest.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    const requestBody = encodeBody(body, format);
    resource_default.post(rest.client, "/push/publish", requestBody, headers, params, null, (err) => callback(err));
  }
};
var DeviceRegistrations = class {
  constructor(rest) {
    this.rest = rest;
  }
  save(device, callback) {
    const rest = this.rest;
    const body = devicedetails_default.fromValues(device);
    const format = rest.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultPostHeaders(rest.options, { format }), params = {};
    if (typeof callback !== "function") {
      return promisify(this, "save", arguments);
    }
    mixin(headers, rest.options.headers);
    if (rest.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    const requestBody = encodeBody(body, format);
    resource_default.put(
      rest.client,
      "/push/deviceRegistrations/" + encodeURIComponent(device.id),
      requestBody,
      headers,
      params,
      null,
      (err, body2, headers2, unpacked) => {
        callback(
          err,
          !err ? devicedetails_default.fromResponseBody(
            body2,
            unpacked ? void 0 : format
          ) : void 0
        );
      }
    );
  }
  get(deviceIdOrDetails, callback) {
    const rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultGetHeaders(rest.options, { format }), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;
    if (typeof callback !== "function") {
      return promisify(this, "get", arguments);
    }
    if (typeof deviceId !== "string" || !deviceId.length) {
      callback(
        new ErrorInfo(
          "First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails",
          4e4,
          400
        )
      );
      return;
    }
    mixin(headers, rest.options.headers);
    resource_default.get(
      rest.client,
      "/push/deviceRegistrations/" + encodeURIComponent(deviceId),
      headers,
      {},
      null,
      function(err, body, headers2, unpacked) {
        callback(
          err,
          !err ? devicedetails_default.fromResponseBody(
            body,
            unpacked ? void 0 : format
          ) : void 0
        );
      }
    );
  }
  list(params, callback) {
    const rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.rest.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(rest.options, { format });
    if (typeof callback !== "function") {
      return promisify(this, "list", arguments);
    }
    mixin(headers, rest.options.headers);
    new paginatedresource_default(rest.client, "/push/deviceRegistrations", headers, envelope, function(body, headers2, unpacked) {
      return __async(this, null, function* () {
        return devicedetails_default.fromResponseBody(body, unpacked ? void 0 : format);
      });
    }).get(params, callback);
  }
  remove(deviceIdOrDetails, callback) {
    const rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultGetHeaders(rest.options, { format }), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;
    if (typeof callback !== "function") {
      return promisify(this, "remove", arguments);
    }
    if (typeof deviceId !== "string" || !deviceId.length) {
      callback(
        new ErrorInfo(
          "First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails",
          4e4,
          400
        )
      );
      return;
    }
    mixin(headers, rest.options.headers);
    if (rest.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    resource_default["delete"](
      rest.client,
      "/push/deviceRegistrations/" + encodeURIComponent(deviceId),
      headers,
      params,
      null,
      (err) => callback(err)
    );
  }
  removeWhere(params, callback) {
    const rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultGetHeaders(rest.options, { format });
    if (typeof callback !== "function") {
      return promisify(this, "removeWhere", arguments);
    }
    mixin(headers, rest.options.headers);
    if (rest.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    resource_default["delete"](rest.client, "/push/deviceRegistrations", headers, params, null, (err) => callback(err));
  }
};
var ChannelSubscriptions = class _ChannelSubscriptions {
  constructor(rest) {
    /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */
    this.remove = _ChannelSubscriptions.prototype.removeWhere;
    this.rest = rest;
  }
  save(subscription, callback) {
    const rest = this.rest;
    const body = pushchannelsubscription_default.fromValues(subscription);
    const format = rest.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultPostHeaders(rest.options, { format }), params = {};
    if (typeof callback !== "function") {
      return promisify(this, "save", arguments);
    }
    mixin(headers, rest.options.headers);
    if (rest.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    const requestBody = encodeBody(body, format);
    resource_default.post(
      rest.client,
      "/push/channelSubscriptions",
      requestBody,
      headers,
      params,
      null,
      function(err, body2, headers2, unpacked) {
        callback(
          err,
          !err && pushchannelsubscription_default.fromResponseBody(body2, unpacked ? void 0 : format)
        );
      }
    );
  }
  list(params, callback) {
    const rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.rest.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(rest.options, { format });
    if (typeof callback !== "function") {
      return promisify(this, "list", arguments);
    }
    mixin(headers, rest.options.headers);
    new paginatedresource_default(rest.client, "/push/channelSubscriptions", headers, envelope, function(body, headers2, unpacked) {
      return __async(this, null, function* () {
        return pushchannelsubscription_default.fromResponseBody(body, unpacked ? void 0 : format);
      });
    }).get(params, callback);
  }
  removeWhere(params, callback) {
    const rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultGetHeaders(rest.options, { format });
    if (typeof callback !== "function") {
      return promisify(this, "removeWhere", arguments);
    }
    mixin(headers, rest.options.headers);
    if (rest.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    resource_default["delete"](rest.client, "/push/channelSubscriptions", headers, params, null, (err) => callback(err));
  }
  listChannels(params, callback) {
    const rest = this.rest, format = rest.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.rest.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(rest.options, { format });
    if (typeof callback !== "function") {
      return promisify(this, "listChannels", arguments);
    }
    mixin(headers, rest.options.headers);
    if (rest.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    new paginatedresource_default(rest.client, "/push/channels", headers, envelope, function(body, headers2, unpacked) {
      return __async(this, null, function* () {
        const parsedBody = !unpacked && format ? decodeBody(body, format) : body;
        for (let i = 0; i < parsedBody.length; i++) {
          parsedBody[i] = String(parsedBody[i]);
        }
        return parsedBody;
      });
    }).get(params, callback);
  }
};
var push_default = Push;

// src/common/lib/util/eventemitter.ts
function callListener(eventThis, listener, args) {
  try {
    listener.apply(eventThis, args);
  } catch (e) {
    logger_default.logAction(
      logger_default.LOG_ERROR,
      "EventEmitter.emit()",
      "Unexpected listener exception: " + e + "; stack = " + (e && e.stack)
    );
  }
}
function removeListener(targetListeners, listener, eventFilter) {
  let listeners;
  let index;
  let eventName;
  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
    listeners = targetListeners[targetListenersIndex];
    if (eventFilter) {
      listeners = listeners[eventFilter];
    }
    if (isArray(listeners)) {
      while ((index = arrIndexOf(listeners, listener)) !== -1) {
        listeners.splice(index, 1);
      }
      if (eventFilter && listeners.length === 0) {
        delete targetListeners[targetListenersIndex][eventFilter];
      }
    } else if (isObject(listeners)) {
      for (eventName in listeners) {
        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && isArray(listeners[eventName])) {
          removeListener([listeners], listener, eventName);
        }
      }
    }
  }
}
var EventEmitter = class _EventEmitter {
  constructor() {
    this.any = [];
    this.events = /* @__PURE__ */ Object.create(null);
    this.anyOnce = [];
    this.eventsOnce = /* @__PURE__ */ Object.create(null);
  }
  on(...args) {
    if (args.length === 1) {
      const listener = args[0];
      if (typeof listener === "function") {
        this.any.push(listener);
      } else {
        throw new Error("EventListener.on(): Invalid arguments: " + Platform.Config.inspect(args));
      }
    }
    if (args.length === 2) {
      const [event, listener] = args;
      if (typeof listener !== "function") {
        throw new Error("EventListener.on(): Invalid arguments: " + Platform.Config.inspect(args));
      }
      if (isEmptyArg(event)) {
        this.any.push(listener);
      } else if (isArray(event)) {
        event.forEach((eventName) => {
          this.on(eventName, listener);
        });
      } else {
        if (typeof event !== "string") {
          throw new Error("EventListener.on(): Invalid arguments: " + Platform.Config.inspect(args));
        }
        const listeners = this.events[event] || (this.events[event] = []);
        listeners.push(listener);
      }
    }
  }
  off(...args) {
    if (args.length == 0 || isEmptyArg(args[0]) && isEmptyArg(args[1])) {
      this.any = [];
      this.events = /* @__PURE__ */ Object.create(null);
      this.anyOnce = [];
      this.eventsOnce = /* @__PURE__ */ Object.create(null);
      return;
    }
    const [firstArg, secondArg] = args;
    let listener = null;
    let event = null;
    if (args.length === 1 || !secondArg) {
      if (typeof firstArg === "function") {
        listener = firstArg;
      } else {
        event = firstArg;
      }
    } else {
      if (typeof secondArg !== "function") {
        throw new Error("EventEmitter.off(): invalid arguments:" + Platform.Config.inspect(args));
      }
      [event, listener] = [firstArg, secondArg];
    }
    if (listener && isEmptyArg(event)) {
      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);
      return;
    }
    if (isArray(event)) {
      event.forEach((eventName) => {
        this.off(eventName, listener);
      });
      return;
    }
    if (typeof event !== "string") {
      throw new Error("EventEmitter.off(): invalid arguments:" + Platform.Config.inspect(args));
    }
    if (listener) {
      removeListener([this.events, this.eventsOnce], listener, event);
    } else {
      delete this.events[event];
      delete this.eventsOnce[event];
    }
  }
  /**
   * Get the array of listeners for a given event; excludes once events
   * @param event (optional) the name of the event, or none for 'any'
   * @return array of events, or null if none
   */
  listeners(event) {
    if (event) {
      const listeners = this.events[event] || [];
      if (this.eventsOnce[event])
        Array.prototype.push.apply(listeners, this.eventsOnce[event]);
      return listeners.length ? listeners : null;
    }
    return this.any.length ? this.any : null;
  }
  /**
   * Emit an event
   * @param event the event name
   * @param args the arguments to pass to the listener
   */
  emit(event, ...args) {
    const eventThis = { event };
    const listeners = [];
    if (this.anyOnce.length) {
      Array.prototype.push.apply(listeners, this.anyOnce);
      this.anyOnce = [];
    }
    if (this.any.length) {
      Array.prototype.push.apply(listeners, this.any);
    }
    const eventsOnceListeners = this.eventsOnce[event];
    if (eventsOnceListeners) {
      Array.prototype.push.apply(listeners, eventsOnceListeners);
      delete this.eventsOnce[event];
    }
    const eventsListeners = this.events[event];
    if (eventsListeners) {
      Array.prototype.push.apply(listeners, eventsListeners);
    }
    arrForEach(listeners, function(listener) {
      callListener(eventThis, listener, args);
    });
  }
  once(...args) {
    const argCount = args.length;
    if (argCount === 0 || argCount === 1 && typeof args[0] !== "function") {
      const event = args[0];
      return new Promise((resolve) => {
        this.once(event, resolve);
      });
    }
    const [firstArg, secondArg] = args;
    if (args.length === 1 && typeof firstArg === "function") {
      this.anyOnce.push(firstArg);
    } else if (isEmptyArg(firstArg)) {
      if (typeof secondArg !== "function") {
        throw new Error("EventEmitter.once(): Invalid arguments:" + Platform.Config.inspect(args));
      }
      this.anyOnce.push(secondArg);
    } else if (isArray(firstArg)) {
      const self2 = this;
      const listenerWrapper = function() {
        const innerArgs = Array.prototype.slice.call(arguments);
        arrForEach(firstArg, function(eventName) {
          self2.off(eventName, listenerWrapper);
        });
        if (typeof secondArg !== "function") {
          throw new Error("EventEmitter.once(): Invalid arguments:" + Platform.Config.inspect(args));
        }
        secondArg.apply(this, innerArgs);
      };
      arrForEach(firstArg, function(eventName) {
        self2.on(eventName, listenerWrapper);
      });
    } else {
      if (typeof firstArg !== "string") {
        throw new Error("EventEmitter.once(): Invalid arguments:" + Platform.Config.inspect(args));
      }
      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);
      if (secondArg) {
        if (typeof secondArg !== "function") {
          throw new Error("EventEmitter.once(): Invalid arguments:" + Platform.Config.inspect(args));
        }
        listeners.push(secondArg);
      }
    }
  }
  /**
   * Private API
   *
   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
   * @param targetState the name of the state event to listen to
   * @param currentState the name of the current state of this object
   * @param listener the listener to be called
   * @param listenerArgs
   */
  whenState(targetState, currentState, listener, ...listenerArgs) {
    const eventThis = { event: targetState };
    if (typeof targetState !== "string" || typeof currentState !== "string") {
      throw "whenState requires a valid event String argument";
    }
    if (typeof listener !== "function") {
      return new Promise((resolve) => {
        _EventEmitter.prototype.whenState.apply(
          this,
          [targetState, currentState, resolve].concat(listenerArgs)
        );
      });
    }
    if (targetState === currentState) {
      callListener(eventThis, listener, listenerArgs);
    } else {
      this.once(targetState, listener);
    }
  }
};
var eventemitter_default = EventEmitter;

// src/common/lib/types/message.ts
function normaliseContext(context) {
  if (!context || !context.channelOptions) {
    return {
      channelOptions: context,
      plugins: {},
      baseEncodedPreviousPayload: void 0
    };
  }
  return context;
}
function normalizeCipherOptions(options) {
  if (options && options.cipher) {
    if (!Platform.Crypto)
      throw new Error("Encryption not enabled; use ably.encryption.js instead");
    const cipher = Platform.Crypto.getCipher(options.cipher);
    return {
      cipher: cipher.cipherParams,
      channelCipher: cipher.cipher
    };
  }
  return options != null ? options : {};
}
function getMessageSize(msg) {
  let size = 0;
  if (msg.name) {
    size += msg.name.length;
  }
  if (msg.clientId) {
    size += msg.clientId.length;
  }
  if (msg.extras) {
    size += JSON.stringify(msg.extras).length;
  }
  if (msg.data) {
    size += dataSizeBytes(msg.data);
  }
  return size;
}
var _Message = class _Message {
  /**
   * Overload toJSON() to intercept JSON.stringify()
   * @return {*}
   */
  toJSON() {
    let encoding = this.encoding;
    let data = this.data;
    if (data && Platform.BufferUtils.isBuffer(data)) {
      if (arguments.length > 0) {
        encoding = encoding ? encoding + "/base64" : "base64";
        data = Platform.BufferUtils.base64Encode(data);
      } else {
        data = Platform.BufferUtils.toBuffer(data);
      }
    }
    return {
      name: this.name,
      id: this.id,
      clientId: this.clientId,
      connectionId: this.connectionId,
      connectionKey: this.connectionKey,
      extras: this.extras,
      encoding,
      data
    };
  }
  toString() {
    let result = "[Message";
    if (this.name)
      result += "; name=" + this.name;
    if (this.id)
      result += "; id=" + this.id;
    if (this.timestamp)
      result += "; timestamp=" + this.timestamp;
    if (this.clientId)
      result += "; clientId=" + this.clientId;
    if (this.connectionId)
      result += "; connectionId=" + this.connectionId;
    if (this.encoding)
      result += "; encoding=" + this.encoding;
    if (this.extras)
      result += "; extras =" + JSON.stringify(this.extras);
    if (this.data) {
      if (typeof this.data == "string")
        result += "; data=" + this.data;
      else if (Platform.BufferUtils.isBuffer(this.data))
        result += "; data (buffer)=" + Platform.BufferUtils.base64Encode(this.data);
      else
        result += "; data (json)=" + JSON.stringify(this.data);
    }
    if (this.extras)
      result += "; extras=" + JSON.stringify(this.extras);
    result += "]";
    return result;
  }
  static encrypt(msg, options, callback) {
    let data = msg.data, encoding = msg.encoding, cipher = options.channelCipher;
    encoding = encoding ? encoding + "/" : "";
    if (!Platform.BufferUtils.isBuffer(data)) {
      data = Platform.BufferUtils.utf8Encode(String(data));
      encoding = encoding + "utf-8/";
    }
    cipher.encrypt(data, function(err, data2) {
      if (err) {
        callback(err);
        return;
      }
      msg.data = data2;
      msg.encoding = encoding + "cipher+" + cipher.algorithm;
      callback(null, msg);
    });
  }
  static encode(msg, options, callback) {
    const data = msg.data;
    const nativeDataType = typeof data == "string" || Platform.BufferUtils.isBuffer(data) || data === null || data === void 0;
    if (!nativeDataType) {
      if (isObject(data) || isArray(data)) {
        msg.data = JSON.stringify(data);
        msg.encoding = msg.encoding ? msg.encoding + "/json" : "json";
      } else {
        throw new ErrorInfo("Data type is unsupported", 40013, 400);
      }
    }
    if (options != null && options.cipher) {
      _Message.encrypt(msg, options, callback);
    } else {
      callback(null, msg);
    }
  }
  static encodeArray(messages, options, callback) {
    let processed = 0;
    for (let i = 0; i < messages.length; i++) {
      _Message.encode(messages[i], options, function(err) {
        if (err) {
          callback(err);
          return;
        }
        processed++;
        if (processed == messages.length) {
          callback(null, messages);
        }
      });
    }
  }
  static decode(message, inputContext) {
    return __async(this, null, function* () {
      const context = normaliseContext(inputContext);
      let lastPayload = message.data;
      const encoding = message.encoding;
      if (encoding) {
        const xforms = encoding.split("/");
        let lastProcessedEncodingIndex, encodingsToProcess = xforms.length, data = message.data;
        let xform = "";
        try {
          while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {
            const match = xforms[--encodingsToProcess].match(/([-\w]+)(\+([\w-]+))?/);
            if (!match)
              break;
            xform = match[1];
            switch (xform) {
              case "base64":
                data = Platform.BufferUtils.base64Decode(String(data));
                if (lastProcessedEncodingIndex == xforms.length) {
                  lastPayload = data;
                }
                continue;
              case "utf-8":
                data = Platform.BufferUtils.utf8Decode(data);
                continue;
              case "json":
                data = JSON.parse(data);
                continue;
              case "cipher":
                if (context.channelOptions != null && context.channelOptions.cipher && context.channelOptions.channelCipher) {
                  const xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;
                  if (xformAlgorithm != cipher.algorithm) {
                    throw new Error("Unable to decrypt message with given cipher; incompatible cipher params");
                  }
                  data = yield cipher.decrypt(data);
                  continue;
                } else {
                  throw new Error("Unable to decrypt message; not an encrypted channel");
                }
              case "vcdiff":
                if (!context.plugins || !context.plugins.vcdiff) {
                  throw new ErrorInfo(
                    "Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)",
                    40019,
                    400
                  );
                }
                if (typeof Uint8Array === "undefined") {
                  throw new ErrorInfo(
                    "Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)",
                    40020,
                    400
                  );
                }
                try {
                  let deltaBase = context.baseEncodedPreviousPayload;
                  if (typeof deltaBase === "string") {
                    deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);
                  }
                  deltaBase = Platform.BufferUtils.toBuffer(deltaBase);
                  data = Platform.BufferUtils.toBuffer(data);
                  data = Platform.BufferUtils.arrayBufferViewToBuffer(context.plugins.vcdiff.decode(data, deltaBase));
                  lastPayload = data;
                } catch (e) {
                  throw new ErrorInfo("Vcdiff delta decode failed with " + e, 40018, 400);
                }
                continue;
              default:
                throw new Error("Unknown encoding");
            }
          }
        } catch (e) {
          const err = e;
          throw new ErrorInfo(
            "Error processing the " + xform + " encoding, decoder returned \u2018" + err.message + "\u2019",
            err.code || 40013,
            400
          );
        } finally {
          message.encoding = lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join("/");
          message.data = data;
        }
      }
      context.baseEncodedPreviousPayload = lastPayload;
    });
  }
  static fromResponseBody(body, options, format) {
    return __async(this, null, function* () {
      if (format) {
        body = decodeBody(body, format);
      }
      for (let i = 0; i < body.length; i++) {
        const msg = body[i] = _Message.fromValues(body[i]);
        try {
          yield _Message.decode(msg, options);
        } catch (e) {
          logger_default.logAction(logger_default.LOG_ERROR, "Message.fromResponseBody()", e.toString());
        }
      }
      return body;
    });
  }
  static fromValues(values) {
    return Object.assign(new _Message(), values);
  }
  static fromValuesArray(values) {
    const count = values.length, result = new Array(count);
    for (let i = 0; i < count; i++)
      result[i] = _Message.fromValues(values[i]);
    return result;
  }
  static fromEncoded(encoded, inputOptions) {
    return __async(this, null, function* () {
      const msg = _Message.fromValues(encoded);
      const options = normalizeCipherOptions(inputOptions != null ? inputOptions : null);
      try {
        yield _Message.decode(msg, options);
      } catch (e) {
        logger_default.logAction(logger_default.LOG_ERROR, "Message.fromEncoded()", e.toString());
      }
      return msg;
    });
  }
  static fromEncodedArray(encodedArray, options) {
    return __async(this, null, function* () {
      return Promise.all(
        encodedArray.map(function(encoded) {
          return _Message.fromEncoded(encoded, options);
        })
      );
    });
  }
  /* This should be called on encode()d (and encrypt()d) Messages (as it
   * assumes the data is a string or buffer) */
  static getMessagesSize(messages) {
    let msg, total = 0;
    for (let i = 0; i < messages.length; i++) {
      msg = messages[i];
      total += msg.size || (msg.size = getMessageSize(msg));
    }
    return total;
  }
};
_Message.serialize = encodeBody;
var Message = _Message;
var message_default = Message;

// src/common/lib/types/presencemessage.ts
function toActionValue(actionString) {
  return PresenceMessage.Actions.indexOf(actionString);
}
var _PresenceMessage = class _PresenceMessage {
  /* Returns whether this presenceMessage is synthesized, i.e. was not actually
   * sent by the connection (usually means a leave event sent 15s after a
   * disconnection). This is useful because synthesized messages cannot be
   * compared for newness by id lexicographically - RTP2b1
   */
  isSynthesized() {
    if (!this.id || !this.connectionId) {
      return true;
    }
    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;
  }
  /* RTP2b2 */
  parseId() {
    if (!this.id)
      throw new Error("parseId(): Presence message does not contain an id");
    const parts = this.id.split(":");
    return {
      connectionId: parts[0],
      msgSerial: parseInt(parts[1], 10),
      index: parseInt(parts[2], 10)
    };
  }
  /**
   * Overload toJSON() to intercept JSON.stringify()
   * @return {*}
   */
  toJSON() {
    let data = this.data;
    let encoding = this.encoding;
    if (data && Platform.BufferUtils.isBuffer(data)) {
      if (arguments.length > 0) {
        encoding = encoding ? encoding + "/base64" : "base64";
        data = Platform.BufferUtils.base64Encode(data);
      } else {
        data = Platform.BufferUtils.toBuffer(data);
      }
    }
    return {
      id: this.id,
      clientId: this.clientId,
      /* Convert presence action back to an int for sending to Ably */
      action: toActionValue(this.action),
      data,
      encoding
    };
  }
  toString() {
    let result = "[PresenceMessage";
    result += "; action=" + this.action;
    if (this.id)
      result += "; id=" + this.id;
    if (this.timestamp)
      result += "; timestamp=" + this.timestamp;
    if (this.clientId)
      result += "; clientId=" + this.clientId;
    if (this.connectionId)
      result += "; connectionId=" + this.connectionId;
    if (this.encoding)
      result += "; encoding=" + this.encoding;
    if (this.data) {
      if (typeof this.data == "string")
        result += "; data=" + this.data;
      else if (Platform.BufferUtils.isBuffer(this.data))
        result += "; data (buffer)=" + Platform.BufferUtils.base64Encode(this.data);
      else
        result += "; data (json)=" + JSON.stringify(this.data);
    }
    result += "]";
    return result;
  }
  static fromResponseBody(body, options, format) {
    return __async(this, null, function* () {
      const messages = [];
      if (format) {
        body = decodeBody(body, format);
      }
      for (let i = 0; i < body.length; i++) {
        const msg = messages[i] = _PresenceMessage.fromValues(body[i], true);
        try {
          yield _PresenceMessage.decode(msg, options);
        } catch (e) {
          logger_default.logAction(logger_default.LOG_ERROR, "PresenceMessage.fromResponseBody()", e.toString());
        }
      }
      return messages;
    });
  }
  static fromValues(values, stringifyAction) {
    if (stringifyAction) {
      values.action = _PresenceMessage.Actions[values.action];
    }
    return Object.assign(new _PresenceMessage(), values);
  }
  static fromValuesArray(values) {
    const count = values.length, result = new Array(count);
    for (let i = 0; i < count; i++)
      result[i] = _PresenceMessage.fromValues(values[i]);
    return result;
  }
  static fromEncoded(encoded, options) {
    return __async(this, null, function* () {
      const msg = _PresenceMessage.fromValues(encoded, true);
      try {
        yield _PresenceMessage.decode(msg, options != null ? options : {});
      } catch (e) {
        logger_default.logAction(logger_default.LOG_ERROR, "PresenceMessage.fromEncoded()", e.toString());
      }
      return msg;
    });
  }
  static fromEncodedArray(encodedArray, options) {
    return __async(this, null, function* () {
      return Promise.all(
        encodedArray.map(function(encoded) {
          return _PresenceMessage.fromEncoded(encoded, options);
        })
      );
    });
  }
};
_PresenceMessage.Actions = ["absent", "present", "enter", "leave", "update"];
_PresenceMessage.encode = message_default.encode;
_PresenceMessage.decode = message_default.decode;
_PresenceMessage.getMessagesSize = message_default.getMessagesSize;
var PresenceMessage = _PresenceMessage;
var presencemessage_default = PresenceMessage;

// src/common/lib/client/presence.ts
var Presence = class extends eventemitter_default {
  constructor(channel) {
    super();
    this.channel = channel;
    this.basePath = channel.basePath + "/presence";
  }
  get(params, callback) {
    logger_default.logAction(logger_default.LOG_MICRO, "Presence.get()", "channel = " + this.channel.name);
    if (callback === void 0) {
      if (typeof params == "function") {
        callback = params;
        params = null;
      } else {
        return promisify(this, "get", arguments);
      }
    }
    const client = this.channel.client, format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });
    mixin(headers, client.options.headers);
    const options = this.channel.channelOptions;
    new paginatedresource_default(client, this.basePath, headers, envelope, function(body, headers2, unpacked) {
      return __async(this, null, function* () {
        return yield presencemessage_default.fromResponseBody(body, options, unpacked ? void 0 : format);
      });
    }).get(params, callback);
  }
  history(params, callback) {
    logger_default.logAction(logger_default.LOG_MICRO, "Presence.history()", "channel = " + this.channel.name);
    return this._history(params, callback);
  }
  _history(params, callback) {
    if (callback === void 0) {
      if (typeof params == "function") {
        callback = params;
        params = null;
      } else {
        return promisify(this, "_history", [params]);
      }
    }
    const rest = this.channel.client, format = rest.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(rest.options, { format });
    mixin(headers, rest.options.headers);
    const options = this.channel.channelOptions;
    new paginatedresource_default(rest, this.basePath + "/history", headers, envelope, function(body, headers2, unpacked) {
      return __async(this, null, function* () {
        return yield presencemessage_default.fromResponseBody(body, options, unpacked ? void 0 : format);
      });
    }).get(params, callback);
  }
};
var presence_default = Presence;

// src/common/lib/client/channel.ts
function noop2() {
}
var MSG_ID_ENTROPY_BYTES = 9;
function allEmptyIds(messages) {
  return arrEvery(messages, function(message) {
    return !message.id;
  });
}
function normaliseChannelOptions(options) {
  const channelOptions = options || {};
  if (channelOptions.cipher) {
    if (!Platform.Crypto)
      throw new Error("Encryption not enabled; use ably.encryption.js instead");
    const cipher = Platform.Crypto.getCipher(channelOptions.cipher);
    channelOptions.cipher = cipher.cipherParams;
    channelOptions.channelCipher = cipher.cipher;
  } else if ("cipher" in channelOptions) {
    channelOptions.cipher = void 0;
    channelOptions.channelCipher = null;
  }
  return channelOptions;
}
var Channel = class extends eventemitter_default {
  constructor(client, name, channelOptions) {
    super();
    logger_default.logAction(logger_default.LOG_MINOR, "Channel()", "started; name = " + name);
    this.client = client;
    this.name = name;
    this.basePath = "/channels/" + encodeURIComponent(name);
    this.presence = new presence_default(this);
    this.channelOptions = normaliseChannelOptions(channelOptions);
  }
  setOptions(options) {
    this.channelOptions = normaliseChannelOptions(options);
  }
  history(params, callback) {
    logger_default.logAction(logger_default.LOG_MICRO, "Channel.history()", "channel = " + this.name);
    if (callback === void 0) {
      if (typeof params == "function") {
        callback = params;
        params = null;
      } else {
        return promisify(this, "history", arguments);
      }
    }
    this._history(params, callback);
  }
  _history(params, callback) {
    const client = this.client, format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });
    mixin(headers, client.options.headers);
    const options = this.channelOptions;
    new paginatedresource_default(client, this.basePath + "/messages", headers, envelope, function(body, headers2, unpacked) {
      return __async(this, null, function* () {
        return yield message_default.fromResponseBody(body, options, unpacked ? void 0 : format);
      });
    }).get(params, callback);
  }
  publish() {
    const argCount = arguments.length, first = arguments[0], second = arguments[1];
    let callback = arguments[argCount - 1];
    let messages;
    let params;
    if (typeof callback !== "function") {
      return promisify(this, "publish", arguments);
    }
    if (typeof first === "string" || first === null) {
      messages = [message_default.fromValues({ name: first, data: second })];
      params = arguments[2];
    } else if (isObject(first)) {
      messages = [message_default.fromValues(first)];
      params = arguments[1];
    } else if (isArray(first)) {
      messages = message_default.fromValuesArray(first);
      params = arguments[1];
    } else {
      throw new ErrorInfo(
        "The single-argument form of publish() expects a message object or an array of message objects",
        40013,
        400
      );
    }
    if (typeof params !== "object" || !params) {
      params = {};
    }
    const client = this.client, options = client.options, format = options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, idempotentRestPublishing = client.options.idempotentRestPublishing, headers = defaults_default.defaultPostHeaders(client.options, { format });
    mixin(headers, options.headers);
    if (idempotentRestPublishing && allEmptyIds(messages)) {
      const msgIdBase = randomString(MSG_ID_ENTROPY_BYTES);
      arrForEach(messages, function(message, index) {
        message.id = msgIdBase + ":" + index.toString();
      });
    }
    message_default.encodeArray(messages, this.channelOptions, (err) => {
      if (err) {
        callback(err);
        return;
      }
      const size = message_default.getMessagesSize(messages), maxMessageSize = options.maxMessageSize;
      if (size > maxMessageSize) {
        callback(
          new ErrorInfo(
            "Maximum size of messages that can be published at once exceeded ( was " + size + " bytes; limit is " + maxMessageSize + " bytes)",
            40009,
            400
          )
        );
        return;
      }
      this._publish(message_default.serialize(messages, format), headers, params, callback);
    });
  }
  _publish(requestBody, headers, params, callback) {
    resource_default.post(this.client, this.basePath + "/messages", requestBody, headers, params, null, callback);
  }
  status(callback) {
    if (typeof callback !== "function") {
      return promisify(this, "status", []);
    }
    const format = this.client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */;
    const headers = defaults_default.defaultPostHeaders(this.client.options, { format });
    resource_default.get(this.client, this.basePath, headers, {}, format, callback || noop2);
  }
};
var channel_default = Channel;

// src/common/lib/types/stats.ts
var MessageCount = class {
  constructor(values) {
    this.count = values && values.count || 0;
    this.data = values && values.data || 0;
    this.uncompressedData = values && values.uncompressedData || 0;
    this.failed = values && values.failed || 0;
    this.refused = values && values.refused || 0;
  }
};
var MessageCategory = class extends MessageCount {
  constructor(values) {
    super(values);
    if (values && values.category) {
      this.category = {};
      forInOwnNonNullProperties(values.category, (prop) => {
        this.category[prop] = new MessageCount(
          values.category[prop]
        );
      });
    }
  }
};
var ResourceCount = class {
  constructor(values) {
    this.peak = values && values.peak || 0;
    this.min = values && values.min || 0;
    this.mean = values && values.mean || 0;
    this.opened = values && values.opened || 0;
    this.refused = values && values.refused || 0;
  }
};
var RequestCount = class {
  constructor(values) {
    this.succeeded = values && values.succeeded || 0;
    this.failed = values && values.failed || 0;
    this.refused = values && values.refused || 0;
  }
};
var ConnectionTypes = class {
  constructor(values) {
    this.plain = new ResourceCount(values && values.plain);
    this.tls = new ResourceCount(values && values.tls);
    this.all = new ResourceCount(values && values.all);
  }
};
var MessageTypes = class {
  constructor(values) {
    this.messages = new MessageCategory(values && values.messages);
    this.presence = new MessageCategory(values && values.presence);
    this.all = new MessageCategory(values && values.all);
  }
};
var MessageTraffic = class {
  constructor(values) {
    this.realtime = new MessageTypes(values && values.realtime);
    this.rest = new MessageTypes(values && values.rest);
    this.webhook = new MessageTypes(values && values.webhook);
    this.sharedQueue = new MessageTypes(values && values.sharedQueue);
    this.externalQueue = new MessageTypes(values && values.externalQueue);
    this.httpEvent = new MessageTypes(values && values.httpEvent);
    this.push = new MessageTypes(values && values.push);
    this.all = new MessageTypes(values && values.all);
  }
};
var MessageDirections = class {
  constructor(values) {
    this.all = new MessageTypes(values && values.all);
    this.inbound = new MessageTraffic(values && values.inbound);
    this.outbound = new MessageTraffic(values && values.outbound);
  }
};
var XchgMessages = class {
  constructor(values) {
    this.all = new MessageTypes(values && values.all);
    this.producerPaid = new MessageDirections(values && values.producerPaid);
    this.consumerPaid = new MessageDirections(values && values.consumerPaid);
  }
};
var PushStats = class {
  constructor(values) {
    this.messages = values && values.messages || 0;
    const notifications = values && values.notifications;
    this.notifications = {
      invalid: notifications && notifications.invalid || 0,
      attempted: notifications && notifications.attempted || 0,
      successful: notifications && notifications.successful || 0,
      failed: notifications && notifications.failed || 0
    };
    this.directPublishes = values && values.directPublishes || 0;
  }
};
var ProcessedCount = class {
  constructor(values) {
    this.succeeded = values && values.succeeded || 0;
    this.skipped = values && values.skipped || 0;
    this.failed = values && values.failed || 0;
  }
};
var ProcessedMessages = class {
  constructor(values) {
    this.delta = void 0;
    if (values && values.delta) {
      this.delta = {};
      forInOwnNonNullProperties(values.delta, (prop) => {
        this.delta[prop] = new ProcessedCount(
          values.delta[prop]
        );
      });
    }
  }
};
var Stats = class _Stats extends MessageDirections {
  constructor(values) {
    super(values);
    this.persisted = new MessageTypes(values && values.persisted);
    this.connections = new ConnectionTypes(values && values.connections);
    this.channels = new ResourceCount(values && values.channels);
    this.apiRequests = new RequestCount(values && values.apiRequests);
    this.tokenRequests = new RequestCount(values && values.tokenRequests);
    this.xchgProducer = new XchgMessages(values && values.xchgProducer);
    this.xchgConsumer = new XchgMessages(values && values.xchgConsumer);
    this.push = new PushStats(values && values.pushStats);
    this.processed = new ProcessedMessages(values && values.processed);
    this.inProgress = values && values.inProgress || void 0;
    this.unit = values && values.unit || void 0;
    this.intervalId = values && values.intervalId || void 0;
  }
  static fromValues(values) {
    return new _Stats(values);
  }
};
var stats_default = Stats;

// src/common/lib/client/rest.ts
var noop3 = function() {
};
var Rest = class {
  constructor(client) {
    this.client = client;
    this.http = client.http;
    this.options = client.options;
    this.channels = new Channels(this.client);
    this.push = new push_default(this);
  }
  stats(params, callback) {
    if (callback === void 0) {
      if (typeof params == "function") {
        callback = params;
        params = null;
      } else {
        return promisify(this, "stats", [params]);
      }
    }
    const headers = defaults_default.defaultGetHeaders(this.options), format = this.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.http.supportsLinkHeaders ? void 0 : format;
    mixin(headers, this.options.headers);
    new paginatedresource_default(this.client, "/stats", headers, envelope, function(body, headers2, unpacked) {
      const statsValues = unpacked ? body : JSON.parse(body);
      for (let i = 0; i < statsValues.length; i++)
        statsValues[i] = stats_default.fromValues(statsValues[i]);
      return statsValues;
    }).get(params, callback);
  }
  time(params, callback) {
    if (callback === void 0) {
      if (typeof params == "function") {
        callback = params;
        params = null;
      } else {
        return promisify(this, "time", [params]);
      }
    }
    const _callback = callback || noop3;
    const headers = defaults_default.defaultGetHeaders(this.options);
    if (this.options.headers)
      mixin(headers, this.options.headers);
    const timeUri = (host) => {
      return this.client.authority(host) + "/time";
    };
    this.http.do(
      HttpMethods_default.Get,
      this.client,
      timeUri,
      headers,
      null,
      params,
      (err, res, headers2, unpacked) => {
        if (err) {
          _callback(err);
          return;
        }
        if (!unpacked)
          res = JSON.parse(res);
        const time = res[0];
        if (!time) {
          _callback(new ErrorInfo("Internal error (unexpected result type from GET /time)", 5e4, 500));
          return;
        }
        this.client.serverTimeOffset = time - now();
        _callback(null, time);
      }
    );
  }
  request(method, path, version2, params, body, customHeaders, callback) {
    const useBinary = this.options.useBinaryProtocol, encoder = useBinary ? Platform.Config.msgpack.encode : JSON.stringify, decoder = useBinary ? Platform.Config.msgpack.decode : JSON.parse, format = useBinary ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.http.supportsLinkHeaders ? void 0 : format;
    params = params || {};
    const _method = method.toLowerCase();
    const headers = _method == "get" ? defaults_default.defaultGetHeaders(this.options, { format, protocolVersion: version2 }) : defaults_default.defaultPostHeaders(this.options, { format, protocolVersion: version2 });
    if (callback === void 0) {
      return promisify(this, "request", [method, path, version2, params, body, customHeaders]);
    }
    if (typeof body !== "string") {
      body = encoder(body);
    }
    mixin(headers, this.options.headers);
    if (customHeaders) {
      mixin(headers, customHeaders);
    }
    const paginatedResource = new paginatedresource_default(
      this.client,
      path,
      headers,
      envelope,
      function(resbody, headers2, unpacked) {
        return __async(this, null, function* () {
          return ensureArray(unpacked ? resbody : decoder(resbody));
        });
      },
      /* useHttpPaginatedResponse: */
      true
    );
    if (!arrIn(Platform.Http.methods, _method)) {
      throw new ErrorInfo("Unsupported method " + _method, 40500, 405);
    }
    if (arrIn(Platform.Http.methodsWithBody, _method)) {
      paginatedResource[_method](params, body, callback);
    } else {
      paginatedResource[_method](
        params,
        callback
      );
    }
  }
  setLog(logOptions) {
    logger_default.setLog(logOptions.level, logOptions.handler);
  }
};
var Channels = class {
  constructor(client) {
    this.client = client;
    this.all = /* @__PURE__ */ Object.create(null);
  }
  get(name, channelOptions) {
    name = String(name);
    let channel = this.all[name];
    if (!channel) {
      this.all[name] = channel = new channel_default(this.client, name, channelOptions);
    } else if (channelOptions) {
      channel.setOptions(channelOptions);
    }
    return channel;
  }
  /* Included to support certain niche use-cases; most users should ignore this.
   * Please do not use this unless you know what you're doing */
  release(name) {
    delete this.all[String(name)];
  }
};
var rest_default = Rest;

// src/platform/web/lib/util/hmac-sha256.ts
var uint8Array = Uint8Array;
var uint32Array = Uint32Array;
var pow = Math.pow;
var DEFAULT_STATE = new uint32Array(8);
var ROUND_CONSTANTS = [];
var M = new uint32Array(64);
function getFractionalBits(n2) {
  return (n2 - (n2 | 0)) * pow(2, 32) | 0;
}
var n = 2;
var nPrime = 0;
while (nPrime < 64) {
  isPrime = true;
  for (factor = 2; factor <= n / 2; factor++) {
    if (n % factor === 0) {
      isPrime = false;
    }
  }
  if (isPrime) {
    if (nPrime < 8) {
      DEFAULT_STATE[nPrime] = getFractionalBits(pow(n, 1 / 2));
    }
    ROUND_CONSTANTS[nPrime] = getFractionalBits(pow(n, 1 / 3));
    nPrime++;
  }
  n++;
}
var isPrime;
var factor;
var LittleEndian = !!new uint8Array(new uint32Array([1]).buffer)[0];
function convertEndian(word) {
  if (LittleEndian) {
    return (
      // byte 1 -> byte 4
      word >>> 24 | // byte 2 -> byte 3
      (word >>> 16 & 255) << 8 | // byte 3 -> byte 2
      (word & 65280) << 8 | // byte 4 -> byte 1
      word << 24
    );
  } else {
    return word;
  }
}
function rightRotate(word, bits) {
  return word >>> bits | word << 32 - bits;
}
function sha256(data) {
  var STATE = DEFAULT_STATE.slice();
  var legth = data.length;
  var bitLength = legth * 8;
  var newBitLength = 512 - (bitLength + 64) % 512 - 1 + bitLength + 65;
  var bytes = new uint8Array(newBitLength / 8);
  var words = new uint32Array(bytes.buffer);
  bytes.set(data, 0);
  bytes[legth] = 128;
  words[words.length - 1] = convertEndian(bitLength);
  var round;
  for (var block = 0; block < newBitLength / 32; block += 16) {
    var workingState = STATE.slice();
    for (round = 0; round < 64; round++) {
      var MRound;
      if (round < 16) {
        MRound = convertEndian(words[block + round]);
      } else {
        var gamma0x = M[round - 15];
        var gamma1x = M[round - 2];
        MRound = M[round - 7] + M[round - 16] + (rightRotate(gamma0x, 7) ^ rightRotate(gamma0x, 18) ^ gamma0x >>> 3) + (rightRotate(gamma1x, 17) ^ rightRotate(gamma1x, 19) ^ gamma1x >>> 10);
      }
      M[round] = MRound |= 0;
      var t1 = (rightRotate(workingState[4], 6) ^ rightRotate(workingState[4], 11) ^ rightRotate(workingState[4], 25)) + (workingState[4] & workingState[5] ^ ~workingState[4] & workingState[6]) + workingState[7] + MRound + ROUND_CONSTANTS[round];
      var t2 = (rightRotate(workingState[0], 2) ^ rightRotate(workingState[0], 13) ^ rightRotate(workingState[0], 22)) + (workingState[0] & workingState[1] ^ workingState[2] & (workingState[0] ^ workingState[1]));
      for (var i = 7; i > 0; i--) {
        workingState[i] = workingState[i - 1];
      }
      workingState[0] = t1 + t2 | 0;
      workingState[4] = workingState[4] + t1 | 0;
    }
    for (round = 0; round < 8; round++) {
      STATE[round] = STATE[round] + workingState[round] | 0;
    }
  }
  return new uint8Array(
    new uint32Array(
      STATE.map(function(val) {
        return convertEndian(val);
      })
    ).buffer
  );
}
function hmac2(key, data) {
  if (key.length > 64)
    key = sha256(key);
  if (key.length < 64) {
    const tmp = new Uint8Array(64);
    tmp.set(key, 0);
    key = tmp;
  }
  var innerKey = new Uint8Array(64);
  var outerKey = new Uint8Array(64);
  for (var i = 0; i < 64; i++) {
    innerKey[i] = 54 ^ key[i];
    outerKey[i] = 92 ^ key[i];
  }
  var msg = new Uint8Array(data.length + 64);
  msg.set(innerKey, 0);
  msg.set(data, 64);
  var result = new Uint8Array(64 + 32);
  result.set(outerKey, 0);
  result.set(sha256(msg), 64);
  return sha256(result);
}

// src/platform/web/lib/util/bufferutils.ts
var BufferUtils = class {
  constructor() {
    this.base64CharSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    this.hexCharSet = "0123456789abcdef";
  }
  // // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js
  uint8ViewToBase64(bytes) {
    let base64 = "";
    const encodings = this.base64CharSet;
    const byteLength = bytes.byteLength;
    const byteRemainder = byteLength % 3;
    const mainLength = byteLength - byteRemainder;
    let a, b, c, d;
    let chunk;
    for (let i = 0; i < mainLength; i = i + 3) {
      chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
      a = (chunk & 16515072) >> 18;
      b = (chunk & 258048) >> 12;
      c = (chunk & 4032) >> 6;
      d = chunk & 63;
      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
    }
    if (byteRemainder == 1) {
      chunk = bytes[mainLength];
      a = (chunk & 252) >> 2;
      b = (chunk & 3) << 4;
      base64 += encodings[a] + encodings[b] + "==";
    } else if (byteRemainder == 2) {
      chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];
      a = (chunk & 64512) >> 10;
      b = (chunk & 1008) >> 4;
      c = (chunk & 15) << 2;
      base64 += encodings[a] + encodings[b] + encodings[c] + "=";
    }
    return base64;
  }
  base64ToArrayBuffer(base64) {
    const binary_string = atob == null ? void 0 : atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      const ascii = binary_string.charCodeAt(i);
      bytes[i] = ascii;
    }
    return bytes.buffer;
  }
  isBuffer(buffer) {
    return buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);
  }
  /* In browsers, returns a Uint8Array */
  toBuffer(buffer) {
    if (!ArrayBuffer) {
      throw new Error("Can't convert to Buffer: browser does not support the necessary types");
    }
    if (buffer instanceof ArrayBuffer) {
      return new Uint8Array(buffer);
    }
    if (ArrayBuffer.isView(buffer)) {
      return new Uint8Array(buffer.buffer);
    }
    throw new Error("BufferUtils.toBuffer expected an ArrayBuffer or a view onto one");
  }
  toArrayBuffer(buffer) {
    if (buffer instanceof ArrayBuffer) {
      return buffer;
    }
    return this.toBuffer(buffer).buffer;
  }
  base64Encode(buffer) {
    return this.uint8ViewToBase64(this.toBuffer(buffer));
  }
  base64Decode(str) {
    if (ArrayBuffer && Platform.Config.atob) {
      return this.base64ToArrayBuffer(str);
    } else {
      throw new Error("Expected ArrayBuffer to exist and Platform.Config.atob to be configured");
    }
  }
  hexEncode(buffer) {
    const arrayBuffer = buffer instanceof ArrayBuffer ? buffer : buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    const uint8Array2 = new Uint8Array(arrayBuffer);
    return uint8Array2.reduce((accum, byte) => accum + byte.toString(16).padStart(2, "0"), "");
  }
  hexDecode(hexEncodedBytes) {
    if (hexEncodedBytes.length % 2 !== 0) {
      throw new Error("Can't create a byte array from a hex string of odd length");
    }
    const uint8Array2 = new Uint8Array(hexEncodedBytes.length / 2);
    for (let i = 0; i < uint8Array2.length; i++) {
      uint8Array2[i] = parseInt(hexEncodedBytes.slice(2 * i, 2 * (i + 1)), 16);
    }
    return uint8Array2.buffer.slice(uint8Array2.byteOffset, uint8Array2.byteOffset + uint8Array2.byteLength);
  }
  utf8Encode(string) {
    if (Platform.Config.TextEncoder) {
      return new Platform.Config.TextEncoder().encode(string).buffer;
    } else {
      throw new Error("Expected TextEncoder to be configured");
    }
  }
  /* For utf8 decoding we apply slightly stricter input validation than to
   * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from
   * can take (in particular allowing strings, which are just interpreted as
   * binary); here we ensure that the input is actually a buffer since trying
   * to utf8-decode a string to another string is almost certainly a mistake */
  utf8Decode(buffer) {
    if (!this.isBuffer(buffer)) {
      throw new Error("Expected input of utf8decode to be an arraybuffer or typed array");
    }
    if (TextDecoder) {
      return new TextDecoder().decode(buffer);
    } else {
      throw new Error("Expected TextDecoder to be configured");
    }
  }
  areBuffersEqual(buffer1, buffer2) {
    if (!buffer1 || !buffer2)
      return false;
    const arrayBuffer1 = this.toArrayBuffer(buffer1);
    const arrayBuffer2 = this.toArrayBuffer(buffer2);
    if (arrayBuffer1.byteLength != arrayBuffer2.byteLength)
      return false;
    const bytes1 = new Uint8Array(arrayBuffer1);
    const bytes2 = new Uint8Array(arrayBuffer2);
    for (var i = 0; i < bytes1.length; i++) {
      if (bytes1[i] != bytes2[i])
        return false;
    }
    return true;
  }
  byteLength(buffer) {
    if (buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)) {
      return buffer.byteLength;
    }
    return -1;
  }
  /* Returns ArrayBuffer on browser and Buffer on Node.js */
  arrayBufferViewToBuffer(arrayBufferView) {
    return arrayBufferView.buffer;
  }
  hmacSha256(message, key) {
    return hmac2(this.toBuffer(key), this.toBuffer(message));
  }
};
var bufferutils_default = new BufferUtils();

// src/platform/web/lib/util/crypto.ts
var CryptoFactory = function(config, bufferUtils) {
  var DEFAULT_ALGORITHM = "aes";
  var DEFAULT_KEYLENGTH = 256;
  var DEFAULT_MODE = "cbc";
  var DEFAULT_BLOCKLENGTH = 16;
  var DEFAULT_BLOCKLENGTH_WORDS = 4;
  var UINT32_SUP = 4294967296;
  var generateRandom;
  if (config.getRandomArrayBuffer) {
    generateRandom = config.getRandomArrayBuffer;
  } else if (typeof Uint32Array !== "undefined" && config.getRandomValues) {
    var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);
    generateRandom = function(bytes, callback) {
      var words = bytes / 4, nativeArray = words == DEFAULT_BLOCKLENGTH_WORDS ? blockRandomArray : new Uint32Array(words);
      config.getRandomValues(nativeArray, function(err) {
        if (typeof callback !== "undefined") {
          callback(err, bufferUtils.toArrayBuffer(nativeArray));
        }
      });
    };
  } else {
    generateRandom = function(bytes, callback) {
      logger_default.logAction(
        logger_default.LOG_MAJOR,
        "Ably.Crypto.generateRandom()",
        "Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()"
      );
      var words = bytes / 4, array = new Uint32Array(words);
      for (var i = 0; i < words; i++) {
        array[i] = Math.floor(Math.random() * UINT32_SUP);
      }
      callback(null, bufferUtils.toArrayBuffer(array));
    };
  }
  function validateCipherParams(params) {
    if (params.algorithm === "aes" && params.mode === "cbc") {
      if (params.keyLength === 128 || params.keyLength === 256) {
        return;
      }
      throw new Error(
        "Unsupported key length " + params.keyLength + " for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)"
      );
    }
  }
  function normaliseBase64(string) {
    return string.replace("_", "/").replace("-", "+");
  }
  function isCipherParams(params) {
    return params instanceof CipherParams;
  }
  class CipherParams {
    constructor(algorithm, keyLength, mode, key) {
      this.algorithm = algorithm;
      this.keyLength = keyLength;
      this.mode = mode;
      this.key = key;
    }
  }
  class Crypto2 {
    /**
     * Obtain a complete CipherParams instance from the provided params, filling
     * in any not provided with default values, calculating a keyLength from
     * the supplied key, and validating the result.
     * @param params an object containing at a minimum a `key` key with value the
     * key, as either a binary or a base64-encoded string.
     * May optionally also contain: algorithm (defaults to AES),
     * mode (defaults to 'cbc')
     */
    static getDefaultParams(params) {
      var key;
      if (!params.key) {
        throw new Error("Crypto.getDefaultParams: a key is required");
      }
      if (typeof params.key === "string") {
        key = bufferUtils.toArrayBuffer(bufferUtils.base64Decode(normaliseBase64(params.key)));
      } else if (params.key instanceof ArrayBuffer) {
        key = params.key;
      } else {
        key = bufferUtils.toArrayBuffer(params.key);
      }
      var algorithm = params.algorithm || DEFAULT_ALGORITHM;
      var keyLength = key.byteLength * 8;
      var mode = params.mode || DEFAULT_MODE;
      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);
      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {
        throw new Error(
          "Crypto.getDefaultParams: a keyLength of " + params.keyLength + " was specified, but the key actually has length " + cipherParams.keyLength
        );
      }
      validateCipherParams(cipherParams);
      return cipherParams;
    }
    /**
     * Generate a random encryption key from the supplied keylength (or the
     * default keyLength if none supplied) as an ArrayBuffer
     * @param keyLength (optional) the required keyLength in bits
     */
    static generateRandomKey(keyLength) {
      return __async(this, null, function* () {
        return new Promise((resolve, reject) => {
          generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, function(err, buf) {
            if (err) {
              const errorInfo = new ErrorInfo("Failed to generate random key: " + err.message, 400, 5e4, err);
              reject(errorInfo);
            } else {
              resolve(buf);
            }
          });
        });
      });
    }
    /**
     * Internal; get a ChannelCipher instance based on the given cipherParams
     * @param params either a CipherParams instance or some subset of its
     * fields that includes a key
     */
    static getCipher(params) {
      var _a2;
      var cipherParams = isCipherParams(params) ? params : this.getDefaultParams(params);
      return {
        cipherParams,
        cipher: new CBCCipher(cipherParams, (_a2 = params.iv) != null ? _a2 : null)
      };
    }
  }
  Crypto2.CipherParams = CipherParams;
  Crypto2;
  class CBCCipher {
    constructor(params, iv) {
      if (!crypto.subtle) {
        if (isSecureContext) {
          throw new Error(
            "Crypto operations are not possible since the browser\u2019s SubtleCrypto class is unavailable (reason unknown)."
          );
        } else {
          throw new Error(
            "Crypto operations are is not possible since the current environment is a non-secure context and hence the browser\u2019s SubtleCrypto class is not available."
          );
        }
      }
      this.algorithm = params.algorithm + "-" + String(params.keyLength) + "-" + params.mode;
      this.webCryptoAlgorithm = params.algorithm + "-" + params.mode;
      this.key = bufferUtils.toArrayBuffer(params.key);
      this.iv = iv ? bufferUtils.toArrayBuffer(iv) : null;
    }
    concat(buffer1, buffer2) {
      const output = new ArrayBuffer(buffer1.byteLength + buffer2.byteLength);
      const outputView = new DataView(output);
      const buffer1View = new DataView(bufferUtils.toArrayBuffer(buffer1));
      for (let i = 0; i < buffer1View.byteLength; i++) {
        outputView.setInt8(i, buffer1View.getInt8(i));
      }
      const buffer2View = new DataView(bufferUtils.toArrayBuffer(buffer2));
      for (let i = 0; i < buffer2View.byteLength; i++) {
        outputView.setInt8(buffer1View.byteLength + i, buffer2View.getInt8(i));
      }
      return output;
    }
    encrypt(plaintext, callback) {
      logger_default.logAction(logger_default.LOG_MICRO, "CBCCipher.encrypt()", "");
      const encryptAsync = () => __async(this, null, function* () {
        const iv = yield new Promise((resolve, reject) => {
          this.getIv((error, iv2) => {
            if (error) {
              reject(error);
            } else {
              resolve(iv2);
            }
          });
        });
        const cryptoKey = yield crypto.subtle.importKey("raw", this.key, this.webCryptoAlgorithm, false, ["encrypt"]);
        const ciphertext = yield crypto.subtle.encrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, plaintext);
        return this.concat(iv, ciphertext);
      });
      encryptAsync().then((ciphertext) => {
        callback(null, ciphertext);
      }).catch((error) => {
        callback(error, null);
      });
    }
    decrypt(ciphertext) {
      return __async(this, null, function* () {
        logger_default.logAction(logger_default.LOG_MICRO, "CBCCipher.decrypt()", "");
        const ciphertextArrayBuffer = bufferUtils.toArrayBuffer(ciphertext);
        const iv = ciphertextArrayBuffer.slice(0, DEFAULT_BLOCKLENGTH);
        const ciphertextBody = ciphertextArrayBuffer.slice(DEFAULT_BLOCKLENGTH);
        const cryptoKey = yield crypto.subtle.importKey("raw", this.key, this.webCryptoAlgorithm, false, ["decrypt"]);
        return crypto.subtle.decrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, ciphertextBody);
      });
    }
    getIv(callback) {
      if (this.iv) {
        var iv = this.iv;
        this.iv = null;
        callback(null, iv);
        return;
      }
      generateRandom(DEFAULT_BLOCKLENGTH, function(err, randomBlock) {
        if (err) {
          callback(err, null);
          return;
        }
        callback(null, bufferUtils.toArrayBuffer(randomBlock));
      });
    }
  }
  return Crypto2;
};
var crypto_default = CryptoFactory;

// src/common/constants/XHRStates.ts
var XHRStates = /* @__PURE__ */ ((XHRStates2) => {
  XHRStates2[XHRStates2["REQ_SEND"] = 0] = "REQ_SEND";
  XHRStates2[XHRStates2["REQ_RECV"] = 1] = "REQ_RECV";
  XHRStates2[XHRStates2["REQ_RECV_POLL"] = 2] = "REQ_RECV_POLL";
  XHRStates2[XHRStates2["REQ_RECV_STREAM"] = 3] = "REQ_RECV_STREAM";
  return XHRStates2;
})(XHRStates || {});
var XHRStates_default = XHRStates;

// src/platform/web/lib/transport/xhrrequest.ts
function isAblyError(responseBody, headers) {
  return arrIn(allToLowerCase(keysArray(headers)), "x-ably-errorcode");
}
function getAblyError(responseBody, headers) {
  if (isAblyError(responseBody, headers)) {
    return responseBody.error && ErrorInfo.fromValues(responseBody.error);
  }
}
var noop4 = function() {
};
var idCounter = 0;
var pendingRequests = {};
var isIE = typeof global !== "undefined" && global.XDomainRequest;
function ieVersion() {
  const match = navigator.userAgent.toString().match(/MSIE\s([\d.]+)/);
  return match && Number(match[1]);
}
function needJsonEnvelope() {
  let version2;
  return isIE && (version2 = ieVersion()) && version2 === 10;
}
function getHeader(xhr, header) {
  return xhr.getResponseHeader && xhr.getResponseHeader(header);
}
function isEncodingChunked(xhr) {
  return xhr.getResponseHeader && (xhr.getResponseHeader("transfer-encoding") || !xhr.getResponseHeader("content-length"));
}
function getHeadersAsObject(xhr) {
  const headerPairs = trim(xhr.getAllResponseHeaders()).split("\r\n");
  const headers = {};
  for (let i = 0; i < headerPairs.length; i++) {
    const parts = headerPairs[i].split(":").map(trim);
    headers[parts[0].toLowerCase()] = parts[1];
  }
  return headers;
}
var XHRRequest = class _XHRRequest extends eventemitter_default {
  constructor(uri, headers, params, body, requestMode, timeouts, method) {
    super();
    params = params || {};
    params.rnd = cheapRandStr();
    if (needJsonEnvelope() && !params.envelope)
      params.envelope = "json";
    this.uri = uri + toQueryString(params);
    this.headers = headers || {};
    this.body = body;
    this.method = method ? method.toUpperCase() : isEmptyArg(body) ? "GET" : "POST";
    this.requestMode = requestMode;
    this.timeouts = timeouts;
    this.timedOut = false;
    this.requestComplete = false;
    this.id = String(++idCounter);
    pendingRequests[this.id] = this;
  }
  static createRequest(uri, headers, params, body, requestMode, timeouts, method) {
    const _timeouts = timeouts || defaults_default.TIMEOUTS;
    return new _XHRRequest(
      uri,
      headers,
      copy(params),
      body,
      requestMode,
      _timeouts,
      method
    );
  }
  complete(err, body, headers, unpacked, statusCode) {
    if (!this.requestComplete) {
      this.requestComplete = true;
      if (!err && body) {
        this.emit("data", body);
      }
      this.emit("complete", err, body, headers, unpacked, statusCode);
      this.dispose();
    }
  }
  abort() {
    this.dispose();
  }
  exec() {
    let headers = this.headers;
    const timeout = this.requestMode == XHRStates_default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, timer = this.timer = setTimeout(() => {
      this.timedOut = true;
      xhr.abort();
    }, timeout), method = this.method, xhr = this.xhr = new XMLHttpRequest(), accept = headers["accept"];
    let body = this.body;
    let responseType = "text";
    if (!accept) {
      headers["accept"] = "application/json";
    } else if (accept.indexOf("application/x-msgpack") === 0) {
      responseType = "arraybuffer";
    }
    if (body) {
      const contentType = headers["content-type"] || (headers["content-type"] = "application/json");
      if (contentType.indexOf("application/json") > -1 && typeof body != "string")
        body = JSON.stringify(body);
    }
    xhr.open(method, this.uri, true);
    xhr.responseType = responseType;
    if ("authorization" in headers) {
      xhr.withCredentials = true;
    }
    for (const h in headers)
      xhr.setRequestHeader(h, headers[h]);
    const errorHandler = (errorEvent, message, code, statusCode2) => {
      var _a2;
      let errorMessage = message + " (event type: " + errorEvent.type + ")";
      if ((_a2 = this == null ? void 0 : this.xhr) == null ? void 0 : _a2.statusText)
        errorMessage += ", current statusText is " + this.xhr.statusText;
      logger_default.logAction(logger_default.LOG_ERROR, "Request.on" + errorEvent.type + "()", errorMessage);
      this.complete(new PartialErrorInfo(errorMessage, code, statusCode2));
    };
    xhr.onerror = function(errorEvent) {
      errorHandler(errorEvent, "XHR error occurred", null, 400);
    };
    xhr.onabort = (errorEvent) => {
      if (this.timedOut) {
        errorHandler(errorEvent, "Request aborted due to request timeout expiring", null, 408);
      } else {
        errorHandler(errorEvent, "Request cancelled", null, 400);
      }
    };
    xhr.ontimeout = function(errorEvent) {
      errorHandler(errorEvent, "Request timed out", null, 408);
    };
    let streaming;
    let statusCode;
    let successResponse;
    let streamPos = 0;
    let unpacked = false;
    const onResponse = () => {
      clearTimeout(timer);
      successResponse = statusCode < 400;
      if (statusCode == 204) {
        this.complete(null, null, null, null, statusCode);
        return;
      }
      streaming = this.requestMode == XHRStates_default.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);
    };
    const onEnd = () => {
      let parsedResponse;
      try {
        const contentType = getHeader(xhr, "content-type");
        const json = contentType ? contentType.indexOf("application/json") >= 0 : xhr.responseType == "text";
        if (json) {
          const jsonResponseBody = xhr.responseType === "arraybuffer" ? Platform.BufferUtils.utf8Decode(xhr.response) : String(xhr.responseText);
          if (jsonResponseBody.length) {
            parsedResponse = JSON.parse(jsonResponseBody);
          } else {
            parsedResponse = jsonResponseBody;
          }
          unpacked = true;
        } else {
          parsedResponse = xhr.response;
        }
        if (parsedResponse.response !== void 0) {
          statusCode = parsedResponse.statusCode;
          successResponse = statusCode < 400;
          headers = parsedResponse.headers;
          parsedResponse = parsedResponse.response;
        } else {
          headers = getHeadersAsObject(xhr);
        }
      } catch (e) {
        this.complete(new PartialErrorInfo("Malformed response body from server: " + e.message, null, 400));
        return;
      }
      if (successResponse || isArray(parsedResponse)) {
        this.complete(null, parsedResponse, headers, unpacked, statusCode);
        return;
      }
      let err = getAblyError(parsedResponse, headers);
      if (!err) {
        err = new PartialErrorInfo(
          "Error response received from server: " + statusCode + " body was: " + Platform.Config.inspect(parsedResponse),
          null,
          statusCode
        );
      }
      this.complete(err, parsedResponse, headers, unpacked, statusCode);
    };
    function onProgress() {
      const responseText = xhr.responseText;
      const bodyEnd = responseText.length - 1;
      let idx, chunk;
      while (streamPos < bodyEnd && (idx = responseText.indexOf("\n", streamPos)) > -1) {
        chunk = responseText.slice(streamPos, idx);
        streamPos = idx + 1;
        onChunk(chunk);
      }
    }
    const onChunk = (chunk) => {
      try {
        chunk = JSON.parse(chunk);
      } catch (e) {
        this.complete(new PartialErrorInfo("Malformed response body from server: " + e.message, null, 400));
        return;
      }
      this.emit("data", chunk);
    };
    const onStreamEnd = () => {
      onProgress();
      this.streamComplete = true;
      Platform.Config.nextTick(() => {
        this.complete();
      });
    };
    xhr.onreadystatechange = function() {
      const readyState = xhr.readyState;
      if (readyState < 3)
        return;
      if (xhr.status !== 0) {
        if (statusCode === void 0) {
          statusCode = xhr.status;
          if (statusCode === 1223)
            statusCode = 204;
          onResponse();
        }
        if (readyState == 3 && streaming) {
          onProgress();
        } else if (readyState == 4) {
          if (streaming)
            onStreamEnd();
          else
            onEnd();
        }
      }
    };
    xhr.send(body);
  }
  dispose() {
    const xhr = this.xhr;
    if (xhr) {
      xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop4;
      this.xhr = null;
      const timer = this.timer;
      if (timer) {
        clearTimeout(timer);
        this.timer = null;
      }
      if (!this.requestComplete)
        xhr.abort();
    }
    delete pendingRequests[this.id];
  }
};
var xhrrequest_default = XHRRequest;

// src/platform/web/lib/transport/fetchrequest.ts
function isAblyError2(responseBody, headers) {
  return !!headers.get("x-ably-errorcode");
}
function getAblyError2(responseBody, headers) {
  if (isAblyError2(responseBody, headers)) {
    return responseBody.error && ErrorInfo.fromValues(responseBody.error);
  }
}
function fetchRequest(method, client, uri, headers, params, body, callback) {
  const fetchHeaders = new Headers(headers || {});
  const _method = method ? method.toUpperCase() : isEmptyArg(body) ? "GET" : "POST";
  const controller = new AbortController();
  const timeout = setTimeout(
    () => {
      controller.abort();
      callback(new PartialErrorInfo("Request timed out", null, 408));
    },
    client ? client.options.timeouts.httpRequestTimeout : defaults_default.TIMEOUTS.httpRequestTimeout
  );
  const requestInit = {
    method: _method,
    headers: fetchHeaders,
    body
  };
  if (!Platform.Config.isWebworker) {
    requestInit.credentials = fetchHeaders.has("authorization") ? "include" : "same-origin";
  }
  getGlobalObject().fetch(uri + "?" + new URLSearchParams(params || {}), requestInit).then((res) => {
    clearTimeout(timeout);
    const contentType = res.headers.get("Content-Type");
    let prom;
    if (contentType && contentType.indexOf("application/x-msgpack") > -1) {
      prom = res.arrayBuffer();
    } else if (contentType && contentType.indexOf("application/json") > -1) {
      prom = res.json();
    } else {
      prom = res.text();
    }
    prom.then((body2) => {
      const packed = !!contentType && contentType.indexOf("application/x-msgpack") === -1;
      if (!res.ok) {
        const err = getAblyError2(body2, res.headers) || new PartialErrorInfo(
          "Error response received from server: " + res.status + " body was: " + Platform.Config.inspect(body2),
          null,
          res.status
        );
        callback(err, body2, res.headers, packed, res.status);
      } else {
        callback(null, body2, res.headers, packed, res.status);
      }
    });
  }).catch((err) => {
    clearTimeout(timeout);
    callback(err);
  });
}

// src/common/constants/HttpStatusCodes.ts
function isSuccessCode(statusCode) {
  return statusCode >= 200 /* Success */ && statusCode < 400 /* BadRequest */;
}

// src/platform/web/lib/util/http.ts
function shouldFallback(errorInfo) {
  const statusCode = errorInfo.statusCode;
  return statusCode === 408 && !errorInfo.code || statusCode === 400 && !errorInfo.code || statusCode >= 500 && statusCode <= 504;
}
function getHosts2(client) {
  if (isRealtime(client)) {
    const connectionHost = client.connection.connectionManager.host;
    if (connectionHost) {
      return [connectionHost].concat(defaults_default.getFallbackHosts(client.options));
    }
  }
  return defaults_default.getHosts(client.options);
}
var _a;
var Http = (_a = class {
  constructor(options) {
    this.checksInProgress = null;
    this.checkConnectivity = void 0;
    this.supportsAuthHeaders = false;
    this.supportsLinkHeaders = false;
    this._getHosts = getHosts2;
    this.options = options || {};
    const connectivityCheckUrl = this.options.connectivityCheckUrl || defaults_default.connectivityCheckUrl;
    const connectivityCheckParams = this.options.connectivityCheckParams;
    const connectivityUrlIsDefault = !this.options.connectivityCheckUrl;
    if (Platform.Config.xhrSupported) {
      this.supportsAuthHeaders = true;
      this.Request = function(method, client, uri, headers, params, body, callback) {
        const req = xhrrequest_default.createRequest(
          uri,
          headers,
          params,
          body,
          XHRStates_default.REQ_SEND,
          client && client.options.timeouts,
          method
        );
        req.once("complete", callback);
        req.exec();
        return req;
      };
      if (this.options.disableConnectivityCheck) {
        this.checkConnectivity = function(callback) {
          callback(null, true);
        };
      } else {
        this.checkConnectivity = function(callback) {
          logger_default.logAction(
            logger_default.LOG_MICRO,
            "(XHRRequest)Http.checkConnectivity()",
            "Sending; " + connectivityCheckUrl
          );
          this.doUri(
            HttpMethods_default.Get,
            null,
            connectivityCheckUrl,
            null,
            null,
            connectivityCheckParams,
            function(err, responseText, headers, packed, statusCode) {
              let result = false;
              if (!connectivityUrlIsDefault) {
                result = !err && isSuccessCode(statusCode);
              } else {
                result = !err && (responseText == null ? void 0 : responseText.replace(/\n/, "")) == "yes";
              }
              logger_default.logAction(logger_default.LOG_MICRO, "(XHRRequest)Http.checkConnectivity()", "Result: " + result);
              callback(null, result);
            }
          );
        };
      }
    } else if (Platform.Config.fetchSupported) {
      this.supportsAuthHeaders = true;
      this.Request = fetchRequest;
      this.checkConnectivity = function(callback) {
        logger_default.logAction(logger_default.LOG_MICRO, "(Fetch)Http.checkConnectivity()", "Sending; " + connectivityCheckUrl);
        this.doUri(
          HttpMethods_default.Get,
          null,
          connectivityCheckUrl,
          null,
          null,
          null,
          function(err, responseText) {
            const result = !err && (responseText == null ? void 0 : responseText.replace(/\n/, "")) == "yes";
            logger_default.logAction(logger_default.LOG_MICRO, "(Fetch)Http.checkConnectivity()", "Result: " + result);
            callback(null, result);
          }
        );
      };
    } else {
      this.Request = (method, rest, uri, headers, params, body, callback) => {
        callback(new PartialErrorInfo("no supported HTTP transports available", null, 400), null);
      };
    }
  }
  /* Unlike for doUri, the 'rest' param here is mandatory, as it's used to generate the hosts */
  do(method, client, path, headers, body, params, callback) {
    const uriFromHost = typeof path == "function" ? path : function(host) {
      return client.baseUri(host) + path;
    };
    const currentFallback = client._currentFallback;
    if (currentFallback) {
      if (currentFallback.validUntil > now()) {
        if (!this.Request) {
          callback == null ? void 0 : callback(new PartialErrorInfo("Request invoked before assigned to", null, 500));
          return;
        }
        this.Request(
          method,
          client,
          uriFromHost(currentFallback.host),
          headers,
          params,
          body,
          (err, ...args) => {
            if (err && shouldFallback(err)) {
              client._currentFallback = null;
              this.do(method, client, path, headers, body, params, callback);
              return;
            }
            callback == null ? void 0 : callback(err, ...args);
          }
        );
        return;
      } else {
        client._currentFallback = null;
      }
    }
    const hosts = getHosts2(client);
    if (hosts.length === 1) {
      this.doUri(method, client, uriFromHost(hosts[0]), headers, body, params, callback);
      return;
    }
    const tryAHost = (candidateHosts, persistOnSuccess) => {
      const host = candidateHosts.shift();
      this.doUri(
        method,
        client,
        uriFromHost(host),
        headers,
        body,
        params,
        function(err, ...args) {
          if (err && shouldFallback(err) && candidateHosts.length) {
            tryAHost(candidateHosts, true);
            return;
          }
          if (persistOnSuccess) {
            client._currentFallback = {
              host,
              validUntil: now() + client.options.timeouts.fallbackRetryTimeout
            };
          }
          callback == null ? void 0 : callback(err, ...args);
        }
      );
    };
    tryAHost(hosts);
  }
  doUri(method, client, uri, headers, body, params, callback) {
    if (!this.Request) {
      callback(new PartialErrorInfo("Request invoked before assigned to", null, 500));
      return;
    }
    this.Request(method, client, uri, headers, params, body, callback);
  }
}, _a.methods = [HttpMethods_default.Get, HttpMethods_default.Delete, HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a.methodsWithoutBody = [HttpMethods_default.Get, HttpMethods_default.Delete], _a.methodsWithBody = [HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a);
var http_default = Http;

// src/platform/web/lib/util/msgpack.ts
function inspect(buffer) {
  if (buffer === void 0)
    return "undefined";
  let view;
  let type;
  if (buffer instanceof ArrayBuffer) {
    type = "ArrayBuffer";
    view = new DataView(buffer);
  } else if (buffer instanceof DataView) {
    type = "DataView";
    view = buffer;
  }
  if (!view)
    return JSON.stringify(buffer);
  const bytes = [];
  for (let i = 0; i < buffer.byteLength; i++) {
    if (i > 20) {
      bytes.push("...");
      break;
    }
    let byte_ = view.getUint8(i).toString(16);
    if (byte_.length === 1)
      byte_ = "0" + byte_;
    bytes.push(byte_);
  }
  return "<" + type + " " + bytes.join(" ") + ">";
}
function utf8Write(view, offset, string) {
  for (let i = 0, l = string.length; i < l; i++) {
    const codePoint = string.charCodeAt(i);
    if (codePoint < 128) {
      view.setUint8(offset++, codePoint >>> 0 & 127 | 0);
      continue;
    }
    if (codePoint < 2048) {
      view.setUint8(offset++, codePoint >>> 6 & 31 | 192);
      view.setUint8(offset++, codePoint >>> 0 & 63 | 128);
      continue;
    }
    if (codePoint < 65536) {
      view.setUint8(offset++, codePoint >>> 12 & 15 | 224);
      view.setUint8(offset++, codePoint >>> 6 & 63 | 128);
      view.setUint8(offset++, codePoint >>> 0 & 63 | 128);
      continue;
    }
    if (codePoint < 1114112) {
      view.setUint8(offset++, codePoint >>> 18 & 7 | 240);
      view.setUint8(offset++, codePoint >>> 12 & 63 | 128);
      view.setUint8(offset++, codePoint >>> 6 & 63 | 128);
      view.setUint8(offset++, codePoint >>> 0 & 63 | 128);
      continue;
    }
    throw new Error("bad codepoint " + codePoint);
  }
}
function utf8Read(view, offset, length) {
  let string = "";
  for (let i = offset, end = offset + length; i < end; i++) {
    const byte_ = view.getUint8(i);
    if ((byte_ & 128) === 0) {
      string += String.fromCharCode(byte_);
      continue;
    }
    if ((byte_ & 224) === 192) {
      string += String.fromCharCode((byte_ & 15) << 6 | view.getUint8(++i) & 63);
      continue;
    }
    if ((byte_ & 240) === 224) {
      string += String.fromCharCode(
        (byte_ & 15) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0
      );
      continue;
    }
    if ((byte_ & 248) === 240) {
      string += String.fromCharCode(
        (byte_ & 7) << 18 | (view.getUint8(++i) & 63) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0
      );
      continue;
    }
    throw new Error("Invalid byte " + byte_.toString(16));
  }
  return string;
}
function utf8ByteCount(string) {
  let count = 0;
  for (let i = 0, l = string.length; i < l; i++) {
    const codePoint = string.charCodeAt(i);
    if (codePoint < 128) {
      count += 1;
      continue;
    }
    if (codePoint < 2048) {
      count += 2;
      continue;
    }
    if (codePoint < 65536) {
      count += 3;
      continue;
    }
    if (codePoint < 1114112) {
      count += 4;
      continue;
    }
    throw new Error("bad codepoint " + codePoint);
  }
  return count;
}
function encode(value, sparse) {
  const size = sizeof(value, sparse);
  if (size === 0)
    return void 0;
  const buffer = new ArrayBuffer(size);
  const view = new DataView(buffer);
  _encode(value, view, 0, sparse);
  return buffer;
}
var SH_L_32 = (1 << 16) * (1 << 16);
var SH_R_32 = 1 / SH_L_32;
function getInt64(view, offset) {
  offset = offset || 0;
  return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);
}
function getUint64(view, offset) {
  offset = offset || 0;
  return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);
}
function setInt64(view, offset, val) {
  if (val < 9223372036854776e3) {
    view.setInt32(offset, Math.floor(val * SH_R_32));
    view.setInt32(offset + 4, val & -1);
  } else {
    view.setUint32(offset, 2147483647);
    view.setUint32(offset + 4, 2147483647);
  }
}
function setUint64(view, offset, val) {
  if (val < 18446744073709552e3) {
    view.setUint32(offset, Math.floor(val * SH_R_32));
    view.setInt32(offset + 4, val & -1);
  } else {
    view.setUint32(offset, 4294967295);
    view.setUint32(offset + 4, 4294967295);
  }
}
var Decoder = class {
  constructor(view, offset) {
    this.map = (length) => {
      const value = {};
      for (let i = 0; i < length; i++) {
        const key = this.parse();
        value[key] = this.parse();
      }
      return value;
    };
    this.bin = (length) => {
      const value = new ArrayBuffer(length);
      new Uint8Array(value).set(new Uint8Array(this.view.buffer, this.offset, length), 0);
      this.offset += length;
      return value;
    };
    this.buf = this.bin;
    this.str = (length) => {
      const value = utf8Read(this.view, this.offset, length);
      this.offset += length;
      return value;
    };
    this.array = (length) => {
      const value = new Array(length);
      for (let i = 0; i < length; i++) {
        value[i] = this.parse();
      }
      return value;
    };
    this.ext = (length) => {
      this.offset += length;
      return {
        type: this.view.getInt8(this.offset),
        data: this.buf(length)
      };
    };
    this.parse = () => {
      const type = this.view.getUint8(this.offset);
      let value, length;
      if ((type & 128) === 0) {
        this.offset++;
        return type;
      }
      if ((type & 240) === 128) {
        length = type & 15;
        this.offset++;
        return this.map(length);
      }
      if ((type & 240) === 144) {
        length = type & 15;
        this.offset++;
        return this.array(length);
      }
      if ((type & 224) === 160) {
        length = type & 31;
        this.offset++;
        return this.str(length);
      }
      if ((type & 224) === 224) {
        value = this.view.getInt8(this.offset);
        this.offset++;
        return value;
      }
      switch (type) {
        case 192:
          this.offset++;
          return null;
        case 193:
          this.offset++;
          return void 0;
        case 194:
          this.offset++;
          return false;
        case 195:
          this.offset++;
          return true;
        case 196:
          length = this.view.getUint8(this.offset + 1);
          this.offset += 2;
          return this.bin(length);
        case 197:
          length = this.view.getUint16(this.offset + 1);
          this.offset += 3;
          return this.bin(length);
        case 198:
          length = this.view.getUint32(this.offset + 1);
          this.offset += 5;
          return this.bin(length);
        case 199:
          length = this.view.getUint8(this.offset + 1);
          this.offset += 2;
          return this.ext(length);
        case 200:
          length = this.view.getUint16(this.offset + 1);
          this.offset += 3;
          return this.ext(length);
        case 201:
          length = this.view.getUint32(this.offset + 1);
          this.offset += 5;
          return this.ext(length);
        case 202:
          value = this.view.getFloat32(this.offset + 1);
          this.offset += 5;
          return value;
        case 203:
          value = this.view.getFloat64(this.offset + 1);
          this.offset += 9;
          return value;
        case 204:
          value = this.view.getUint8(this.offset + 1);
          this.offset += 2;
          return value;
        case 205:
          value = this.view.getUint16(this.offset + 1);
          this.offset += 3;
          return value;
        case 206:
          value = this.view.getUint32(this.offset + 1);
          this.offset += 5;
          return value;
        case 207:
          value = getUint64(this.view, this.offset + 1);
          this.offset += 9;
          return value;
        case 208:
          value = this.view.getInt8(this.offset + 1);
          this.offset += 2;
          return value;
        case 209:
          value = this.view.getInt16(this.offset + 1);
          this.offset += 3;
          return value;
        case 210:
          value = this.view.getInt32(this.offset + 1);
          this.offset += 5;
          return value;
        case 211:
          value = getInt64(this.view, this.offset + 1);
          this.offset += 9;
          return value;
        case 212:
          length = 1;
          this.offset++;
          return this.ext(length);
        case 213:
          length = 2;
          this.offset++;
          return this.ext(length);
        case 214:
          length = 4;
          this.offset++;
          return this.ext(length);
        case 215:
          length = 8;
          this.offset++;
          return this.ext(length);
        case 216:
          length = 16;
          this.offset++;
          return this.ext(length);
        case 217:
          length = this.view.getUint8(this.offset + 1);
          this.offset += 2;
          return this.str(length);
        case 218:
          length = this.view.getUint16(this.offset + 1);
          this.offset += 3;
          return this.str(length);
        case 219:
          length = this.view.getUint32(this.offset + 1);
          this.offset += 5;
          return this.str(length);
        case 220:
          length = this.view.getUint16(this.offset + 1);
          this.offset += 3;
          return this.array(length);
        case 221:
          length = this.view.getUint32(this.offset + 1);
          this.offset += 5;
          return this.array(length);
        case 222:
          length = this.view.getUint16(this.offset + 1);
          this.offset += 3;
          return this.map(length);
        case 223:
          length = this.view.getUint32(this.offset + 1);
          this.offset += 5;
          return this.map(length);
      }
      throw new Error("Unknown type 0x" + type.toString(16));
    };
    this.offset = offset || 0;
    this.view = view;
  }
};
function decode(buffer) {
  const view = new DataView(buffer);
  const decoder = new Decoder(view);
  const value = decoder.parse();
  if (decoder.offset !== buffer.byteLength)
    throw new Error(buffer.byteLength - decoder.offset + " trailing bytes");
  return value;
}
function encodeableKeys(value, sparse) {
  return Object.keys(value).filter(function(e) {
    const val = value[e], type = typeof val;
    return (!sparse || val !== void 0 && val !== null) && ("function" !== type || !!val.toJSON);
  });
}
function _encode(value, view, offset, sparse) {
  const type = typeof value;
  if (typeof value === "string") {
    const length = utf8ByteCount(value);
    if (length < 32) {
      view.setUint8(offset, length | 160);
      utf8Write(view, offset + 1, value);
      return 1 + length;
    }
    if (length < 256) {
      view.setUint8(offset, 217);
      view.setUint8(offset + 1, length);
      utf8Write(view, offset + 2, value);
      return 2 + length;
    }
    if (length < 65536) {
      view.setUint8(offset, 218);
      view.setUint16(offset + 1, length);
      utf8Write(view, offset + 3, value);
      return 3 + length;
    }
    if (length < 4294967296) {
      view.setUint8(offset, 219);
      view.setUint32(offset + 1, length);
      utf8Write(view, offset + 5, value);
      return 5 + length;
    }
  }
  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
    value = value.buffer;
  }
  if (value instanceof ArrayBuffer) {
    const length = value.byteLength;
    if (length < 256) {
      view.setUint8(offset, 196);
      view.setUint8(offset + 1, length);
      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);
      return 2 + length;
    }
    if (length < 65536) {
      view.setUint8(offset, 197);
      view.setUint16(offset + 1, length);
      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);
      return 3 + length;
    }
    if (length < 4294967296) {
      view.setUint8(offset, 198);
      view.setUint32(offset + 1, length);
      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);
      return 5 + length;
    }
  }
  if (typeof value === "number") {
    if (Math.floor(value) !== value) {
      view.setUint8(offset, 203);
      view.setFloat64(offset + 1, value);
      return 9;
    }
    if (value >= 0) {
      if (value < 128) {
        view.setUint8(offset, value);
        return 1;
      }
      if (value < 256) {
        view.setUint8(offset, 204);
        view.setUint8(offset + 1, value);
        return 2;
      }
      if (value < 65536) {
        view.setUint8(offset, 205);
        view.setUint16(offset + 1, value);
        return 3;
      }
      if (value < 4294967296) {
        view.setUint8(offset, 206);
        view.setUint32(offset + 1, value);
        return 5;
      }
      if (value < 18446744073709552e3) {
        view.setUint8(offset, 207);
        setUint64(view, offset + 1, value);
        return 9;
      }
      throw new Error("Number too big 0x" + value.toString(16));
    }
    if (value >= -32) {
      view.setInt8(offset, value);
      return 1;
    }
    if (value >= -128) {
      view.setUint8(offset, 208);
      view.setInt8(offset + 1, value);
      return 2;
    }
    if (value >= -32768) {
      view.setUint8(offset, 209);
      view.setInt16(offset + 1, value);
      return 3;
    }
    if (value >= -2147483648) {
      view.setUint8(offset, 210);
      view.setInt32(offset + 1, value);
      return 5;
    }
    if (value >= -9223372036854776e3) {
      view.setUint8(offset, 211);
      setInt64(view, offset + 1, value);
      return 9;
    }
    throw new Error("Number too small -0x" + (-value).toString(16).substr(1));
  }
  if (type === "undefined") {
    if (sparse)
      return 0;
    view.setUint8(offset, 212);
    view.setUint8(offset + 1, 0);
    view.setUint8(offset + 2, 0);
    return 3;
  }
  if (value === null) {
    if (sparse)
      return 0;
    view.setUint8(offset, 192);
    return 1;
  }
  if (type === "boolean") {
    view.setUint8(offset, value ? 195 : 194);
    return 1;
  }
  if ("function" === typeof value.toJSON)
    return _encode(value.toJSON(), view, offset, sparse);
  if (type === "object") {
    let length, size = 0;
    let keys;
    const isArray2 = Array.isArray(value);
    if (isArray2) {
      length = value.length;
    } else {
      keys = encodeableKeys(value, sparse);
      length = keys.length;
    }
    if (length < 16) {
      view.setUint8(offset, length | (isArray2 ? 144 : 128));
      size = 1;
    } else if (length < 65536) {
      view.setUint8(offset, isArray2 ? 220 : 222);
      view.setUint16(offset + 1, length);
      size = 3;
    } else if (length < 4294967296) {
      view.setUint8(offset, isArray2 ? 221 : 223);
      view.setUint32(offset + 1, length);
      size = 5;
    }
    if (isArray2) {
      for (let i = 0; i < length; i++) {
        size += _encode(value[i], view, offset + size, sparse);
      }
    } else if (keys) {
      for (let i = 0; i < length; i++) {
        const key = keys[i];
        size += _encode(key, view, offset + size);
        size += _encode(value[key], view, offset + size, sparse);
      }
    }
    return size;
  }
  if (type === "function")
    return 0;
  throw new Error("Unknown type " + type);
}
function sizeof(value, sparse) {
  const type = typeof value;
  if (type === "string") {
    const length = utf8ByteCount(value);
    if (length < 32) {
      return 1 + length;
    }
    if (length < 256) {
      return 2 + length;
    }
    if (length < 65536) {
      return 3 + length;
    }
    if (length < 4294967296) {
      return 5 + length;
    }
  }
  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
    value = value.buffer;
  }
  if (value instanceof ArrayBuffer) {
    const length = value.byteLength;
    if (length < 256) {
      return 2 + length;
    }
    if (length < 65536) {
      return 3 + length;
    }
    if (length < 4294967296) {
      return 5 + length;
    }
  }
  if (typeof value === "number") {
    if (Math.floor(value) !== value)
      return 9;
    if (value >= 0) {
      if (value < 128)
        return 1;
      if (value < 256)
        return 2;
      if (value < 65536)
        return 3;
      if (value < 4294967296)
        return 5;
      if (value < 18446744073709552e3)
        return 9;
      throw new Error("Number too big 0x" + value.toString(16));
    }
    if (value >= -32)
      return 1;
    if (value >= -128)
      return 2;
    if (value >= -32768)
      return 3;
    if (value >= -2147483648)
      return 5;
    if (value >= -9223372036854776e3)
      return 9;
    throw new Error("Number too small -0x" + value.toString(16).substr(1));
  }
  if (type === "boolean")
    return 1;
  if (value === null)
    return sparse ? 0 : 1;
  if (value === void 0)
    return sparse ? 0 : 3;
  if ("function" === typeof value.toJSON)
    return sizeof(value.toJSON(), sparse);
  if (type === "object") {
    let length, size = 0;
    if (Array.isArray(value)) {
      length = value.length;
      for (let i = 0; i < length; i++) {
        size += sizeof(value[i], sparse);
      }
    } else {
      const keys = encodeableKeys(value, sparse);
      length = keys.length;
      for (let i = 0; i < length; i++) {
        const key = keys[i];
        size += sizeof(key) + sizeof(value[key], sparse);
      }
    }
    if (length < 16) {
      return 1 + size;
    }
    if (length < 65536) {
      return 3 + size;
    }
    if (length < 4294967296) {
      return 5 + size;
    }
    throw new Error("Array or object too long 0x" + length.toString(16));
  }
  if (type === "function")
    return 0;
  throw new Error("Unknown type " + type);
}
var msgpack_default = {
  encode,
  decode,
  inspect,
  utf8Write,
  utf8Read,
  utf8ByteCount
};

// src/platform/web/config.ts
var globalObject2 = getGlobalObject();
if (typeof Window === "undefined" && typeof WorkerGlobalScope === "undefined") {
  console.log(
    "Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm"
  );
}
function allowComet() {
  const loc = globalObject2.location;
  return !globalObject2.WebSocket || !loc || !loc.origin || loc.origin.indexOf("http") > -1;
}
var userAgent = globalObject2.navigator && globalObject2.navigator.userAgent.toString();
var currentUrl = globalObject2.location && globalObject2.location.href;
var Config = {
  agent: "browser",
  logTimestamps: true,
  userAgent,
  currentUrl,
  noUpgrade: userAgent && !!userAgent.match(/MSIE\s8\.0/),
  binaryType: "arraybuffer",
  WebSocket: globalObject2.WebSocket,
  fetchSupported: !!globalObject2.fetch,
  xhrSupported: globalObject2.XMLHttpRequest && "withCredentials" in new XMLHttpRequest(),
  allowComet: allowComet(),
  streamingSupported: true,
  useProtocolHeartbeats: true,
  msgpack: msgpack_default,
  supportsBinary: !!globalObject2.TextDecoder,
  preferBinary: false,
  ArrayBuffer: globalObject2.ArrayBuffer,
  atob: globalObject2.atob,
  nextTick: typeof globalObject2.setImmediate !== "undefined" ? globalObject2.setImmediate.bind(globalObject2) : function(f) {
    setTimeout(f, 0);
  },
  addEventListener: globalObject2.addEventListener,
  inspect: JSON.stringify,
  stringByteSize: function(str) {
    return globalObject2.TextDecoder && new globalObject2.TextEncoder().encode(str).length || str.length;
  },
  TextEncoder: globalObject2.TextEncoder,
  TextDecoder: globalObject2.TextDecoder,
  getRandomValues: function(crypto2) {
    if (crypto2 === void 0) {
      return void 0;
    }
    return function(arr, callback) {
      crypto2.getRandomValues(arr);
      if (callback) {
        callback(null);
      }
    };
  }(globalObject2.crypto || msCrypto)
};
var config_default = Config;

// src/platform/web/lib/util/webstorage.ts
var test = "ablyjs-storage-test";
var globalObject3 = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : self;
var Webstorage = class {
  constructor() {
    try {
      globalObject3.sessionStorage.setItem(test, test);
      globalObject3.sessionStorage.removeItem(test);
      this.sessionSupported = true;
    } catch (e) {
      this.sessionSupported = false;
    }
    try {
      globalObject3.localStorage.setItem(test, test);
      globalObject3.localStorage.removeItem(test);
      this.localSupported = true;
    } catch (e) {
      this.localSupported = false;
    }
  }
  get(name) {
    return this._get(name, false);
  }
  getSession(name) {
    return this._get(name, true);
  }
  remove(name) {
    return this._remove(name, false);
  }
  removeSession(name) {
    return this._remove(name, true);
  }
  set(name, value, ttl) {
    return this._set(name, value, ttl, false);
  }
  setSession(name, value, ttl) {
    return this._set(name, value, ttl, true);
  }
  _set(name, value, ttl, session) {
    const wrappedValue = { value };
    if (ttl) {
      wrappedValue.expires = now() + ttl;
    }
    return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));
  }
  _get(name, session) {
    if (session && !this.sessionSupported)
      throw new Error("Session Storage not supported");
    if (!session && !this.localSupported)
      throw new Error("Local Storage not supported");
    const rawItem = this.storageInterface(session).getItem(name);
    if (!rawItem)
      return null;
    const wrappedValue = JSON.parse(rawItem);
    if (wrappedValue.expires && wrappedValue.expires < now()) {
      this.storageInterface(session).removeItem(name);
      return null;
    }
    return wrappedValue.value;
  }
  _remove(name, session) {
    return this.storageInterface(session).removeItem(name);
  }
  storageInterface(session) {
    return session ? globalObject3.sessionStorage : globalObject3.localStorage;
  }
};
var webstorage_default = new Webstorage();

// src/common/constants/TransportNames.ts
var TransportNames = /* @__PURE__ */ ((TransportNames2) => {
  TransportNames2["WebSocket"] = "web_socket";
  TransportNames2["Comet"] = "comet";
  TransportNames2["XhrStreaming"] = "xhr_streaming";
  TransportNames2["XhrPolling"] = "xhr_polling";
  return TransportNames2;
})(TransportNames || {});
var TransportNames_default = TransportNames;

// src/platform/web/lib/util/defaults.ts
var Defaults2 = {
  connectivityCheckUrl: "https://internet-up.ably-realtime.com/is-the-internet-up.txt",
  /* Order matters here: the base transport is the leftmost one in the
   * intersection of baseTransportOrder and the transports clientOption that's
   * supported. */
  defaultTransports: [TransportNames_default.XhrPolling, TransportNames_default.XhrStreaming, TransportNames_default.WebSocket],
  baseTransportOrder: [TransportNames_default.XhrPolling, TransportNames_default.XhrStreaming, TransportNames_default.WebSocket],
  transportPreferenceOrder: [TransportNames_default.XhrPolling, TransportNames_default.XhrStreaming, TransportNames_default.WebSocket],
  upgradeTransports: [TransportNames_default.XhrStreaming, TransportNames_default.WebSocket]
};
var defaults_default2 = Defaults2;

// src/platform/web/modules.ts
var Crypto = crypto_default(config_default, bufferutils_default);
Platform.Crypto = Crypto;
Platform.BufferUtils = bufferutils_default;
Platform.Http = http_default;
Platform.Config = config_default;
Platform.WebStorage = webstorage_default;
logger_default.initLogHandlers();
Platform.Defaults = getDefaults(defaults_default2);
if (Platform.Config.agent) {
  Platform.Defaults.agent += " " + Platform.Config.agent;
}
if (Platform.Config.noUpgrade) {
  Platform.Defaults.upgradeTransports = [];
}
export {
  BaseClient,
  Crypto,
  rest_default as Rest
};
//# sourceMappingURL=index.js.map
