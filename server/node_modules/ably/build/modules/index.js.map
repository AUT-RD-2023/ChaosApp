{
  "version": 3,
  "sources": ["../../src/common/platform.ts", "../../src/common/lib/util/logger.ts", "../../src/common/lib/types/errorinfo.ts", "../../src/common/lib/util/utils.ts", "../../package.json", "../../src/common/lib/util/defaults.ts", "../../src/common/lib/util/multicaster.ts", "../../src/common/constants/HttpMethods.ts", "../../src/common/lib/client/auth.ts", "../../src/common/lib/client/baseclient.ts", "../../src/common/lib/types/devicedetails.ts", "../../src/common/lib/client/resource.ts", "../../src/common/lib/client/paginatedresource.ts", "../../src/common/lib/types/pushchannelsubscription.ts", "../../src/common/lib/client/push.ts", "../../src/common/lib/util/eventemitter.ts", "../../src/common/lib/types/message.ts", "../../src/common/lib/types/presencemessage.ts", "../../src/common/lib/client/presence.ts", "../../src/common/lib/client/channel.ts", "../../src/common/lib/types/stats.ts", "../../src/common/lib/client/rest.ts", "../../src/platform/web/lib/util/hmac-sha256.ts", "../../src/platform/web/lib/util/bufferutils.ts", "../../src/platform/web/lib/util/crypto.ts", "../../src/common/constants/XHRStates.ts", "../../src/platform/web/lib/transport/xhrrequest.ts", "../../src/platform/web/lib/transport/fetchrequest.ts", "../../src/common/constants/HttpStatusCodes.ts", "../../src/platform/web/lib/util/http.ts", "../../src/platform/web/lib/util/msgpack.ts", "../../src/platform/web/config.ts", "../../src/platform/web/lib/util/webstorage.ts", "../../src/common/constants/TransportNames.ts", "../../src/platform/web/lib/util/defaults.ts", "../../src/platform/web/modules.ts"],
  "sourcesContent": ["import { IPlatformConfig } from './types/IPlatformConfig';\nimport { IHttp } from './types/http';\nimport ConnectionManager from './lib/transport/connectionmanager';\nimport IDefaults from './types/IDefaults';\nimport IWebStorage from './types/IWebStorage';\nimport IBufferUtils from './types/IBufferUtils';\nimport Transport from './lib/transport/transport';\nimport * as WebBufferUtils from '../platform/web/lib/util/bufferutils';\nimport * as NodeBufferUtils from '../platform/nodejs/lib/util/bufferutils';\n\ntype Bufferlike = WebBufferUtils.Bufferlike | NodeBufferUtils.Bufferlike;\ntype BufferUtilsOutput = WebBufferUtils.Output | NodeBufferUtils.Output;\ntype ToBufferOutput = WebBufferUtils.ToBufferOutput | NodeBufferUtils.ToBufferOutput;\n\nexport default class Platform {\n  static Config: IPlatformConfig;\n  /*\n     What we actually _want_ is for Platform to be a generic class\n     parameterised by Bufferlike etc, but that requires far-reaching changes to\n     components that make use of Platform. So instead we have to advertise a\n     BufferUtils object that accepts a broader range of data types than it\n     can in reality handle.\n   */\n  static BufferUtils: IBufferUtils<Bufferlike, BufferUtilsOutput, ToBufferOutput>;\n  /*\n     This should be a class whose static methods implement the ICryptoStatic\n     interface, but (for the same reasons as described in the BufferUtils\n     comment above) Platform doesn\u2019t currently allow us to express the\n     generic parameters, hence keeping the type as `any`.\n   */\n  static Crypto: any;\n  static Http: typeof IHttp;\n  static Transports: Array<(connectionManager: typeof ConnectionManager) => Transport>;\n  static Defaults: IDefaults;\n  static WebStorage: IWebStorage | null;\n}\n", "import Platform from 'common/platform';\n\nexport type LoggerOptions = {\n  handler: LoggerFunction;\n  level: LogLevels;\n};\ntype LoggerFunction = (...args: string[]) => void;\n\n// Workaround for salesforce lightning locker compatibility\n// This is a shorthand version of Utils.getGlobalObject (which we can't use here without creating a circular import)\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\n\nenum LogLevels {\n  None = 0,\n  Error = 1,\n  Major = 2,\n  Minor = 3,\n  Micro = 4,\n}\n\nfunction pad(timeSegment: number, three?: number) {\n  return `${timeSegment}`.padStart(three ? 3 : 2, '0');\n}\n\nfunction getHandler(logger: Function): Function {\n  return Platform.Config.logTimestamps\n    ? function (msg: unknown) {\n        const time = new Date();\n        logger(\n          pad(time.getHours()) +\n            ':' +\n            pad(time.getMinutes()) +\n            ':' +\n            pad(time.getSeconds()) +\n            '.' +\n            pad(time.getMilliseconds(), 1) +\n            ' ' +\n            msg\n        );\n      }\n    : logger;\n}\n\nconst getDefaultLoggers = (): [Function, Function] => {\n  let consoleLogger;\n  let errorLogger;\n\n  /* Can't just check for console && console.log; fails in IE <=9 */\n  if (\n    (typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') /* node */ ||\n    typeof globalObject?.console?.log?.apply === 'function' /* sensible browsers */\n  ) {\n    consoleLogger = function (...args: unknown[]) {\n      console.log.apply(console, args);\n    };\n    errorLogger = console.warn\n      ? function (...args: unknown[]) {\n          console.warn.apply(console, args);\n        }\n      : consoleLogger;\n  } else if (globalObject?.console.log as unknown) {\n    /* IE <= 9 with the console open -- console.log does not\n     * inherit from Function, so has no apply method */\n    consoleLogger = errorLogger = function () {\n      Function.prototype.apply.call(console.log, console, arguments);\n    };\n  } else {\n    /* IE <= 9 when dev tools are closed - window.console not even defined */\n    consoleLogger = errorLogger = function () {};\n  }\n\n  return [consoleLogger, errorLogger].map(getHandler) as [Function, Function];\n};\n\nclass Logger {\n  private static logLevel: LogLevels = LogLevels.Error; // default logLevel\n  private static logHandler: Function;\n  private static logErrorHandler: Function;\n\n  // public constants\n  static readonly LOG_NONE: LogLevels = LogLevels.None;\n  static readonly LOG_ERROR: LogLevels = LogLevels.Error;\n  static readonly LOG_MAJOR: LogLevels = LogLevels.Major;\n  static readonly LOG_MINOR: LogLevels = LogLevels.Minor;\n  static readonly LOG_MICRO: LogLevels = LogLevels.Micro;\n  // aliases\n  static readonly LOG_DEFAULT: LogLevels = LogLevels.Error;\n  static readonly LOG_DEBUG: LogLevels = LogLevels.Micro;\n\n  constructor() {\n    Logger.logLevel = Logger.LOG_DEFAULT;\n  }\n\n  static initLogHandlers() {\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\n    this.logHandler = logHandler;\n    this.logErrorHandler = logErrorHandler;\n  }\n\n  /* public static functions */\n  static logAction = (level: LogLevels, action: string, message?: string) => {\n    if (Logger.shouldLog(level)) {\n      (level === LogLevels.Error ? Logger.logErrorHandler : Logger.logHandler)('Ably: ' + action + ': ' + message);\n    }\n  };\n\n  /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\n\t   the object being serialised if the log level will not output the message */\n  static shouldLog = (level: LogLevels) => {\n    return level <= Logger.logLevel;\n  };\n\n  static setLog = (level: LogLevels | undefined, handler: Function | undefined) => {\n    if (level !== undefined) Logger.logLevel = level;\n    if (handler !== undefined) Logger.logHandler = Logger.logErrorHandler = handler;\n  };\n}\n\nexport default Logger;\n", "import Platform from 'common/platform';\nimport * as Utils from '../util/utils';\nimport * as API from '../../../../ably';\n\nexport interface IPartialErrorInfo extends Error {\n  code: number | null;\n  statusCode?: number;\n  cause?: string | Error | ErrorInfo;\n  href?: string;\n}\n\nfunction toString(err: ErrorInfo | PartialErrorInfo) {\n  let result = '[' + err.constructor.name;\n  if (err.message) result += ': ' + err.message;\n  if (err.statusCode) result += '; statusCode=' + err.statusCode;\n  if (err.code) result += '; code=' + err.code;\n  if (err.cause) result += '; cause=' + Utils.inspectError(err.cause);\n  if (err.href && !(err.message && err.message.indexOf('help.ably.io') > -1)) result += '; see ' + err.href + ' ';\n  result += ']';\n  return result;\n}\n\nexport interface IConvertibleToErrorInfo {\n  message: string;\n  code: number;\n  statusCode: number;\n}\n\nexport default class ErrorInfo extends Error implements IPartialErrorInfo, API.Types.ErrorInfo {\n  code: number;\n  statusCode: number;\n  cause?: string | Error | ErrorInfo;\n  href?: string;\n\n  constructor(message: string, code: number, statusCode: number, cause?: string | Error | ErrorInfo) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== 'undefined') {\n      Object.setPrototypeOf(this, ErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n\n  toString(): string {\n    return toString(this);\n  }\n\n  static fromValues(values: IConvertibleToErrorInfo): ErrorInfo {\n    const { message, code, statusCode } = values;\n    if (typeof message !== 'string' || typeof code !== 'number' || typeof statusCode !== 'number') {\n      throw new Error('ErrorInfo.fromValues(): invalid values: ' + Platform.Config.inspect(values));\n    }\n    const result = Object.assign(new ErrorInfo(message, code, statusCode), values);\n    if (result.code && !result.href) {\n      result.href = 'https://help.ably.io/error/' + result.code;\n    }\n    return result;\n  }\n}\n\nexport class PartialErrorInfo extends Error implements IPartialErrorInfo {\n  code: number | null;\n  statusCode?: number;\n  cause?: string | Error | ErrorInfo;\n  href?: string;\n\n  constructor(message: string, code: number | null, statusCode?: number, cause?: string | Error | ErrorInfo) {\n    super(message);\n    if (typeof Object.setPrototypeOf !== 'undefined') {\n      Object.setPrototypeOf(this, PartialErrorInfo.prototype);\n    }\n    this.code = code;\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n\n  toString(): string {\n    return toString(this);\n  }\n}\n", "import Platform from 'common/platform';\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\nimport Realtime from '../client/realtime';\nimport { BaseClient } from '../client/baseclient';\n\nfunction randomPosn(arrOrStr: Array<unknown> | string) {\n  return Math.floor(Math.random() * arrOrStr.length);\n}\n\n/*\n * Add a set of properties to a target object\n * target: the target object\n * props:  an object whose enumerable properties are\n *         added, by reference only\n */\nexport function mixin(\n  target: Record<string, unknown>,\n  ...args: Array<object | undefined | null>\n): Record<string, unknown> {\n  for (let i = 0; i < args.length; i++) {\n    const source = args[i];\n    if (!source) {\n      break;\n    }\n    const hasOwnProperty = Object.prototype.hasOwnProperty;\n    for (const key in source) {\n      if (!hasOwnProperty || hasOwnProperty.call(source, key)) {\n        target[key] = (source as Record<string, unknown>)[key];\n      }\n    }\n  }\n  return target;\n}\n\n/*\n * Add a set of properties to a target object\n * target: the target object\n * props:  an object whose enumerable properties are\n *         added, by reference only\n */\nexport function copy<T = Record<string, unknown>>(src: T | Record<string, unknown> | null | undefined): T {\n  return mixin({}, src as Record<string, unknown>) as T;\n}\n\n/*\n * Determine whether or not a given object is\n * an array.\n */\nexport const isArray =\n  Array.isArray ||\n  function (value: unknown): value is Array<unknown> {\n    return Object.prototype.toString.call(value) == '[object Array]';\n  };\n\n/*\n * Ensures that an Array object is always returned\n * returning the original Array of obj is an Array\n * else wrapping the obj in a single element Array\n */\nexport function ensureArray(obj: Record<string, unknown>): unknown[] {\n  if (isEmptyArg(obj)) {\n    return [];\n  }\n  if (isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\nexport function isObject(ob: unknown): ob is Record<string, unknown> {\n  return Object.prototype.toString.call(ob) == '[object Object]';\n}\n\n/*\n * Determine whether or not an object contains\n * any enumerable properties.\n * ob: the object\n */\nexport function isEmpty(ob: Record<string, unknown> | unknown[]): boolean {\n  for (const prop in ob) return false;\n  return true;\n}\n\n/*\n * Determine whether or not an argument to an overloaded function is\n * undefined (missing) or null.\n * This method is useful when constructing functions such as (WebIDL terminology):\n *   off([TreatUndefinedAs=Null] DOMString? event)\n * as you can then confirm the argument using:\n *   Utils.isEmptyArg(event)\n */\n\nexport function isEmptyArg(arg: unknown): arg is null | undefined {\n  return arg === null || arg === undefined;\n}\n\n/*\n * Perform a simple shallow clone of an object.\n * Result is an object irrespective of whether\n * the input is an object or array. All\n * enumerable properties are copied.\n * ob: the object\n */\nexport function shallowClone(ob: Record<string, unknown>): Record<string, unknown> {\n  const result = new Object() as Record<string, unknown>;\n  for (const prop in ob) result[prop] = ob[prop];\n  return result;\n}\n\n/*\n * Clone an object by creating a new object with the\n * given object as its prototype. Optionally\n * a set of additional own properties can be\n * supplied to be added to the newly created clone.\n * ob:            the object to be cloned\n * ownProperties: optional object with additional\n *                properties to add\n */\nexport function prototypicalClone(\n  ob: Record<string, unknown>,\n  ownProperties: Record<string, unknown>\n): Record<string, unknown> {\n  class F {}\n  F.prototype = ob;\n  const result = new F() as Record<string, unknown>;\n  if (ownProperties) mixin(result, ownProperties);\n  return result;\n}\n\n/*\n * Declare a constructor to represent a subclass\n * of another constructor\n * If platform has a built-in version we use that from Platform, else we\n * define here (so can make use of other Utils fns)\n * See node.js util.inherits\n */\nexport const inherits = function (ctor: any, superCtor: Function) {\n  if (Platform.Config.inherits) {\n    Platform.Config.inherits(ctor, superCtor);\n    return;\n  }\n  ctor.super_ = superCtor;\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\n};\n\n/*\n * Determine whether or not an object has an enumerable\n * property whose value equals a given value.\n * ob:  the object\n * val: the value to find\n */\nexport function containsValue(ob: Record<string, unknown>, val: unknown): boolean {\n  for (const i in ob) {\n    if (ob[i] == val) return true;\n  }\n  return false;\n}\n\nexport function intersect<T>(arr: Array<string>, ob: string[] | Record<string, T>): string[] {\n  return isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\n}\n\nexport function arrIntersect<T>(arr1: Array<T>, arr2: Array<T>): Array<T> {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const member = arr1[i];\n    if (arrIndexOf(arr2, member) != -1) result.push(member);\n  }\n  return result;\n}\n\nexport function arrIntersectOb(arr: Array<string>, ob: Record<string, unknown>): string[] {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const member = arr[i];\n    if (member in ob) result.push(member);\n  }\n  return result;\n}\n\nexport function arrSubtract<T>(arr1: Array<T>, arr2: Array<T>): Array<T> {\n  const result = [];\n  for (let i = 0; i < arr1.length; i++) {\n    const element = arr1[i];\n    if (arrIndexOf(arr2, element) == -1) result.push(element);\n  }\n  return result;\n}\n\nexport const arrIndexOf = (Array.prototype.indexOf as unknown)\n  ? function (arr: Array<unknown>, elem: unknown, fromIndex?: number) {\n      return arr.indexOf(elem, fromIndex);\n    }\n  : function (arr: Array<unknown>, elem: unknown, fromIndex?: number) {\n      fromIndex = fromIndex || 0;\n      const len = arr.length;\n      for (; fromIndex < len; fromIndex++) {\n        if (arr[fromIndex] === elem) {\n          return fromIndex;\n        }\n      }\n      return -1;\n    };\n\nexport function arrIn(arr: Array<unknown>, val: unknown): boolean {\n  return arrIndexOf(arr, val) !== -1;\n}\n\nexport function arrDeleteValue<T>(arr: Array<T>, val: T): boolean {\n  const idx = arrIndexOf(arr, val);\n  const res = idx != -1;\n  if (res) arr.splice(idx, 1);\n  return res;\n}\n\nexport function arrWithoutValue<T>(arr: Array<T>, val: T): Array<T> {\n  const newArr = arr.slice();\n  arrDeleteValue(newArr, val);\n  return newArr;\n}\n\n/*\n * Construct an array of the keys of the enumerable\n * properties of a given object, optionally limited\n * to only the own properties.\n * ob:      the object\n * ownOnly: boolean, get own properties only\n */\nexport function keysArray(ob: Record<string, unknown>, ownOnly?: boolean): Array<string> {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\n    result.push(prop);\n  }\n  return result;\n}\n\n/*\n * Construct an array of the values of the enumerable\n * properties of a given object, optionally limited\n * to only the own properties.\n * ob:      the object\n * ownOnly: boolean, get own properties only\n */\nexport function valuesArray<T>(ob: Record<string, T>, ownOnly?: boolean): T[] {\n  const result = [];\n  for (const prop in ob) {\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\n    result.push(ob[prop]);\n  }\n  return result;\n}\n\nexport function forInOwnNonNullProperties(ob: Record<string, unknown>, fn: (prop: string) => void): void {\n  for (const prop in ob) {\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\n      fn(prop);\n    }\n  }\n}\n\nexport const arrForEach = (Array.prototype.forEach as unknown)\n  ? function <T = unknown>(arr: Array<T>, fn: (value: T, index: number, arr: Array<T>) => unknown) {\n      arr.forEach(fn);\n    }\n  : function <T = unknown>(arr: Array<T>, fn: (value: T, index: number, arr: Array<T>) => unknown) {\n      const len = arr.length;\n      for (let i = 0; i < len; i++) {\n        fn(arr[i], i, arr);\n      }\n    };\n\n/* Useful when the function may mutate the array */\nexport function safeArrForEach<T = unknown>(\n  arr: Array<T>,\n  fn: (value: T, index: number, arr: Array<T>) => unknown\n): void {\n  return arrForEach(arr.slice(), fn);\n}\n\nexport const arrMap = (Array.prototype.map as unknown)\n  ? function <T1, T2>(arr: Array<T1>, fn: (value: T1, index?: number, arr?: Array<T1>) => T2) {\n      return arr.map(fn);\n    }\n  : function <T>(arr: Array<T>, fn: (value: T, index?: number, arr?: Array<T>) => unknown) {\n      const result = [];\n      const len = arr.length;\n      for (let i = 0; i < len; i++) {\n        result.push(fn(arr[i], i, arr));\n      }\n      return result;\n    };\n\nexport const arrFilter = (Array.prototype.filter as unknown)\n  ? function <T>(arr: Array<T>, fn: (value: T, index?: number, arr?: Array<T>) => boolean) {\n      return arr.filter(fn);\n    }\n  : function <T>(arr: Array<T>, fn: (value: T, index?: number, arr?: Array<T>) => boolean) {\n      const result = [],\n        len = arr.length;\n      for (let i = 0; i < len; i++) {\n        if (fn(arr[i])) {\n          result.push(arr[i]);\n        }\n      }\n      return result;\n    };\n\nexport const arrEvery = (Array.prototype.every as unknown)\n  ? function <T>(arr: Array<T>, fn: (value: T, index?: number, arr?: Array<T>) => boolean) {\n      return arr.every(fn);\n    }\n  : function <T>(arr: Array<T>, fn: (value: T, index?: number, arr?: Array<T>) => boolean) {\n      const len = arr.length;\n      for (let i = 0; i < len; i++) {\n        if (!fn(arr[i], i, arr)) {\n          return false;\n        }\n      }\n      return true;\n    };\n\nexport function allSame(arr: Array<Record<string, unknown>>, prop: string): boolean {\n  if (arr.length === 0) {\n    return true;\n  }\n  const first = arr[0][prop];\n  return arrEvery(arr, function (item) {\n    return item[prop] === first;\n  });\n}\n\nexport enum Format {\n  msgpack = 'msgpack',\n  json = 'json',\n}\n\nexport function arrPopRandomElement<T>(arr: Array<T>): T {\n  return arr.splice(randomPosn(arr), 1)[0];\n}\n\nexport function toQueryString(params?: Record<string, string> | null): string {\n  const parts = [];\n  if (params) {\n    for (const key in params) parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));\n  }\n  return parts.length ? '?' + parts.join('&') : '';\n}\n\nexport function parseQueryString(query: string): Record<string, string> {\n  let match;\n  const search = /([^?&=]+)=?([^&]*)/g;\n  const result: Record<string, string> = {};\n\n  while ((match = search.exec(query))) result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n\n  return result;\n}\n\nexport const now =\n  Date.now ||\n  function () {\n    /* IE 8 */\n    return new Date().getTime();\n  };\n\nexport function isErrorInfoOrPartialErrorInfo(err: unknown): err is ErrorInfo | PartialErrorInfo {\n  return typeof err == 'object' && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\n}\n\nexport function inspectError(err: unknown): string {\n  if (\n    err instanceof Error ||\n    (err as ErrorInfo)?.constructor?.name === 'ErrorInfo' ||\n    (err as PartialErrorInfo)?.constructor?.name === 'PartialErrorInfo'\n  )\n    return Platform.Config.inspect(err);\n  return (err as Error).toString();\n}\n\nexport function inspectBody(body: unknown): string {\n  if (Platform.BufferUtils.isBuffer(body)) {\n    return (body as any).toString();\n  } else if (typeof body === 'string') {\n    return body;\n  } else {\n    return Platform.Config.inspect(body);\n  }\n}\n\n/* Data is assumed to be either a string or a buffer. */\nexport function dataSizeBytes(data: string | Buffer): number {\n  if (Platform.BufferUtils.isBuffer(data)) {\n    return Platform.BufferUtils.byteLength(data);\n  }\n  if (typeof data === 'string') {\n    return Platform.Config.stringByteSize(data);\n  }\n  throw new Error('Expected input of Utils.dataSizeBytes to be a buffer or string, but was: ' + typeof data);\n}\n\nexport function cheapRandStr(): string {\n  return String(Math.random()).substr(2);\n}\n\n/* Takes param the minimum number of bytes of entropy the string must\n * include, not the length of the string. String length produced is not\n * guaranteed. */\nexport const randomString = (numBytes: number): string => {\n  if (Platform.Config.getRandomValues && typeof Uint8Array !== 'undefined') {\n    const uIntArr = new Uint8Array(numBytes);\n    (Platform.Config.getRandomValues as Function)(uIntArr);\n    return Platform.BufferUtils.base64Encode(uIntArr);\n  }\n  /* No secure random generator available; fall back to Math.random.\n   * TODO we should no longer end up in this scenario \u2014 and hence should be able to remove this code \u2014 given that all supported platforms should now have a random generator \u2014 see https://github.com/ably/ably-js/issues/1332\n   */\n  const charset = Platform.BufferUtils.base64CharSet;\n  /* base64 has 33% overhead; round length up */\n  const length = Math.round((numBytes * 4) / 3);\n  let result = '';\n  for (let i = 0; i < length; i++) {\n    result += charset[randomPosn(charset)];\n  }\n  return result;\n};\n\n/* Pick n elements at random without replacement from an array */\nexport function arrChooseN<T>(arr: Array<T>, n: number): Array<T> {\n  const numItems = Math.min(n, arr.length),\n    mutableArr = arr.slice(),\n    result: Array<T> = [];\n  for (let i = 0; i < numItems; i++) {\n    result.push(arrPopRandomElement(mutableArr));\n  }\n  return result;\n}\n\nexport const trim = (String.prototype.trim as unknown)\n  ? function (str: string) {\n      return str.trim();\n    }\n  : function (str: string) {\n      return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    };\n\nexport function promisify<T>(ob: Record<string, any>, fnName: string, args: IArguments | unknown[]): Promise<T> {\n  return new Promise(function (resolve, reject) {\n    ob[fnName](...(args as unknown[]), function (err: Error, res: unknown) {\n      err ? reject(err) : resolve(res as T);\n    });\n  });\n}\n\nexport function decodeBody<T>(body: unknown, format?: Format | null): T {\n  return format == 'msgpack' ? Platform.Config.msgpack.decode(body as Buffer) : JSON.parse(String(body));\n}\n\nexport function encodeBody(body: unknown, format?: Format): string | Buffer {\n  return format == 'msgpack' ? (Platform.Config.msgpack.encode(body, true) as Buffer) : JSON.stringify(body);\n}\n\nexport function allToLowerCase(arr: Array<string>): Array<string> {\n  return arr.map(function (element) {\n    return element && element.toLowerCase();\n  });\n}\n\nexport function allToUpperCase(arr: Array<string>): Array<string> {\n  return arr.map(function (element) {\n    return element && element.toUpperCase();\n  });\n}\n\nexport function getBackoffCoefficient(n: number) {\n  return Math.min((n + 2) / 3, 2);\n}\n\nexport function getJitterCoefficient() {\n  return 1 - Math.random() * 0.2;\n}\n\nexport function getGlobalObject() {\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  return self;\n}\n\nexport function shallowEquals(source: Record<string, unknown>, target: Record<string, unknown>) {\n  return (\n    Object.keys(source).every((key) => source[key] === target[key]) &&\n    Object.keys(target).every((key) => target[key] === source[key])\n  );\n}\n\nexport function matchDerivedChannel(name: string) {\n  /**\n   * This regex check is to retain existing channel params if any e.g [?rewind=1]foo to\n   * [filter=xyz?rewind=1]foo. This is to keep channel compatibility around use of\n   * channel params that work with derived channels.\n   *\n   * This eslint unsafe regex warning is triggered because the RegExp uses nested quantifiers,\n   * but it does not create any situation where the regex engine has to\n   * explore a large number of possible matches so it\u2019s safe to ignore\n   */\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/; // eslint-disable-line\n  const match = name.match(regex);\n  if (!match || !match.length || match.length < 5) {\n    throw new ErrorInfo('regex match failed', 400, 40010);\n  }\n  // Fail if there is already a channel qualifier, eg [meta]foo should fail instead of just overriding with [filter=xyz]foo\n  if (match![2]) {\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\n  }\n  // Return match values to be added to derive channel quantifier.\n  return {\n    qualifierParam: match[3] || '',\n    channelName: match[4],\n  };\n}\n\nexport function toBase64(str: string) {\n  const bufferUtils = Platform.BufferUtils;\n  const textBuffer = bufferUtils.utf8Encode(str);\n  return bufferUtils.base64Encode(textBuffer);\n}\n\nexport function isRealtime(client: BaseClient): client is Realtime {\n  return !!(client as Realtime).connection;\n}\n", "{\n  \"name\": \"ably\",\n  \"description\": \"Realtime client library for Ably, the realtime messaging service\",\n  \"version\": \"1.2.40\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ably/ably-js/issues\",\n    \"email\": \"support@ably.com\"\n  },\n  \"main\": \"./build/ably-node.js\",\n  \"typings\": \"./ably.d.ts\",\n  \"react-native\": {\n    \"./build/ably-node.js\": \"./build/ably-reactnative.js\"\n  },\n  \"browser\": {\n    \"./build/ably-node.js\": \"./build/ably.js\"\n  },\n  \"files\": [\n    \"build/**\",\n    \"ably.d.ts\",\n    \"resources/**\"\n  ],\n  \"dependencies\": {\n    \"@ably/msgpack-js\": \"^0.4.0\",\n    \"got\": \"^11.8.5\",\n    \"ws\": \"^5.1\"\n  },\n  \"devDependencies\": {\n    \"@ably/vcdiff-decoder\": \"1.0.4\",\n    \"@types/node\": \"^18.0.0\",\n    \"@types/request\": \"^2.48.7\",\n    \"@types/ws\": \"^8.2.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.14.0\",\n    \"@typescript-eslint/parser\": \"^5.14.0\",\n    \"async\": \"ably-forks/async#requirejs\",\n    \"aws-sdk\": \"^2.1075.0\",\n    \"chai\": \"^4.2.0\",\n    \"copy-webpack-plugin\": \"^11.0.0\",\n    \"cors\": \"~2.7\",\n    \"esbuild\": \"^0.18.10\",\n    \"esbuild-plugin-umd-wrapper\": \"^1.0.7\",\n    \"eslint\": \"^7.13.0\",\n    \"eslint-plugin-jsdoc\": \"^40.0.0\",\n    \"eslint-plugin-security\": \"^1.4.0\",\n    \"express\": \"^4.17.1\",\n    \"glob\": \"~4.4\",\n    \"grunt\": \"^1.4.1\",\n    \"grunt-bump\": \"^0.3.1\",\n    \"grunt-cli\": \"~1.2.0\",\n    \"grunt-contrib-concat\": \"~0.5\",\n    \"grunt-shell\": \"~1.1\",\n    \"grunt-webpack\": \"^5.0.0\",\n    \"hexy\": \"~0.2\",\n    \"kexec\": \"ably-forks/node-kexec#update-for-node-12\",\n    \"minimist\": \"^1.2.5\",\n    \"mocha\": \"^8.1.3\",\n    \"playwright\": \"^1.10.0\",\n    \"prettier\": \"^2.8.8\",\n    \"requirejs\": \"~2.1\",\n    \"shelljs\": \"~0.8\",\n    \"source-map-explorer\": \"^2.5.2\",\n    \"ts-loader\": \"^9.4.2\",\n    \"tsconfig-paths-webpack-plugin\": \"^4.0.1\",\n    \"tslib\": \"^2.3.1\",\n    \"typedoc\": \"^0.24.7\",\n    \"typescript\": \"^4.9.5\",\n    \"webpack\": \"^5.79.0\",\n    \"webpack-cli\": \"^5.0.1\"\n  },\n  \"engines\": {\n    \"node\": \">=5.10.x\"\n  },\n  \"repository\": \"ably/ably-js\",\n  \"jspm\": {\n    \"registry\": \"npm\",\n    \"directories\": {\n      \"lib\": \"build\"\n    },\n    \"main\": \"ably\"\n  },\n  \"scripts\": {\n    \"grunt\": \"grunt\",\n    \"test\": \"grunt test\",\n    \"test:node\": \"grunt test:node\",\n    \"test:webserver\": \"grunt test:webserver\",\n    \"test:playwright\": \"node test/support/runPlaywrightTests.js\",\n    \"concat\": \"grunt concat\",\n    \"build\": \"grunt build:all\",\n    \"build:node\": \"grunt build:node\",\n    \"build:browser\": \"grunt build:browser\",\n    \"requirejs\": \"grunt requirejs\",\n    \"lint\": \"eslint .\",\n    \"lint:fix\": \"eslint --fix .\",\n    \"prepare\": \"npm run build\",\n    \"format\": \"prettier --write --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts webpack.config.js Gruntfile.js scripts/cdn_deploy.js docs/chrome-mv3.md\",\n    \"format:check\": \"prettier --check --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts webpack.config.js Gruntfile.js scripts/cdn_deploy.js\",\n    \"sourcemap\": \"source-map-explorer build/ably.min.js\",\n    \"sourcemap:noencryption\": \"source-map-explorer build/ably.noencryption.min.js\",\n    \"modulereport\": \"node scripts/moduleReport.js\",\n    \"docs\": \"typedoc --entryPoints ably.d.ts --out docs/generated --readme docs/landing-page.md\"\n  }\n}\n", "import Platform from 'common/platform';\nimport * as Utils from './utils';\nimport Logger from './logger';\nimport ErrorInfo from 'common/lib/types/errorinfo';\nimport { version } from '../../../../package.json';\nimport ClientOptions, { InternalClientOptions, NormalisedClientOptions } from 'common/types/ClientOptions';\nimport IDefaults from '../../types/IDefaults';\n\nlet agent = 'ably-js/' + version;\n\ntype CompleteDefaults = IDefaults & {\n  ENVIRONMENT: string;\n  REST_HOST: string;\n  REALTIME_HOST: string;\n  FALLBACK_HOSTS: string[];\n  PORT: number;\n  TLS_PORT: number;\n  TIMEOUTS: {\n    disconnectedRetryTimeout: number;\n    suspendedRetryTimeout: number;\n    httpRequestTimeout: number;\n    channelRetryTimeout: number;\n    fallbackRetryTimeout: number;\n    connectionStateTtl: number;\n    realtimeRequestTimeout: number;\n    recvTimeout: number;\n    preferenceConnectTimeout: number;\n    parallelUpgradeDelay: number;\n  };\n  httpMaxRetryCount: number;\n  maxMessageSize: number;\n  version: string;\n  protocolVersion: number;\n  agent: string;\n  getHost(options: ClientOptions, host?: string | null, ws?: boolean): string;\n  getPort(options: ClientOptions, tls?: boolean): number | undefined;\n  getHttpScheme(options: ClientOptions): string;\n  environmentFallbackHosts(environment: string): string[];\n  getFallbackHosts(options: NormalisedClientOptions): string[];\n  getHosts(options: NormalisedClientOptions): string[];\n  checkHost(host: string): void;\n  getRealtimeHost(options: ClientOptions, production: boolean, environment: string): string;\n  objectifyOptions(options: ClientOptions | string): ClientOptions;\n  normaliseOptions(options: InternalClientOptions): NormalisedClientOptions;\n  defaultGetHeaders(options: NormalisedClientOptions, headersOptions?: HeadersOptions): Record<string, string>;\n  defaultPostHeaders(options: NormalisedClientOptions, headersOptions?: HeadersOptions): Record<string, string>;\n};\n\nconst Defaults = {\n  ENVIRONMENT: '',\n  REST_HOST: 'rest.ably.io',\n  REALTIME_HOST: 'realtime.ably.io',\n  FALLBACK_HOSTS: [\n    'A.ably-realtime.com',\n    'B.ably-realtime.com',\n    'C.ably-realtime.com',\n    'D.ably-realtime.com',\n    'E.ably-realtime.com',\n  ],\n  PORT: 80,\n  TLS_PORT: 443,\n  TIMEOUTS: {\n    /* Documented as options params: */\n    disconnectedRetryTimeout: 15000,\n    suspendedRetryTimeout: 30000,\n    /* Undocumented, but part of the api and can be used by customers: */\n    httpRequestTimeout: 15000,\n    channelRetryTimeout: 15000,\n    fallbackRetryTimeout: 600000,\n    /* For internal / test use only: */\n    connectionStateTtl: 120000,\n    realtimeRequestTimeout: 10000,\n    recvTimeout: 90000,\n    preferenceConnectTimeout: 6000,\n    parallelUpgradeDelay: 6000,\n  },\n  httpMaxRetryCount: 3,\n  maxMessageSize: 65536,\n\n  version,\n  protocolVersion: 2,\n  agent,\n  getHost,\n  getPort,\n  getHttpScheme,\n  environmentFallbackHosts,\n  getFallbackHosts,\n  getHosts,\n  checkHost,\n  objectifyOptions,\n  normaliseOptions,\n  defaultGetHeaders,\n  defaultPostHeaders,\n};\n\nexport function getHost(options: ClientOptions, host?: string | null, ws?: boolean): string {\n  if (ws) host = (host == options.restHost && options.realtimeHost) || host || options.realtimeHost;\n  else host = host || options.restHost;\n\n  return host as string;\n}\n\nexport function getPort(options: ClientOptions, tls?: boolean): number | undefined {\n  return tls || options.tls ? options.tlsPort : options.port;\n}\n\nexport function getHttpScheme(options: ClientOptions): string {\n  return options.tls ? 'https://' : 'http://';\n}\n\n// construct environment fallback hosts as per RSC15i\nexport function environmentFallbackHosts(environment: string): string[] {\n  return [\n    environment + '-a-fallback.ably-realtime.com',\n    environment + '-b-fallback.ably-realtime.com',\n    environment + '-c-fallback.ably-realtime.com',\n    environment + '-d-fallback.ably-realtime.com',\n    environment + '-e-fallback.ably-realtime.com',\n  ];\n}\n\nexport function getFallbackHosts(options: NormalisedClientOptions): string[] {\n  const fallbackHosts = options.fallbackHosts,\n    httpMaxRetryCount =\n      typeof options.httpMaxRetryCount !== 'undefined' ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\n\n  return fallbackHosts ? Utils.arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\n}\n\nexport function getHosts(options: NormalisedClientOptions): string[] {\n  return [options.restHost].concat(getFallbackHosts(options));\n}\n\nfunction checkHost(host: string): void {\n  if (typeof host !== 'string') {\n    throw new ErrorInfo('host must be a string; was a ' + typeof host, 40000, 400);\n  }\n  if (!host.length) {\n    throw new ErrorInfo('host must not be zero-length', 40000, 400);\n  }\n}\n\nfunction getRealtimeHost(options: ClientOptions, production: boolean, environment: string): string {\n  if (options.realtimeHost) return options.realtimeHost;\n  /* prefer setting realtimeHost to restHost as a custom restHost typically indicates\n   * a development environment is being used that can't be inferred by the library */\n  if (options.restHost) {\n    Logger.logAction(\n      Logger.LOG_MINOR,\n      'Defaults.normaliseOptions',\n      'restHost is set to \"' +\n        options.restHost +\n        '\" but realtimeHost is not set, so setting realtimeHost to \"' +\n        options.restHost +\n        '\" too. If this is not what you want, please set realtimeHost explicitly.'\n    );\n    return options.restHost;\n  }\n  return production ? Defaults.REALTIME_HOST : environment + '-' + Defaults.REALTIME_HOST;\n}\n\nfunction getTimeouts(options: ClientOptions) {\n  /* Allow values passed in options to override default timeouts */\n  const timeouts: Record<string, number> = {};\n  for (const prop in Defaults.TIMEOUTS) {\n    timeouts[prop] = (options as Record<string, number>)[prop] || (Defaults.TIMEOUTS as Record<string, number>)[prop];\n  }\n  return timeouts;\n}\n\nexport function getAgentString(options: ClientOptions): string {\n  let agentStr = Defaults.agent;\n  if (options.agents) {\n    for (var agent in options.agents) {\n      agentStr += ' ' + agent + '/' + options.agents[agent];\n    }\n  }\n  return agentStr;\n}\n\nexport function objectifyOptions(options: ClientOptions | string): ClientOptions {\n  if (typeof options == 'string') {\n    return options.indexOf(':') == -1 ? { token: options } : { key: options };\n  }\n  return options;\n}\n\nexport function normaliseOptions(options: InternalClientOptions): NormalisedClientOptions {\n  if (typeof options.recover === 'function' && options.closeOnUnload === true) {\n    Logger.logAction(\n      Logger.LOG_ERROR,\n      'Defaults.normaliseOptions',\n      'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter'\n    );\n    options.recover = undefined;\n  }\n\n  if (!('closeOnUnload' in options)) {\n    /* Have closeOnUnload default to true unless we have any indication that\n     * the user may want to recover the connection */\n    options.closeOnUnload = !options.recover;\n  }\n\n  if (!('queueMessages' in options)) options.queueMessages = true;\n\n  /* infer hosts and fallbacks based on the configured environment */\n  const environment = (options.environment && String(options.environment).toLowerCase()) || Defaults.ENVIRONMENT;\n  const production = !environment || environment === 'production';\n\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\n    options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);\n  }\n\n  const restHost = options.restHost || (production ? Defaults.REST_HOST : environment + '-' + Defaults.REST_HOST);\n  const realtimeHost = getRealtimeHost(options, production, environment);\n\n  Utils.arrForEach((options.fallbackHosts || []).concat(restHost, realtimeHost), checkHost);\n\n  options.port = options.port || Defaults.PORT;\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\n  if (!('tls' in options)) options.tls = true;\n\n  const timeouts = getTimeouts(options);\n\n  if ('useBinaryProtocol' in options) {\n    options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\n  } else {\n    options.useBinaryProtocol = Platform.Config.preferBinary;\n  }\n\n  const headers: Record<string, string> = {};\n  if (options.clientId) {\n    headers['X-Ably-ClientId'] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\n  }\n\n  if (!('idempotentRestPublishing' in options)) {\n    options.idempotentRestPublishing = true;\n  }\n\n  let connectivityCheckParams = null;\n  let connectivityCheckUrl = options.connectivityCheckUrl;\n  if (options.connectivityCheckUrl) {\n    let [uri, qs] = options.connectivityCheckUrl.split('?');\n    connectivityCheckParams = qs ? Utils.parseQueryString(qs) : {};\n    if (uri.indexOf('://') === -1) {\n      uri = 'https://' + uri;\n    }\n    connectivityCheckUrl = uri;\n  }\n\n  return {\n    ...options,\n    useBinaryProtocol:\n      'useBinaryProtocol' in options\n        ? Platform.Config.supportsBinary && options.useBinaryProtocol\n        : Platform.Config.preferBinary,\n    realtimeHost,\n    restHost,\n    maxMessageSize: options.internal?.maxMessageSize || Defaults.maxMessageSize,\n    timeouts,\n    connectivityCheckParams,\n    connectivityCheckUrl,\n    headers,\n  };\n}\n\nconst contentTypes = {\n  json: 'application/json',\n  xml: 'application/xml',\n  html: 'text/html',\n  msgpack: 'application/x-msgpack',\n};\n\nexport interface HeadersOptions {\n  format?: Utils.Format;\n  protocolVersion?: number;\n}\n\nconst defaultHeadersOptions: Required<HeadersOptions> = {\n  format: Utils.Format.json,\n  protocolVersion: Defaults.protocolVersion,\n};\n\nexport function defaultGetHeaders(\n  options: NormalisedClientOptions,\n  {\n    format = defaultHeadersOptions.format,\n    protocolVersion = defaultHeadersOptions.protocolVersion,\n  }: HeadersOptions = {}\n): Record<string, string> {\n  const accept = contentTypes[format];\n  return {\n    accept: accept,\n    'X-Ably-Version': protocolVersion.toString(),\n    'Ably-Agent': getAgentString(options),\n  };\n}\n\nexport function defaultPostHeaders(\n  options: NormalisedClientOptions,\n  {\n    format = defaultHeadersOptions.format,\n    protocolVersion = defaultHeadersOptions.protocolVersion,\n  }: HeadersOptions = {}\n): Record<string, string> {\n  let contentType;\n  const accept = (contentType = contentTypes[format]);\n\n  return {\n    accept: accept,\n    'content-type': contentType,\n    'X-Ably-Version': protocolVersion.toString(),\n    'Ably-Agent': getAgentString(options),\n  };\n}\n\nexport default Defaults as CompleteDefaults;\n\nexport function getDefaults(platformDefaults: IDefaults) {\n  return Object.assign(Defaults, platformDefaults);\n}\n", "import Logger from './logger';\n\ntype AnyFunction = (...args: any[]) => unknown;\n\nexport interface MulticasterInstance extends Function {\n  (...args: unknown[]): void;\n  push: (fn: AnyFunction) => void;\n}\n\nclass Multicaster {\n  members: Array<AnyFunction>;\n\n  // Private constructor; use static Multicaster.create instead\n  private constructor(members?: Array<AnyFunction | undefined>) {\n    this.members = (members as Array<AnyFunction>) || [];\n  }\n\n  call(...args: unknown[]): void {\n    for (const member of this.members) {\n      if (member) {\n        try {\n          member(...args);\n        } catch (e) {\n          Logger.logAction(\n            Logger.LOG_ERROR,\n            'Multicaster multiple callback handler',\n            'Unexpected exception: ' + e + '; stack = ' + (e as Error).stack\n          );\n        }\n      }\n    }\n  }\n\n  push(...args: Array<AnyFunction>): void {\n    this.members.push(...args);\n  }\n\n  static create(members?: Array<AnyFunction | undefined>): MulticasterInstance {\n    const instance = new Multicaster(members);\n    return Object.assign((...args: unknown[]) => instance.call(...args), {\n      push: (fn: AnyFunction) => instance.push(fn),\n    });\n  }\n}\n\nexport default Multicaster;\n", "enum HttpMethods {\n  Get = 'get',\n  Delete = 'delete',\n  Post = 'post',\n  Put = 'put',\n  Patch = 'patch',\n}\n\nexport default HttpMethods;\n", "import Logger from '../util/logger';\nimport * as Utils from '../util/utils';\nimport Multicaster from '../util/multicaster';\nimport ErrorInfo, { IPartialErrorInfo } from '../types/errorinfo';\nimport { ErrnoException, RequestCallback, RequestParams } from '../../types/http';\nimport * as API from '../../../../ably';\nimport { StandardCallback } from '../../types/utils';\nimport ClientOptions from '../../types/ClientOptions';\nimport HttpMethods from '../../constants/HttpMethods';\nimport Platform from '../../platform';\nimport { BaseClient } from './baseclient';\nimport Defaults from '../util/defaults';\n\nconst MAX_TOKEN_LENGTH = Math.pow(2, 17);\nfunction noop() {}\nfunction random() {\n  return ('000000' + Math.floor(Math.random() * 1e16)).slice(-16);\n}\n\n/* A client auth callback may give errors in any number of formats; normalise to an ErrorInfo or PartialErrorInfo */\nfunction normaliseAuthcallbackError(err: any) {\n  if (!Utils.isErrorInfoOrPartialErrorInfo(err)) {\n    return new ErrorInfo(Utils.inspectError(err), err.code || 40170, err.statusCode || 401);\n  }\n  /* network errors will not have an inherent error code */\n  if (!err.code) {\n    if (err.statusCode === 403) {\n      err.code = 40300;\n    } else {\n      err.code = 40170;\n      /* normalise statusCode to 401 per RSA4e */\n      err.statusCode = 401;\n    }\n  }\n  return err;\n}\n\nlet hmac = (text: string, key: string): string => {\n  const bufferUtils = Platform.BufferUtils;\n\n  const textBuffer = bufferUtils.utf8Encode(text);\n  const keyBuffer = bufferUtils.utf8Encode(key);\n\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\n\n  return bufferUtils.base64Encode(digest);\n};\n\nfunction c14n(capability?: string | Record<string, Array<string>>) {\n  if (!capability) return '';\n\n  if (typeof capability == 'string') capability = JSON.parse(capability);\n\n  const c14nCapability: Record<string, Array<string>> = Object.create(null);\n  const keys = Utils.keysArray(capability as Record<string, Array<string>>, true);\n  if (!keys) return '';\n  keys.sort();\n  for (let i = 0; i < keys.length; i++) {\n    c14nCapability[keys[i]] = (capability as Record<string, Array<string>>)[keys[i]].sort();\n  }\n  return JSON.stringify(c14nCapability);\n}\n\nfunction logAndValidateTokenAuthMethod(authOptions: API.Types.AuthOptions) {\n  if (authOptions.authCallback) {\n    Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with authCallback');\n  } else if (authOptions.authUrl) {\n    Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with authUrl');\n  } else if (authOptions.key) {\n    Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with client-side signing');\n  } else if (authOptions.tokenDetails) {\n    Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with supplied token only');\n  } else {\n    const msg = 'authOptions must include valid authentication parameters';\n    Logger.logAction(Logger.LOG_ERROR, 'Auth()', msg);\n    throw new Error(msg);\n  }\n}\n\nfunction basicAuthForced(options: ClientOptions) {\n  return 'useTokenAuth' in options && !options.useTokenAuth;\n}\n\n/* RSA4 */\nfunction useTokenAuth(options: ClientOptions) {\n  return (\n    options.useTokenAuth ||\n    (!basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails))\n  );\n}\n\n/* RSA4a */\nfunction noWayToRenew(options: ClientOptions) {\n  return !options.key && !options.authCallback && !options.authUrl;\n}\n\nlet trId = 0;\nfunction getTokenRequestId() {\n  return trId++;\n}\n\nclass Auth {\n  client: BaseClient;\n  tokenParams: API.Types.TokenParams;\n  currentTokenRequestId: number | null;\n  waitingForTokenRequest: ReturnType<typeof Multicaster.create> | null;\n  // This initialization is always overwritten and only used to prevent a TypeScript compiler error\n  authOptions: API.Types.AuthOptions = {} as API.Types.AuthOptions;\n  tokenDetails?: API.Types.TokenDetails | null;\n  method?: string;\n  key?: string;\n  basicKey?: string;\n  clientId?: string | null;\n\n  constructor(client: BaseClient, options: ClientOptions) {\n    this.client = client;\n    this.tokenParams = options.defaultTokenParams || {};\n    /* The id of the current token request if one is in progress, else null */\n    this.currentTokenRequestId = null;\n    this.waitingForTokenRequest = null;\n\n    if (useTokenAuth(options)) {\n      /* Token auth */\n      if (noWayToRenew(options)) {\n        Logger.logAction(\n          Logger.LOG_ERROR,\n          'Auth()',\n          'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help'\n        );\n      }\n      this._saveTokenOptions(options.defaultTokenParams as API.Types.TokenDetails, options);\n      logAndValidateTokenAuthMethod(this.authOptions);\n    } else {\n      /* Basic auth */\n      if (!options.key) {\n        const msg =\n          'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';\n        Logger.logAction(Logger.LOG_ERROR, 'Auth()', msg);\n        throw new ErrorInfo(msg, 40160, 401);\n      }\n      Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'anonymous, using basic auth');\n      this._saveBasicOptions(options);\n    }\n  }\n\n  /**\n   * Instructs the library to get a token immediately and ensures Token Auth\n   * is used for all future requests, storing the tokenParams and authOptions\n   * given as the new defaults for subsequent use.\n   *\n   * @param callback (err, tokenDetails)\n   */\n  authorize(callback: Function): void;\n\n  /**\n   * Instructs the library to get a token immediately and ensures Token Auth\n   * is used for all future requests, storing the tokenParams and authOptions\n   * given as the new defaults for subsequent use.\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   *\n   * - ttl:        (optional) the requested life of any new token in ms. If none\n   *               is specified a default of 1 hour is provided. The maximum lifetime\n   *               is 24hours; any request exceeding that lifetime will be rejected\n   *               with an error.\n   *\n   * - capability: (optional) the capability to associate with the access token.\n   *               If none is specified, a token will be requested with all of the\n   *               capabilities of the specified key.\n   *\n   * - clientId:   (optional) a client ID to associate with the token\n   *\n   * - timestamp:  (optional) the time in ms since the epoch. If none is specified,\n   *               the system will be queried for a time value to use.\n   *\n   * @param callback (err, tokenDetails)\n   */\n  authorize(tokenParams: API.Types.TokenParams | null, callback: Function): void;\n\n  /**\n   * Instructs the library to get a token immediately and ensures Token Auth\n   * is used for all future requests, storing the tokenParams and authOptions\n   * given as the new defaults for subsequent use.\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   *\n   * - ttl:        (optional) the requested life of any new token in ms. If none\n   *               is specified a default of 1 hour is provided. The maximum lifetime\n   *               is 24hours; any request exceeding that lifetime will be rejected\n   *               with an error.\n   *\n   * - capability: (optional) the capability to associate with the access token.\n   *               If none is specified, a token will be requested with all of the\n   *               capabilities of the specified key.\n   *\n   * - clientId:   (optional) a client ID to associate with the token\n   *\n   * - timestamp:  (optional) the time in ms since the epoch. If none is specified,\n   *               the system will be queried for a time value to use.\n   *\n   * @param authOptions\n   * an object containing auth options relevant to token auth:\n   *\n   * - queryTime   (optional) boolean indicating that the Ably system should be\n   *               queried for the current time when none is specified explicitly.\n   *\n   * - tokenDetails: (optional) object: An authenticated TokenDetails object.\n   *\n   * - token:        (optional) string: the `token` property of a tokenDetails object\n   *\n   * - authCallback:  (optional) a JavaScript callback to be called to get auth information.\n   *                  authCallback should be a function of (tokenParams, callback) that calls\n   *                  the callback with (err, result), where result is any of:\n   *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),\n   *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),\n   *                  - a token string\n   *\n   * - authUrl:       (optional) a URL to be used to GET or POST a set of token request\n   *                  params, to obtain a signed token request.\n   *\n   * - authHeaders:   (optional) a set of application-specific headers to be added to any request\n   *                  made to the authUrl.\n   *\n   * - authParams:    (optional) a set of application-specific query params to be added to any\n   *                  request made to the authUrl.\n   *\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   *\n   * @param callback (err, tokenDetails)\n   */\n  authorize(\n    tokenParams: API.Types.TokenParams | null,\n    authOptions: API.Types.AuthOptions | null,\n    callback: Function\n  ): void;\n\n  authorize(\n    tokenParams: Record<string, any> | Function | null,\n    authOptions?: API.Types.AuthOptions | null | Function,\n    callback?: Function\n  ): void | Promise<void> {\n    let _authOptions: API.Types.AuthOptions | null;\n    /* shuffle and normalise arguments as necessary */\n    if (typeof tokenParams == 'function' && !callback) {\n      callback = tokenParams;\n      _authOptions = tokenParams = null;\n    } else if (typeof authOptions == 'function' && !callback) {\n      callback = authOptions;\n      _authOptions = null;\n    } else {\n      _authOptions = authOptions as API.Types.AuthOptions;\n    }\n    if (!callback) {\n      return Utils.promisify(this, 'authorize', arguments);\n    }\n\n    /* RSA10a: authorize() call implies token auth. If a key is passed it, we\n     * just check if it doesn't clash and assume we're generating a token from it */\n    if (_authOptions && _authOptions.key && this.authOptions.key !== _authOptions.key) {\n      throw new ErrorInfo('Unable to update auth options with incompatible key', 40102, 401);\n    }\n\n    this._forceNewToken(\n      tokenParams as API.Types.TokenParams,\n      _authOptions,\n      (err: ErrorInfo, tokenDetails: API.Types.TokenDetails) => {\n        if (err) {\n          if (Utils.isRealtime(this.client)) {\n            /* We interpret RSA4d as including requests made by a client lib to\n             * authenticate triggered by an explicit authorize() or an AUTH received from\n             * ably, not just connect-sequence-triggered token fetches */\n            this.client.connection.connectionManager.actOnErrorFromAuthorize(err);\n          }\n          callback?.(err);\n          return;\n        }\n\n        /* RTC8\n         * - When authorize called by an end user and have a realtime connection,\n         * don't call back till new token has taken effect.\n         * - Use this.client.connection as a proxy for (this.client instanceof Realtime),\n         * which doesn't work in node as Realtime isn't part of the vm context for Rest clients */\n        if (Utils.isRealtime(this.client)) {\n          this.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback || noop);\n        } else {\n          callback?.(null, tokenDetails);\n        }\n      }\n    );\n  }\n\n  /* For internal use, eg by connectionManager - useful when want to call back\n   * as soon as we have the new token, rather than waiting for it to take\n   * effect on the connection as #authorize does */\n  _forceNewToken(\n    tokenParams: API.Types.TokenParams | null,\n    authOptions: API.Types.AuthOptions | null,\n    callback: Function\n  ) {\n    /* get rid of current token even if still valid */\n    this.tokenDetails = null;\n\n    /* _save normalises the tokenParams and authOptions and updates the auth\n     * object. All subsequent operations should use the values on `this`,\n     * not the passed in ones. */\n    this._saveTokenOptions(tokenParams, authOptions);\n\n    logAndValidateTokenAuthMethod(this.authOptions);\n\n    this._ensureValidAuthCredentials(true, (err: ErrorInfo | null, tokenDetails?: API.Types.TokenDetails) => {\n      /* RSA10g */\n      delete this.tokenParams.timestamp;\n      delete this.authOptions.queryTime;\n      callback(err, tokenDetails);\n    });\n  }\n\n  /**\n   * Request an access token\n   * @param callback (err, tokenDetails)\n   */\n  requestToken(callback: StandardCallback<API.Types.TokenDetails>): void;\n\n  /**\n   * Request an access token\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   *\n   * @param callback (err, tokenDetails)\n   */\n  requestToken(tokenParams: API.Types.TokenParams | null, callback: StandardCallback<API.Types.TokenDetails>): void;\n\n  /**\n   * Request an access token\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use.\n   *\n   * - authCallback:  (optional) a JavaScript callback to be called to get auth information.\n   *                  authCallback should be a function of (tokenParams, callback) that calls\n   *                  the callback with (err, result), where result is any of:\n   *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),\n   *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),\n   *                  - a token string\n   *\n   * - authUrl:       (optional) a URL to be used to GET or POST a set of token request\n   *                  params, to obtain a signed token request.\n   *\n   * - authHeaders:   (optional) a set of application-specific headers to be added to any request\n   *                  made to the authUrl.\n   *\n   * - authParams:    (optional) a set of application-specific query params to be added to any\n   *                  request made to the authUrl.\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   *\n   * @param callback (err, tokenDetails)\n   */\n  requestToken(\n    tokenParams: API.Types.TokenParams | null,\n    authOptions: API.Types.AuthOptions,\n    callback: StandardCallback<API.Types.TokenDetails>\n  ): void;\n\n  requestToken(\n    tokenParams: API.Types.TokenParams | StandardCallback<API.Types.TokenDetails> | null,\n    authOptions?: any | StandardCallback<API.Types.TokenDetails>,\n    callback?: StandardCallback<API.Types.TokenDetails>\n  ): void | Promise<void> {\n    /* shuffle and normalise arguments as necessary */\n    if (typeof tokenParams == 'function' && !callback) {\n      callback = tokenParams;\n      authOptions = tokenParams = null;\n    } else if (typeof authOptions == 'function' && !callback) {\n      callback = authOptions;\n      authOptions = null;\n    }\n    if (!callback) {\n      return Utils.promisify(this, 'requestToken', arguments);\n    }\n\n    /* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */\n    authOptions = authOptions || this.authOptions;\n    tokenParams = tokenParams || Utils.copy(this.tokenParams);\n    const _callback = callback || noop;\n\n    /* first set up whatever callback will be used to get signed\n     * token requests */\n    let tokenRequestCallback,\n      client = this.client;\n\n    if (authOptions.authCallback) {\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');\n      tokenRequestCallback = authOptions.authCallback;\n    } else if (authOptions.authUrl) {\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');\n      tokenRequestCallback = (params: Record<string, unknown>, cb: Function) => {\n        const authHeaders = Utils.mixin({ accept: 'application/json, text/plain' }, authOptions.authHeaders) as Record<\n          string,\n          string\n        >;\n        const usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === 'post';\n        let providedQsParams;\n        /* Combine authParams with any qs params given in the authUrl */\n        const queryIdx = authOptions.authUrl.indexOf('?');\n        if (queryIdx > -1) {\n          providedQsParams = Utils.parseQueryString(authOptions.authUrl.slice(queryIdx));\n          authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);\n          if (!usePost) {\n            /* In case of conflict, authParams take precedence over qs params in the authUrl */\n            authOptions.authParams = Utils.mixin(providedQsParams, authOptions.authParams);\n          }\n        }\n        /* RSA8c2 */\n        const authParams = Utils.mixin({}, authOptions.authParams || {}, params) as RequestParams;\n        const authUrlRequestCallback = function (\n          err: ErrorInfo,\n          body: string,\n          headers: Record<string, string>,\n          unpacked: any\n        ) {\n          let contentType;\n          if (err) {\n            Logger.logAction(\n              Logger.LOG_MICRO,\n              'Auth.requestToken().tokenRequestCallback',\n              'Received Error: ' + Utils.inspectError(err)\n            );\n          } else {\n            contentType = headers['content-type'];\n            Logger.logAction(\n              Logger.LOG_MICRO,\n              'Auth.requestToken().tokenRequestCallback',\n              'Received; content-type: ' + contentType + '; body: ' + Utils.inspectBody(body)\n            );\n          }\n          if (err || unpacked) return cb(err, body);\n          if (Platform.BufferUtils.isBuffer(body)) body = body.toString();\n          if (!contentType) {\n            cb(new ErrorInfo('authUrl response is missing a content-type header', 40170, 401));\n            return;\n          }\n          const json = contentType.indexOf('application/json') > -1,\n            text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;\n          if (!json && !text) {\n            cb(\n              new ErrorInfo(\n                'authUrl responded with unacceptable content-type ' +\n                  contentType +\n                  ', should be either text/plain, application/jwt or application/json',\n                40170,\n                401\n              )\n            );\n            return;\n          }\n          if (json) {\n            if (body.length > MAX_TOKEN_LENGTH) {\n              cb(new ErrorInfo('authUrl response exceeded max permitted length', 40170, 401));\n              return;\n            }\n            try {\n              body = JSON.parse(body);\n            } catch (e) {\n              cb(\n                new ErrorInfo('Unexpected error processing authURL response; err = ' + (e as Error).message, 40170, 401)\n              );\n              return;\n            }\n          }\n          cb(null, body, contentType);\n        };\n        Logger.logAction(\n          Logger.LOG_MICRO,\n          'Auth.requestToken().tokenRequestCallback',\n          'Requesting token from ' +\n            authOptions.authUrl +\n            '; Params: ' +\n            JSON.stringify(authParams) +\n            '; method: ' +\n            (usePost ? 'POST' : 'GET')\n        );\n        if (usePost) {\n          /* send body form-encoded */\n          const headers = authHeaders || {};\n          headers['content-type'] = 'application/x-www-form-urlencoded';\n          const body = Utils.toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */\n          this.client.http.doUri(\n            HttpMethods.Post,\n            client,\n            authOptions.authUrl,\n            headers,\n            body,\n            providedQsParams as Record<string, string>,\n            authUrlRequestCallback as RequestCallback\n          );\n        } else {\n          this.client.http.doUri(\n            HttpMethods.Get,\n            client,\n            authOptions.authUrl,\n            authHeaders || {},\n            null,\n            authParams,\n            authUrlRequestCallback as RequestCallback\n          );\n        }\n      };\n    } else if (authOptions.key) {\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');\n      tokenRequestCallback = (params: any, cb: Function) => {\n        this.createTokenRequest(params, authOptions, cb);\n      };\n    } else {\n      const msg =\n        'Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)';\n      Logger.logAction(\n        Logger.LOG_ERROR,\n        'Auth()',\n        'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help'\n      );\n      _callback(new ErrorInfo(msg, 40171, 403));\n      return;\n    }\n\n    /* normalise token params */\n    if ('capability' in (tokenParams as Record<string, any>))\n      (tokenParams as Record<string, any>).capability = c14n((tokenParams as Record<string, any>).capability);\n\n    const tokenRequest = (signedTokenParams: Record<string, any>, tokenCb: Function) => {\n      const keyName = signedTokenParams.keyName,\n        path = '/keys/' + keyName + '/requestToken',\n        tokenUri = function (host: string) {\n          return client.baseUri(host) + path;\n        };\n\n      const requestHeaders = Defaults.defaultPostHeaders(this.client.options);\n      if (authOptions.requestHeaders) Utils.mixin(requestHeaders, authOptions.requestHeaders);\n      Logger.logAction(\n        Logger.LOG_MICRO,\n        'Auth.requestToken().requestToken',\n        'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams)\n      );\n      this.client.http.do(\n        HttpMethods.Post,\n        client,\n        tokenUri,\n        requestHeaders,\n        JSON.stringify(signedTokenParams),\n        null,\n        tokenCb as RequestCallback\n      );\n    };\n\n    let tokenRequestCallbackTimeoutExpired = false,\n      timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,\n      tokenRequestCallbackTimeout = setTimeout(function () {\n        tokenRequestCallbackTimeoutExpired = true;\n        const msg = 'Token request callback timed out after ' + timeoutLength / 1000 + ' seconds';\n        Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);\n        _callback(new ErrorInfo(msg, 40170, 401));\n      }, timeoutLength);\n\n    tokenRequestCallback(tokenParams, function (err: ErrorInfo, tokenRequestOrDetails: any, contentType: string) {\n      if (tokenRequestCallbackTimeoutExpired) return;\n      clearTimeout(tokenRequestCallbackTimeout);\n\n      if (err) {\n        Logger.logAction(\n          Logger.LOG_ERROR,\n          'Auth.requestToken()',\n          'token request signing call returned error; err = ' + Utils.inspectError(err)\n        );\n        _callback(normaliseAuthcallbackError(err));\n        return;\n      }\n      /* the response from the callback might be a token string, a signed request or a token details */\n      if (typeof tokenRequestOrDetails === 'string') {\n        if (tokenRequestOrDetails.length === 0) {\n          _callback(new ErrorInfo('Token string is empty', 40170, 401));\n        } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\n          _callback(\n            new ErrorInfo(\n              'Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)',\n              40170,\n              401\n            )\n          );\n        } else if (tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {\n          /* common failure mode with poorly-implemented authCallbacks */\n          _callback(new ErrorInfo('Token string was literal null/undefined', 40170, 401));\n        } else if (tokenRequestOrDetails[0] === '{' && !(contentType && contentType.indexOf('application/jwt') > -1)) {\n          _callback(\n            new ErrorInfo(\n              \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\n              40170,\n              401\n            )\n          );\n        } else {\n          _callback(null, { token: tokenRequestOrDetails } as API.Types.TokenDetails);\n        }\n        return;\n      }\n      if (typeof tokenRequestOrDetails !== 'object') {\n        const msg =\n          'Expected token request callback to call back with a token string or token request/details object, but got a ' +\n          typeof tokenRequestOrDetails;\n        Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);\n        _callback(new ErrorInfo(msg, 40170, 401));\n        return;\n      }\n      const objectSize = JSON.stringify(tokenRequestOrDetails).length;\n      if (objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {\n        _callback(\n          new ErrorInfo(\n            'Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)',\n            40170,\n            401\n          )\n        );\n        return;\n      }\n      if ('issued' in tokenRequestOrDetails) {\n        /* a tokenDetails object */\n        _callback(null, tokenRequestOrDetails);\n        return;\n      }\n      if (!('keyName' in tokenRequestOrDetails)) {\n        const msg =\n          'Expected token request callback to call back with a token string, token request object, or token details object';\n        Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);\n        _callback(new ErrorInfo(msg, 40170, 401));\n        return;\n      }\n      /* it's a token request, so make the request */\n      tokenRequest(\n        tokenRequestOrDetails,\n        function (\n          err?: ErrorInfo | ErrnoException | null,\n          tokenResponse?: API.Types.TokenDetails | string,\n          headers?: Record<string, string>,\n          unpacked?: boolean\n        ) {\n          if (err) {\n            Logger.logAction(\n              Logger.LOG_ERROR,\n              'Auth.requestToken()',\n              'token request API call returned error; err = ' + Utils.inspectError(err)\n            );\n            _callback(normaliseAuthcallbackError(err));\n            return;\n          }\n          if (!unpacked) tokenResponse = JSON.parse(tokenResponse as string);\n          Logger.logAction(Logger.LOG_MINOR, 'Auth.getToken()', 'token received');\n          _callback(null, tokenResponse as API.Types.TokenDetails);\n        }\n      );\n    });\n  }\n\n  /**\n   * Create and sign a token request based on the given options.\n   * NOTE this can only be used when the key value is available locally.\n   * Otherwise, signed token requests must be obtained from the key\n   * owner (either using the token request callback or url).\n   *\n   * @param authOptions\n   * an object containing the request options:\n   * - key:           the key to use. If not specified, a key passed in constructing\n   *                  the Rest interface will be used\n   *\n   * - queryTime      (optional) boolean indicating that the ably system should be\n   *                  queried for the current time when none is specified explicitly\n   *\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n   *                  requestToken request\n   *\n   * @param tokenParams\n   * an object containing the parameters for the requested token:\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n   *                  exceeding that lifetime will be rejected with an error.\n   *\n   * - capability:    (optional) the capability to associate with the access token.\n   *                  If none is specified, a token will be requested with all of the\n   *                  capabilities of the specified key.\n   *\n   * - clientId:      (optional) a client ID to associate with the token; if not\n   *                  specified, a clientId passed in constructing the Rest interface will be used\n   *\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n   *                  the system will be queried for a time value to use.\n   *\n   * @param callback\n   */\n  createTokenRequest(tokenParams: API.Types.TokenParams | null, authOptions: any, callback: Function) {\n    /* shuffle and normalise arguments as necessary */\n    if (typeof tokenParams == 'function' && !callback) {\n      callback = tokenParams;\n      authOptions = tokenParams = null;\n    } else if (typeof authOptions == 'function' && !callback) {\n      callback = authOptions;\n      authOptions = null;\n    }\n    if (!callback) {\n      return Utils.promisify(this, 'createTokenRequest', arguments);\n    }\n\n    /* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */\n    authOptions = authOptions || this.authOptions;\n    tokenParams = tokenParams || Utils.copy<API.Types.TokenParams>(this.tokenParams);\n\n    const key = authOptions.key;\n    if (!key) {\n      callback(new ErrorInfo('No key specified', 40101, 403));\n      return;\n    }\n    const keyParts = key.split(':'),\n      keyName = keyParts[0],\n      keySecret = keyParts[1];\n\n    if (!keySecret) {\n      callback(new ErrorInfo('Invalid key specified', 40101, 403));\n      return;\n    }\n\n    if (tokenParams.clientId === '') {\n      callback(new ErrorInfo('clientId can\u2019t be an empty string', 40012, 400));\n      return;\n    }\n\n    if ('capability' in tokenParams) {\n      tokenParams.capability = c14n(tokenParams.capability);\n    }\n\n    const request = Utils.mixin({ keyName: keyName }, tokenParams),\n      clientId = tokenParams.clientId || '',\n      ttl = tokenParams.ttl || '',\n      capability = tokenParams.capability || '';\n\n    ((authoriseCb) => {\n      if (request.timestamp) {\n        authoriseCb();\n        return;\n      }\n      this.getTimestamp(authOptions && authOptions.queryTime, function (err?: ErrorInfo | null, time?: number) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        request.timestamp = time;\n        authoriseCb();\n      });\n    })(function () {\n      /* nonce */\n      /* NOTE: there is no expectation that the client\n       * specifies the nonce; this is done by the library\n       * However, this can be overridden by the client\n       * simply for testing purposes. */\n      const nonce = request.nonce || (request.nonce = random()),\n        timestamp = request.timestamp;\n\n      const signText =\n        request.keyName + '\\n' + ttl + '\\n' + capability + '\\n' + clientId + '\\n' + timestamp + '\\n' + nonce + '\\n';\n\n      /* mac */\n      /* NOTE: there is no expectation that the client\n       * specifies the mac; this is done by the library\n       * However, this can be overridden by the client\n       * simply for testing purposes. */\n      request.mac = request.mac || hmac(signText, keySecret);\n\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');\n      callback(null, request);\n    });\n  }\n\n  /**\n   * Get the auth query params to use for a websocket connection,\n   * based on the current auth parameters\n   */\n  getAuthParams(callback: Function) {\n    if (this.method == 'basic') callback(null, { key: this.key });\n    else\n      this._ensureValidAuthCredentials(false, function (err: ErrorInfo | null, tokenDetails?: API.Types.TokenDetails) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (!tokenDetails) {\n          throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\n        }\n        callback(null, { access_token: tokenDetails.token });\n      });\n  }\n\n  /**\n   * Get the authorization header to use for a REST or comet request,\n   * based on the current auth parameters\n   */\n  getAuthHeaders(callback: Function) {\n    if (this.method == 'basic') {\n      callback(null, { authorization: 'Basic ' + this.basicKey });\n    } else {\n      this._ensureValidAuthCredentials(false, function (err: ErrorInfo | null, tokenDetails?: API.Types.TokenDetails) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (!tokenDetails) {\n          throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\n        }\n        callback(null, { authorization: 'Bearer ' + Utils.toBase64(tokenDetails.token) });\n      });\n    }\n  }\n\n  /**\n   * Get the current time based on the local clock,\n   * or if the option queryTime is true, return the server time.\n   * The server time offset from the local time is stored so that\n   * only one request to the server to get the time is ever needed\n   */\n  getTimestamp(queryTime: boolean, callback: StandardCallback<number>): void {\n    if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {\n      this.client.time(callback);\n    } else {\n      callback(null, this.getTimestampUsingOffset());\n    }\n  }\n\n  getTimestampUsingOffset() {\n    return Utils.now() + (this.client.serverTimeOffset || 0);\n  }\n\n  isTimeOffsetSet() {\n    return this.client.serverTimeOffset !== null;\n  }\n\n  _saveBasicOptions(authOptions: API.Types.AuthOptions) {\n    this.method = 'basic';\n    this.key = authOptions.key;\n    this.basicKey = Utils.toBase64(authOptions.key as string);\n    this.authOptions = authOptions || {};\n    if ('clientId' in authOptions) {\n      this._userSetClientId(authOptions.clientId);\n    }\n  }\n\n  _saveTokenOptions(tokenParams: API.Types.TokenParams | null, authOptions: API.Types.AuthOptions | null) {\n    this.method = 'token';\n\n    if (tokenParams) {\n      /* We temporarily persist tokenParams.timestamp in case a new token needs\n       * to be requested, then null it out in the callback of\n       * _ensureValidAuthCredentials for RSA10g compliance */\n      this.tokenParams = tokenParams;\n    }\n\n    if (authOptions) {\n      /* normalise */\n      if (authOptions.token) {\n        /* options.token may contain a token string or, for convenience, a TokenDetails */\n        authOptions.tokenDetails =\n          typeof authOptions.token === 'string'\n            ? ({ token: authOptions.token } as API.Types.TokenDetails)\n            : authOptions.token;\n      }\n\n      if (authOptions.tokenDetails) {\n        this.tokenDetails = authOptions.tokenDetails;\n      }\n\n      if ('clientId' in authOptions) {\n        this._userSetClientId(authOptions.clientId);\n      }\n\n      this.authOptions = authOptions;\n    }\n  }\n\n  /* @param forceSupersede: force a new token request even if there's one in\n   * progress, making all pending callbacks wait for the new one */\n  _ensureValidAuthCredentials(\n    forceSupersede: boolean,\n    callback: (err: ErrorInfo | null, token?: API.Types.TokenDetails) => void\n  ) {\n    const token = this.tokenDetails;\n\n    if (token) {\n      if (this._tokenClientIdMismatch(token.clientId)) {\n        /* 403 to trigger a permanently failed client - RSA15c */\n        callback(\n          new ErrorInfo(\n            'Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')',\n            40102,\n            403\n          )\n        );\n        return;\n      }\n      /* RSA4b1 -- if we have a server time offset set already, we can\n       * automatically remove expired tokens. Else just use the cached token. If it is\n       * expired Ably will tell us and we'll discard it then. */\n      if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {\n        Logger.logAction(Logger.LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);\n        callback(null, token);\n        return;\n      }\n      /* expired, so remove and fallthrough to getting a new one */\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.getToken()', 'deleting expired token');\n      this.tokenDetails = null;\n    }\n\n    (this.waitingForTokenRequest || (this.waitingForTokenRequest = Multicaster.create())).push(callback);\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\n      return;\n    }\n\n    /* Request a new token */\n    const tokenRequestId = (this.currentTokenRequestId = getTokenRequestId());\n    this.requestToken(this.tokenParams, this.authOptions, (err: Function, tokenResponse?: API.Types.TokenDetails) => {\n      if ((this.currentTokenRequestId as number) > tokenRequestId) {\n        Logger.logAction(\n          Logger.LOG_MINOR,\n          'Auth._ensureValidAuthCredentials()',\n          'Discarding token request response; overtaken by newer one'\n        );\n        return;\n      }\n      this.currentTokenRequestId = null;\n      const callbacks = this.waitingForTokenRequest || noop;\n      this.waitingForTokenRequest = null;\n      if (err) {\n        callbacks(err);\n        return;\n      }\n      callbacks(null, (this.tokenDetails = tokenResponse));\n    });\n  }\n\n  /* User-set: check types, '*' is disallowed, throw any errors */\n  _userSetClientId(clientId: string | undefined) {\n    if (!(typeof clientId === 'string' || clientId === null)) {\n      throw new ErrorInfo('clientId must be either a string or null', 40012, 400);\n    } else if (clientId === '*') {\n      throw new ErrorInfo(\n        'Can\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\n        40012,\n        400\n      );\n    } else {\n      const err = this._uncheckedSetClientId(clientId);\n      if (err) throw err;\n    }\n  }\n\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\n  _uncheckedSetClientId(clientId: string | undefined) {\n    if (this._tokenClientIdMismatch(clientId)) {\n      /* Should never happen in normal circumstances as realtime should\n       * recognise mismatch and return an error */\n      const msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;\n      const err = new ErrorInfo(msg, 40102, 401);\n      Logger.logAction(Logger.LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);\n      return err;\n    } else {\n      /* RSA7a4: if options.clientId is provided and is not\n       * null, it overrides defaultTokenParams.clientId */\n      this.clientId = this.tokenParams.clientId = clientId;\n      return null;\n    }\n  }\n\n  _tokenClientIdMismatch(tokenClientId?: string | null): boolean {\n    return !!(\n      this.clientId &&\n      this.clientId !== '*' &&\n      tokenClientId &&\n      tokenClientId !== '*' &&\n      this.clientId !== tokenClientId\n    );\n  }\n\n  static isTokenErr(error: IPartialErrorInfo) {\n    return error.code && error.code >= 40140 && error.code < 40150;\n  }\n}\n\nexport default Auth;\n", "import Logger, { LoggerOptions } from '../util/logger';\nimport Defaults from '../util/defaults';\nimport Auth from './auth';\nimport ErrorInfo from '../types/errorinfo';\nimport Stats from '../types/stats';\nimport { StandardCallback } from '../../types/utils';\nimport { IHttp, RequestParams } from '../../types/http';\nimport ClientOptions, { NormalisedClientOptions } from '../../types/ClientOptions';\n\nimport Platform from '../../platform';\nimport Rest from './rest';\nimport { HttpPaginatedResponse, PaginatedResult } from './paginatedresource';\n\ninterface ModulesMap {\n  Rest?: typeof Rest;\n}\n\nclass BaseClient {\n  options: NormalisedClientOptions;\n  baseUri: (host: string) => string;\n  authority: (host: string) => string;\n  _currentFallback: null | {\n    host: string;\n    validUntil: number;\n  };\n  serverTimeOffset: number | null;\n  http: IHttp;\n  auth: Auth;\n  _rest?: Rest;\n\n  constructor(options: ClientOptions | string, modules: ModulesMap) {\n    if (!options) {\n      const msg = 'no options provided';\n      Logger.logAction(Logger.LOG_ERROR, 'Rest()', msg);\n      throw new Error(msg);\n    }\n    const optionsObj = Defaults.objectifyOptions(options);\n\n    Logger.setLog(optionsObj.logLevel, optionsObj.logHandler);\n    Logger.logAction(Logger.LOG_MICRO, 'Rest()', 'initialized with clientOptions ' + Platform.Config.inspect(options));\n\n    const normalOptions = (this.options = Defaults.normaliseOptions(optionsObj));\n\n    /* process options */\n    if (normalOptions.key) {\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\n      if (!keyMatch) {\n        const msg = 'invalid key parameter';\n        Logger.logAction(Logger.LOG_ERROR, 'Rest()', msg);\n        throw new ErrorInfo(msg, 40400, 404);\n      }\n      normalOptions.keyName = keyMatch[1];\n      normalOptions.keySecret = keyMatch[2];\n    }\n\n    if ('clientId' in normalOptions) {\n      if (!(typeof normalOptions.clientId === 'string' || normalOptions.clientId === null))\n        throw new ErrorInfo('clientId must be either a string or null', 40012, 400);\n      else if (normalOptions.clientId === '*')\n        throw new ErrorInfo(\n          'Can\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\n          40012,\n          400\n        );\n    }\n\n    Logger.logAction(Logger.LOG_MINOR, 'Rest()', 'started; version = ' + Defaults.version);\n\n    this.baseUri = this.authority = function (host) {\n      return Defaults.getHttpScheme(normalOptions) + host + ':' + Defaults.getPort(normalOptions, false);\n    };\n    this._currentFallback = null;\n\n    this.serverTimeOffset = null;\n    this.http = new Platform.Http(normalOptions);\n    this.auth = new Auth(this, normalOptions);\n\n    if (modules?.Rest) {\n      this._rest = new modules.Rest(this);\n    }\n  }\n\n  private get rest(): Rest {\n    if (!this._rest) {\n      throw new ErrorInfo('Rest module not provided', 400, 40000);\n    }\n    return this._rest;\n  }\n\n  get channels() {\n    return this.rest.channels;\n  }\n\n  get push() {\n    return this.rest.push;\n  }\n\n  stats(\n    params: RequestParams,\n    callback: StandardCallback<PaginatedResult<Stats>>\n  ): Promise<PaginatedResult<Stats>> | void {\n    return this.rest.stats(params, callback);\n  }\n\n  time(params?: RequestParams | StandardCallback<number>, callback?: StandardCallback<number>): Promise<number> | void {\n    return this.rest.time(params, callback);\n  }\n\n  request(\n    method: string,\n    path: string,\n    version: number,\n    params: RequestParams,\n    body: unknown,\n    customHeaders: Record<string, string>,\n    callback: StandardCallback<HttpPaginatedResponse<unknown>>\n  ): Promise<HttpPaginatedResponse<unknown>> | void {\n    return this.rest.request(method, path, version, params, body, customHeaders, callback);\n  }\n\n  setLog(logOptions: LoggerOptions): void {\n    Logger.setLog(logOptions.level, logOptions.handler);\n  }\n\n  static Platform = Platform;\n}\n\nexport { BaseClient };\n", "import * as Utils from '../util/utils';\nimport ErrorInfo, { IConvertibleToErrorInfo } from './errorinfo';\n\nenum DeviceFormFactor {\n  Phone = 'phone',\n  Tablet = 'tablet',\n  Desktop = 'desktop',\n  TV = 'tv',\n  Watch = 'watch',\n  Car = 'car',\n  Embedded = 'embedded',\n  Other = 'other',\n}\n\nenum DevicePlatform {\n  Android = 'android',\n  IOS = 'ios',\n  Browser = 'browser',\n}\n\ntype DevicePushState = 'ACTIVE' | 'FAILING' | 'FAILED';\n\ntype DevicePushDetails = {\n  error?: ErrorInfo;\n  recipient?: string;\n  state?: DevicePushState;\n  metadata?: string;\n};\n\nclass DeviceDetails {\n  id?: string;\n  clientId?: string;\n  deviceSecret?: string;\n  formFactor?: DeviceFormFactor;\n  platform?: DevicePlatform;\n  push?: DevicePushDetails;\n  metadata?: string;\n  deviceIdentityToken?: string;\n\n  toJSON(): DeviceDetails {\n    return {\n      id: this.id,\n      deviceSecret: this.deviceSecret,\n      platform: this.platform,\n      formFactor: this.formFactor,\n      clientId: this.clientId,\n      metadata: this.metadata,\n      deviceIdentityToken: this.deviceIdentityToken,\n      push: {\n        recipient: this.push?.recipient,\n        state: this.push?.state,\n        error: this.push?.error,\n      },\n    } as DeviceDetails;\n  }\n\n  toString(): string {\n    let result = '[DeviceDetails';\n    if (this.id) result += '; id=' + this.id;\n    if (this.platform) result += '; platform=' + this.platform;\n    if (this.formFactor) result += '; formFactor=' + this.formFactor;\n    if (this.clientId) result += '; clientId=' + this.clientId;\n    if (this.metadata) result += '; metadata=' + this.metadata;\n    if (this.deviceIdentityToken) result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);\n    if (this.push?.recipient) result += '; push.recipient=' + JSON.stringify(this.push.recipient);\n    if (this.push?.state) result += '; push.state=' + this.push.state;\n    if (this.push?.error) result += '; push.error=' + JSON.stringify(this.push.error);\n    if (this.push?.metadata) result += '; push.metadata=' + this.push.metadata;\n    result += ']';\n    return result;\n  }\n\n  static toRequestBody = Utils.encodeBody;\n\n  static fromResponseBody(\n    body: Array<Record<string, unknown>> | Record<string, unknown>,\n    format?: Utils.Format\n  ): DeviceDetails | DeviceDetails[] {\n    if (format) {\n      body = Utils.decodeBody(body, format);\n    }\n\n    if (Utils.isArray(body)) {\n      return DeviceDetails.fromValuesArray(body);\n    } else {\n      return DeviceDetails.fromValues(body);\n    }\n  }\n\n  static fromValues(values: Record<string, unknown>): DeviceDetails {\n    values.error = values.error && ErrorInfo.fromValues(values.error as IConvertibleToErrorInfo);\n    return Object.assign(new DeviceDetails(), values);\n  }\n\n  static fromValuesArray(values: Array<Record<string, unknown>>): DeviceDetails[] {\n    const count = values.length,\n      result = new Array(count);\n    for (let i = 0; i < count; i++) result[i] = DeviceDetails.fromValues(values[i]);\n    return result;\n  }\n}\n\nexport default DeviceDetails;\n", "import Platform from '../../platform';\nimport * as Utils from '../util/utils';\nimport Logger from '../util/logger';\nimport Auth from './auth';\nimport HttpMethods from '../../constants/HttpMethods';\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from '../types/errorinfo';\nimport { ErrnoException } from '../../types/http';\nimport { BaseClient } from './baseclient';\n\nfunction withAuthDetails(\n  client: BaseClient,\n  headers: Record<string, string>,\n  params: Record<string, any>,\n  errCallback: Function,\n  opCallback: Function\n) {\n  if (client.http.supportsAuthHeaders) {\n    client.auth.getAuthHeaders(function (err: Error, authHeaders: Record<string, string>) {\n      if (err) errCallback(err);\n      else opCallback(Utils.mixin(authHeaders, headers), params);\n    });\n  } else {\n    client.auth.getAuthParams(function (err: Error, authParams: Record<string, string>) {\n      if (err) errCallback(err);\n      else opCallback(headers, Utils.mixin(authParams, params));\n    });\n  }\n}\n\nfunction unenvelope<T>(callback: ResourceCallback<T>, format: Utils.Format | null): ResourceCallback<T> {\n  return (err, body, outerHeaders, unpacked, outerStatusCode) => {\n    if (err && !body) {\n      callback(err);\n      return;\n    }\n\n    if (!unpacked) {\n      try {\n        body = Utils.decodeBody(body, format);\n      } catch (e) {\n        if (Utils.isErrorInfoOrPartialErrorInfo(e)) {\n          callback(e);\n        } else {\n          callback(new PartialErrorInfo(Utils.inspectError(e), null));\n        }\n        return;\n      }\n    }\n\n    if (!body) {\n      callback(new PartialErrorInfo('unenvelope(): Response body is missing', null));\n      return;\n    }\n\n    const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body as Record<string, any>;\n\n    if (wrappedStatusCode === undefined) {\n      /* Envelope already unwrapped by the transport */\n      callback(err, body, outerHeaders, true, outerStatusCode);\n      return;\n    }\n\n    if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\n      /* handle wrapped errors */\n      let wrappedErr = (response && response.error) || err;\n      if (!wrappedErr) {\n        wrappedErr = new Error('Error in unenveloping ' + body);\n        wrappedErr.statusCode = wrappedStatusCode;\n      }\n      callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);\n      return;\n    }\n\n    callback(err, response, wrappedHeaders, true, wrappedStatusCode);\n  };\n}\n\nfunction paramString(params: Record<string, any>) {\n  const paramPairs = [];\n  if (params) {\n    for (const needle in params) {\n      paramPairs.push(needle + '=' + params[needle]);\n    }\n  }\n  return paramPairs.join('&');\n}\n\nfunction urlFromPathAndParams(path: string, params: Record<string, any>) {\n  return path + (params ? '?' : '') + paramString(params);\n}\n\nfunction logResponseHandler<T>(\n  callback: ResourceCallback<T>,\n  method: HttpMethods,\n  path: string,\n  params: Record<string, string>\n): ResourceCallback {\n  return (err, body, headers, unpacked, statusCode) => {\n    if (err) {\n      Logger.logAction(\n        Logger.LOG_MICRO,\n        'Resource.' + method + '()',\n        'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + Utils.inspectError(err)\n      );\n    } else {\n      Logger.logAction(\n        Logger.LOG_MICRO,\n        'Resource.' + method + '()',\n        'Received; ' +\n          urlFromPathAndParams(path, params) +\n          '; Headers: ' +\n          paramString(headers as Record<string, any>) +\n          '; StatusCode: ' +\n          statusCode +\n          '; Body: ' +\n          (Platform.BufferUtils.isBuffer(body) ? body.toString() : body)\n      );\n    }\n    if (callback) {\n      callback(err, body as T, headers, unpacked, statusCode);\n    }\n  };\n}\n\nexport type ResourceCallback<T = unknown> = (\n  err: IPartialErrorInfo | null,\n  body?: T,\n  headers?: Record<string, string>,\n  unpacked?: boolean,\n  statusCode?: number\n) => void;\n\nclass Resource {\n  static get<T = unknown>(\n    client: BaseClient,\n    path: string,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    callback: ResourceCallback<T>\n  ): void {\n    Resource.do(HttpMethods.Get, client, path, null, headers, params, envelope, callback);\n  }\n\n  static delete(\n    client: BaseClient,\n    path: string,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    callback: ResourceCallback\n  ): void {\n    Resource.do(HttpMethods.Delete, client, path, null, headers, params, envelope, callback);\n  }\n\n  static post(\n    client: BaseClient,\n    path: string,\n    body: unknown,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    callback: ResourceCallback\n  ): void {\n    Resource.do(HttpMethods.Post, client, path, body, headers, params, envelope, callback);\n  }\n\n  static patch(\n    client: BaseClient,\n    path: string,\n    body: unknown,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    callback: ResourceCallback\n  ): void {\n    Resource.do(HttpMethods.Patch, client, path, body, headers, params, envelope, callback);\n  }\n\n  static put(\n    client: BaseClient,\n    path: string,\n    body: unknown,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    callback: ResourceCallback\n  ): void {\n    Resource.do(HttpMethods.Put, client, path, body, headers, params, envelope, callback);\n  }\n\n  static do<T>(\n    method: HttpMethods,\n    client: BaseClient,\n    path: string,\n    body: unknown,\n    headers: Record<string, string>,\n    params: Record<string, any>,\n    envelope: Utils.Format | null,\n    callback: ResourceCallback<T>\n  ): void {\n    if (Logger.shouldLog(Logger.LOG_MICRO)) {\n      callback = logResponseHandler(callback, method, path, params);\n    }\n\n    if (envelope) {\n      callback = callback && unenvelope(callback, envelope);\n      (params = params || {})['envelope'] = envelope;\n    }\n\n    function doRequest(this: any, headers: Record<string, string>, params: Record<string, any>) {\n      if (Logger.shouldLog(Logger.LOG_MICRO)) {\n        Logger.logAction(\n          Logger.LOG_MICRO,\n          'Resource.' + method + '()',\n          'Sending; ' + urlFromPathAndParams(path, params)\n        );\n      }\n\n      if (Logger.shouldLog(Logger.LOG_MICRO)) {\n        let decodedBody = body;\n        if (headers['content-type']?.indexOf('msgpack') > 0) {\n          try {\n            decodedBody = Platform.Config.msgpack.decode(body as Buffer);\n          } catch (decodeErr) {\n            Logger.logAction(\n              Logger.LOG_MICRO,\n              'Resource.' + method + '()',\n              'Sending MsgPack Decoding Error: ' + Utils.inspectError(decodeErr)\n            );\n          }\n        }\n        Logger.logAction(\n          Logger.LOG_MICRO,\n          'Resource.' + method + '()',\n          'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody\n        );\n      }\n\n      client.http.do(\n        method,\n        client,\n        path,\n        headers,\n        body,\n        params,\n        function (\n          err: ErrorInfo | ErrnoException | null | undefined,\n          res: any,\n          headers: Record<string, string>,\n          unpacked?: boolean,\n          statusCode?: number\n        ) {\n          if (err && Auth.isTokenErr(err as ErrorInfo)) {\n            /* token has expired, so get a new one */\n            client.auth.authorize(null, null, function (err: ErrorInfo) {\n              if (err) {\n                callback(err);\n                return;\n              }\n              /* retry ... */\n              withAuthDetails(client, headers, params, callback, doRequest);\n            });\n            return;\n          }\n          callback(err as ErrorInfo, res, headers, unpacked, statusCode);\n        }\n      );\n    }\n\n    withAuthDetails(client, headers, params, callback, doRequest);\n  }\n}\n\nexport default Resource;\n", "import * as Utils from '../util/utils';\nimport Logger from '../util/logger';\nimport Resource from './resource';\nimport ErrorInfo, { IPartialErrorInfo } from '../types/errorinfo';\nimport { PaginatedResultCallback } from '../../types/utils';\nimport { BaseClient } from './baseclient';\n\nexport type BodyHandler = (body: unknown, headers: Record<string, string>, packed?: boolean) => Promise<any>;\n\nfunction getRelParams(linkUrl: string) {\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\n  return urlMatch && urlMatch[2] && Utils.parseQueryString(urlMatch[2]);\n}\n\nfunction parseRelLinks(linkHeader: string | Array<string>) {\n  if (typeof linkHeader == 'string') linkHeader = linkHeader.split(',');\n\n  const relParams: Record<string, Record<string, string>> = {};\n  for (let i = 0; i < linkHeader.length; i++) {\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\n    if (linkMatch) {\n      const params = getRelParams(linkMatch[1]);\n      if (params) relParams[linkMatch[2]] = params;\n    }\n  }\n  return relParams;\n}\n\nfunction returnErrOnly(err: IPartialErrorInfo, body: unknown, useHPR?: boolean) {\n  /* If using httpPaginatedResponse, errors from Ably are returned as part of\n   * the HPR, only do callback(err) for network errors etc. which don't\n   * return a body and/or have no ably-originated error code (non-numeric\n   * error codes originate from node) */\n  return !(useHPR && (body || typeof err.code === 'number'));\n}\n\nclass PaginatedResource {\n  client: BaseClient;\n  path: string;\n  headers: Record<string, string>;\n  envelope: Utils.Format | null;\n  bodyHandler: BodyHandler;\n  useHttpPaginatedResponse: boolean;\n\n  constructor(\n    client: BaseClient,\n    path: string,\n    headers: Record<string, string>,\n    envelope: Utils.Format | undefined,\n    bodyHandler: BodyHandler,\n    useHttpPaginatedResponse?: boolean\n  ) {\n    this.client = client;\n    this.path = path;\n    this.headers = headers;\n    this.envelope = envelope ?? null;\n    this.bodyHandler = bodyHandler;\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\n  }\n\n  get<T1, T2>(params: Record<string, T2>, callback: PaginatedResultCallback<T1>): void {\n    Resource.get(\n      this.client,\n      this.path,\n      this.headers,\n      params,\n      this.envelope,\n      (err, body, headers, unpacked, statusCode) => {\n        this.handlePage(err, body, headers, unpacked, statusCode, callback);\n      }\n    );\n  }\n\n  delete<T1, T2>(params: Record<string, T2>, callback: PaginatedResultCallback<T1>): void {\n    Resource.delete(\n      this.client,\n      this.path,\n      this.headers,\n      params,\n      this.envelope,\n      (err, body, headers, unpacked, statusCode) => {\n        this.handlePage(err, body, headers, unpacked, statusCode, callback);\n      }\n    );\n  }\n\n  post<T1, T2>(params: Record<string, T2>, body: unknown, callback: PaginatedResultCallback<T1>): void {\n    Resource.post(\n      this.client,\n      this.path,\n      body,\n      this.headers,\n      params,\n      this.envelope,\n      (err, responseBody, headers, unpacked, statusCode) => {\n        if (callback) {\n          this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);\n        }\n      }\n    );\n  }\n\n  put<T1, T2>(params: Record<string, T2>, body: unknown, callback: PaginatedResultCallback<T1>): void {\n    Resource.put(\n      this.client,\n      this.path,\n      body,\n      this.headers,\n      params,\n      this.envelope,\n      (err, responseBody, headers, unpacked, statusCode) => {\n        if (callback) {\n          this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);\n        }\n      }\n    );\n  }\n\n  patch<T1, T2>(params: Record<string, T2>, body: unknown, callback: PaginatedResultCallback<T1>): void {\n    Resource.patch(\n      this.client,\n      this.path,\n      body,\n      this.headers,\n      params,\n      this.envelope,\n      (err, responseBody, headers, unpacked, statusCode) => {\n        if (callback) {\n          this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);\n        }\n      }\n    );\n  }\n\n  handlePage<T>(\n    err: IPartialErrorInfo | null,\n    body: unknown,\n    headers: Record<string, string> | undefined,\n    unpacked: boolean | undefined,\n    statusCode: number | undefined,\n    callback: PaginatedResultCallback<T>\n  ): void {\n    if (err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {\n      Logger.logAction(\n        Logger.LOG_ERROR,\n        'PaginatedResource.handlePage()',\n        'Unexpected error getting resource: err = ' + Utils.inspectError(err)\n      );\n      callback?.(err);\n      return;\n    }\n\n    const handleBody = async () => {\n      let items, linkHeader, relParams;\n\n      try {\n        items = await this.bodyHandler(body, headers || {}, unpacked);\n      } catch (e) {\n        /* If we got an error, the failure to parse the body is almost certainly\n         * due to that, so throw that in preference over the parse error */\n        throw err || e;\n      }\n\n      if (headers && (linkHeader = headers['Link'] || headers['link'])) {\n        relParams = parseRelLinks(linkHeader);\n      }\n\n      if (this.useHttpPaginatedResponse) {\n        return new HttpPaginatedResponse(this, items, headers || {}, statusCode as number, relParams, err);\n      } else {\n        return new PaginatedResult(this, items, relParams);\n      }\n    };\n\n    handleBody()\n      .then((result) => callback(null, result))\n      .catch((err) => callback(err, null));\n  }\n}\n\nexport class PaginatedResult<T> {\n  resource: PaginatedResource;\n  items: T[];\n  first?: (results: PaginatedResultCallback<T>) => void;\n  next?: (results: PaginatedResultCallback<T>) => void;\n  current?: (results: PaginatedResultCallback<T>) => void;\n  hasNext?: () => boolean;\n  isLast?: () => boolean;\n\n  constructor(resource: PaginatedResource, items: T[], relParams?: Record<string, any>) {\n    this.resource = resource;\n    this.items = items;\n\n    const self = this;\n    if (relParams) {\n      if ('first' in relParams) {\n        this.first = function (callback: (result?: ErrorInfo | null) => void) {\n          if (!callback) {\n            return Utils.promisify(self, 'first', []);\n          }\n          self.get(relParams.first, callback);\n        };\n      }\n      if ('current' in relParams) {\n        this.current = function (callback: (results?: ErrorInfo | null) => void) {\n          if (!callback) {\n            return Utils.promisify(self, 'current', []);\n          }\n          self.get(relParams.current, callback);\n        };\n      }\n      this.next = function (callback: (results?: ErrorInfo | null) => void) {\n        if (!callback) {\n          return Utils.promisify(self, 'next', []);\n        }\n        if ('next' in relParams) {\n          self.get(relParams.next, callback);\n        } else {\n          callback(null);\n        }\n      };\n\n      this.hasNext = function () {\n        return 'next' in relParams;\n      };\n      this.isLast = () => {\n        return !this.hasNext?.();\n      };\n    }\n  }\n\n  /* We assume that only the initial request can be a POST, and that accessing\n   * the rest of a multipage set of results can always be done with GET */\n  get(params: any, callback: PaginatedResultCallback<T>): void {\n    const res = this.resource;\n    Resource.get(\n      res.client,\n      res.path,\n      res.headers,\n      params,\n      res.envelope,\n      function (err, body, headers, unpacked, statusCode) {\n        res.handlePage(err, body, headers, unpacked, statusCode, callback);\n      }\n    );\n  }\n}\n\nexport class HttpPaginatedResponse<T> extends PaginatedResult<T> {\n  statusCode: number;\n  success: boolean;\n  headers: Record<string, string>;\n  errorCode?: number | null;\n  errorMessage?: string | null;\n\n  constructor(\n    resource: PaginatedResource,\n    items: T[],\n    headers: Record<string, string>,\n    statusCode: number,\n    relParams: any,\n    err: IPartialErrorInfo | null\n  ) {\n    super(resource, items, relParams);\n    this.statusCode = statusCode;\n    this.success = statusCode < 300 && statusCode >= 200;\n    this.headers = headers;\n    this.errorCode = err && err.code;\n    this.errorMessage = err && err.message;\n  }\n\n  toJSON() {\n    return {\n      items: this.items,\n      statusCode: this.statusCode,\n      success: this.success,\n      headers: this.headers,\n      errorCode: this.errorCode,\n      errorMessage: this.errorMessage,\n    };\n  }\n}\n\nexport default PaginatedResource;\n", "import * as Utils from '../util/utils';\n\ntype PushChannelSubscriptionObject = {\n  channel?: string;\n  deviceId?: string;\n  clientId?: string;\n};\n\nclass PushChannelSubscription {\n  channel?: string;\n  deviceId?: string;\n  clientId?: string;\n\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON(): PushChannelSubscriptionObject {\n    return {\n      channel: this.channel,\n      deviceId: this.deviceId,\n      clientId: this.clientId,\n    };\n  }\n\n  toString(): string {\n    let result = '[PushChannelSubscription';\n    if (this.channel) result += '; channel=' + this.channel;\n    if (this.deviceId) result += '; deviceId=' + this.deviceId;\n    if (this.clientId) result += '; clientId=' + this.clientId;\n    result += ']';\n    return result;\n  }\n\n  static toRequestBody = Utils.encodeBody;\n\n  static fromResponseBody(\n    body: Array<Record<string, unknown>> | Record<string, unknown>,\n    format?: Utils.Format\n  ): PushChannelSubscription | PushChannelSubscription[] {\n    if (format) {\n      body = Utils.decodeBody(body, format) as Record<string, unknown>;\n    }\n\n    if (Utils.isArray(body)) {\n      return PushChannelSubscription.fromValuesArray(body);\n    } else {\n      return PushChannelSubscription.fromValues(body);\n    }\n  }\n\n  static fromValues(values: Record<string, unknown>): PushChannelSubscription {\n    return Object.assign(new PushChannelSubscription(), values);\n  }\n\n  static fromValuesArray(values: Array<Record<string, unknown>>): PushChannelSubscription[] {\n    const count = values.length,\n      result = new Array(count);\n    for (let i = 0; i < count; i++) result[i] = PushChannelSubscription.fromValues(values[i]);\n    return result;\n  }\n}\n\nexport default PushChannelSubscription;\n", "import * as Utils from '../util/utils';\nimport DeviceDetails from '../types/devicedetails';\nimport Resource from './resource';\nimport PaginatedResource from './paginatedresource';\nimport ErrorInfo from '../types/errorinfo';\nimport PushChannelSubscription from '../types/pushchannelsubscription';\nimport { ErrCallback, PaginatedResultCallback, StandardCallback } from '../../types/utils';\nimport Rest from './rest';\nimport Defaults from '../util/defaults';\n\nclass Push {\n  rest: Rest;\n  admin: Admin;\n\n  constructor(rest: Rest) {\n    this.rest = rest;\n    this.admin = new Admin(rest);\n  }\n}\n\nclass Admin {\n  rest: Rest;\n  deviceRegistrations: DeviceRegistrations;\n  channelSubscriptions: ChannelSubscriptions;\n\n  constructor(rest: Rest) {\n    this.rest = rest;\n    this.deviceRegistrations = new DeviceRegistrations(rest);\n    this.channelSubscriptions = new ChannelSubscriptions(rest);\n  }\n\n  publish(recipient: any, payload: any, callback: ErrCallback) {\n    const rest = this.rest;\n    const format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultPostHeaders(rest.options, { format }),\n      params = {};\n    const body = Utils.mixin({ recipient: recipient }, payload);\n\n    if (typeof callback !== 'function') {\n      return Utils.promisify(this, 'publish', arguments);\n    }\n\n    Utils.mixin(headers, rest.options.headers);\n\n    if (rest.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    const requestBody = Utils.encodeBody(body, format);\n    Resource.post(rest.client, '/push/publish', requestBody, headers, params, null, (err) => callback(err));\n  }\n}\n\nclass DeviceRegistrations {\n  rest: Rest;\n\n  constructor(rest: Rest) {\n    this.rest = rest;\n  }\n\n  save(device: any, callback: StandardCallback<DeviceDetails>) {\n    const rest = this.rest;\n    const body = DeviceDetails.fromValues(device);\n    const format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultPostHeaders(rest.options, { format }),\n      params = {};\n\n    if (typeof callback !== 'function') {\n      return Utils.promisify(this, 'save', arguments);\n    }\n\n    Utils.mixin(headers, rest.options.headers);\n\n    if (rest.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    const requestBody = Utils.encodeBody(body, format);\n    Resource.put(\n      rest.client,\n      '/push/deviceRegistrations/' + encodeURIComponent(device.id),\n      requestBody,\n      headers,\n      params,\n      null,\n      (err, body, headers, unpacked) => {\n        callback(\n          err,\n          !err\n            ? (DeviceDetails.fromResponseBody(\n                body as Record<string, unknown>,\n                unpacked ? undefined : format\n              ) as DeviceDetails)\n            : undefined\n        );\n      }\n    );\n  }\n\n  get(deviceIdOrDetails: any, callback: StandardCallback<DeviceDetails>) {\n    const rest = this.rest,\n      format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultGetHeaders(rest.options, { format }),\n      deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n\n    if (typeof callback !== 'function') {\n      return Utils.promisify(this, 'get', arguments);\n    }\n\n    if (typeof deviceId !== 'string' || !deviceId.length) {\n      callback(\n        new ErrorInfo(\n          'First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails',\n          40000,\n          400\n        )\n      );\n      return;\n    }\n\n    Utils.mixin(headers, rest.options.headers);\n\n    Resource.get(\n      rest.client,\n      '/push/deviceRegistrations/' + encodeURIComponent(deviceId),\n      headers,\n      {},\n      null,\n      function (err, body, headers, unpacked) {\n        callback(\n          err,\n          !err\n            ? (DeviceDetails.fromResponseBody(\n                body as Record<string, unknown>,\n                unpacked ? undefined : format\n              ) as DeviceDetails)\n            : undefined\n        );\n      }\n    );\n  }\n\n  list(params: any, callback: PaginatedResultCallback<unknown>) {\n    const rest = this.rest,\n      format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.rest.http.supportsLinkHeaders ? undefined : format,\n      headers = Defaults.defaultGetHeaders(rest.options, { format });\n\n    if (typeof callback !== 'function') {\n      return Utils.promisify(this, 'list', arguments);\n    }\n\n    Utils.mixin(headers, rest.options.headers);\n\n    new PaginatedResource(rest.client, '/push/deviceRegistrations', headers, envelope, async function (\n      body: any,\n      headers: Record<string, string>,\n      unpacked?: boolean\n    ) {\n      return DeviceDetails.fromResponseBody(body, unpacked ? undefined : format);\n    }).get(params, callback);\n  }\n\n  remove(deviceIdOrDetails: any, callback: ErrCallback) {\n    const rest = this.rest,\n      format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultGetHeaders(rest.options, { format }),\n      params = {},\n      deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n\n    if (typeof callback !== 'function') {\n      return Utils.promisify(this, 'remove', arguments);\n    }\n\n    if (typeof deviceId !== 'string' || !deviceId.length) {\n      callback(\n        new ErrorInfo(\n          'First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails',\n          40000,\n          400\n        )\n      );\n      return;\n    }\n\n    Utils.mixin(headers, rest.options.headers);\n\n    if (rest.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    Resource['delete'](\n      rest.client,\n      '/push/deviceRegistrations/' + encodeURIComponent(deviceId),\n      headers,\n      params,\n      null,\n      (err) => callback(err)\n    );\n  }\n\n  removeWhere(params: any, callback: ErrCallback) {\n    const rest = this.rest,\n      format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultGetHeaders(rest.options, { format });\n\n    if (typeof callback !== 'function') {\n      return Utils.promisify(this, 'removeWhere', arguments);\n    }\n\n    Utils.mixin(headers, rest.options.headers);\n\n    if (rest.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    Resource['delete'](rest.client, '/push/deviceRegistrations', headers, params, null, (err) => callback(err));\n  }\n}\n\nclass ChannelSubscriptions {\n  rest: Rest;\n\n  constructor(rest: Rest) {\n    this.rest = rest;\n  }\n\n  save(subscription: Record<string, unknown>, callback: PaginatedResultCallback<unknown>) {\n    const rest = this.rest;\n    const body = PushChannelSubscription.fromValues(subscription);\n    const format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultPostHeaders(rest.options, { format }),\n      params = {};\n\n    if (typeof callback !== 'function') {\n      return Utils.promisify(this, 'save', arguments);\n    }\n\n    Utils.mixin(headers, rest.options.headers);\n\n    if (rest.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    const requestBody = Utils.encodeBody(body, format);\n    Resource.post(\n      rest.client,\n      '/push/channelSubscriptions',\n      requestBody,\n      headers,\n      params,\n      null,\n      function (err, body, headers, unpacked) {\n        callback(\n          err,\n          !err && PushChannelSubscription.fromResponseBody(body as Record<string, any>, unpacked ? undefined : format)\n        );\n      }\n    );\n  }\n\n  list(params: any, callback: PaginatedResultCallback<unknown>) {\n    const rest = this.rest,\n      format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.rest.http.supportsLinkHeaders ? undefined : format,\n      headers = Defaults.defaultGetHeaders(rest.options, { format });\n\n    if (typeof callback !== 'function') {\n      return Utils.promisify(this, 'list', arguments);\n    }\n\n    Utils.mixin(headers, rest.options.headers);\n\n    new PaginatedResource(rest.client, '/push/channelSubscriptions', headers, envelope, async function (\n      body: any,\n      headers: Record<string, string>,\n      unpacked?: boolean\n    ) {\n      return PushChannelSubscription.fromResponseBody(body, unpacked ? undefined : format);\n    }).get(params, callback);\n  }\n\n  removeWhere(params: any, callback: PaginatedResultCallback<unknown>) {\n    const rest = this.rest,\n      format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      headers = Defaults.defaultGetHeaders(rest.options, { format });\n\n    if (typeof callback !== 'function') {\n      return Utils.promisify(this, 'removeWhere', arguments);\n    }\n\n    Utils.mixin(headers, rest.options.headers);\n\n    if (rest.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    Resource['delete'](rest.client, '/push/channelSubscriptions', headers, params, null, (err) => callback(err));\n  }\n\n  /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\n  remove = ChannelSubscriptions.prototype.removeWhere;\n\n  listChannels(params: any, callback: PaginatedResultCallback<unknown>) {\n    const rest = this.rest,\n      format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.rest.http.supportsLinkHeaders ? undefined : format,\n      headers = Defaults.defaultGetHeaders(rest.options, { format });\n\n    if (typeof callback !== 'function') {\n      return Utils.promisify(this, 'listChannels', arguments);\n    }\n\n    Utils.mixin(headers, rest.options.headers);\n\n    if (rest.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\n\n    new PaginatedResource(rest.client, '/push/channels', headers, envelope, async function (\n      body: unknown,\n      headers: Record<string, string>,\n      unpacked?: boolean\n    ) {\n      const parsedBody = (!unpacked && format ? Utils.decodeBody(body, format) : body) as Array<string>;\n\n      for (let i = 0; i < parsedBody.length; i++) {\n        parsedBody[i] = String(parsedBody[i]);\n      }\n      return parsedBody;\n    }).get(params, callback);\n  }\n}\n\nexport default Push;\n", "import * as Utils from './utils';\nimport Logger from './logger';\nimport Platform from 'common/platform';\n\n/* Call the listener, catch any exceptions and log, but continue operation*/\nfunction callListener(eventThis: { event: string }, listener: Function, args: unknown[]) {\n  try {\n    listener.apply(eventThis, args);\n  } catch (e) {\n    Logger.logAction(\n      Logger.LOG_ERROR,\n      'EventEmitter.emit()',\n      'Unexpected listener exception: ' + e + '; stack = ' + (e && (e as Error).stack)\n    );\n  }\n}\n\n/**\n * Remove listeners that match listener\n * @param targetListeners is an array of listener arrays or event objects with arrays of listeners\n * @param listener the listener callback to remove\n * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event\n */\nfunction removeListener(targetListeners: any, listener: Function, eventFilter?: string) {\n  let listeners: Record<string, unknown>;\n  let index;\n  let eventName;\n\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\n    listeners = targetListeners[targetListenersIndex];\n    if (eventFilter) {\n      listeners = listeners[eventFilter] as Record<string, unknown>;\n    }\n\n    if (Utils.isArray(listeners)) {\n      while ((index = Utils.arrIndexOf(listeners, listener)) !== -1) {\n        listeners.splice(index, 1);\n      }\n      /* If events object has an event name key with no listeners then\n\t\t\t\t\tremove the key to stop the list growing indefinitely */\n      if (eventFilter && listeners.length === 0) {\n        delete targetListeners[targetListenersIndex][eventFilter];\n      }\n    } else if (Utils.isObject(listeners)) {\n      /* events */\n      for (eventName in listeners) {\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Utils.isArray(listeners[eventName])) {\n          removeListener([listeners], listener, eventName);\n        }\n      }\n    }\n  }\n}\n\nclass EventEmitter {\n  any: Array<Function>;\n  events: Record<string, Array<Function>>;\n  anyOnce: Array<Function>;\n  eventsOnce: Record<string, Array<Function>>;\n\n  constructor() {\n    this.any = [];\n    this.events = Object.create(null);\n    this.anyOnce = [];\n    this.eventsOnce = Object.create(null);\n  }\n\n  /**\n   * Add an event listener\n   * @param listener the listener to be called\n   */\n  on(listener: Function): void;\n\n  /**\n   * Add an event listener\n   * @param event (optional) the name of the event to listen to\n   * @param listener the listener to be called\n   */\n  on(event: null | string | string[], listener: Function): void;\n\n  on(...args: unknown[]) {\n    if (args.length === 1) {\n      const listener = args[0];\n      if (typeof listener === 'function') {\n        this.any.push(listener);\n      } else {\n        throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\n      }\n    }\n    if (args.length === 2) {\n      const [event, listener] = args;\n      if (typeof listener !== 'function') {\n        throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\n      }\n      if (Utils.isEmptyArg(event)) {\n        this.any.push(listener);\n      } else if (Utils.isArray(event)) {\n        event.forEach((eventName) => {\n          this.on(eventName, listener);\n        });\n      } else {\n        if (typeof event !== 'string') {\n          throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\n        }\n        const listeners = this.events[event] || (this.events[event] = []);\n        listeners.push(listener);\n      }\n    }\n  }\n\n  /**\n   * Remove one or more event listeners\n   * @param listener (optional) the listener to remove. If not\n   *        supplied, all listeners are removed.\n   */\n  off(listener?: Function): void;\n\n  /**\n   * Remove one or more event listeners\n   * @param event (optional) the name of the event whose listener\n   *        is to be removed. If not supplied, the listener is\n   *        treated as an 'any' listener\n   * @param listener (optional) the listener to remove. If not\n   *        supplied, all listeners are removed.\n   */\n  off(event: string | string[] | null, listener?: Function | null): void;\n\n  off(...args: unknown[]) {\n    if (args.length == 0 || (Utils.isEmptyArg(args[0]) && Utils.isEmptyArg(args[1]))) {\n      this.any = [];\n      this.events = Object.create(null);\n      this.anyOnce = [];\n      this.eventsOnce = Object.create(null);\n      return;\n    }\n    const [firstArg, secondArg] = args;\n    let listener: Function | null = null;\n    let event: unknown = null;\n    if (args.length === 1 || !secondArg) {\n      if (typeof firstArg === 'function') {\n        /* we take this to be the listener and treat the event as \"any\" .. */\n        listener = firstArg;\n      } else {\n        event = firstArg;\n      }\n      /* ... or we take event to be the actual event name and listener to be all */\n    } else {\n      if (typeof secondArg !== 'function') {\n        throw new Error('EventEmitter.off(): invalid arguments:' + Platform.Config.inspect(args));\n      }\n      [event, listener] = [firstArg, secondArg];\n    }\n\n    if (listener && Utils.isEmptyArg(event)) {\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\n      return;\n    }\n\n    if (Utils.isArray(event)) {\n      event.forEach((eventName) => {\n        this.off(eventName, listener);\n      });\n      return;\n    }\n\n    /* \"normal\" case where event is an actual event */\n    if (typeof event !== 'string') {\n      throw new Error('EventEmitter.off(): invalid arguments:' + Platform.Config.inspect(args));\n    }\n    if (listener) {\n      removeListener([this.events, this.eventsOnce], listener, event);\n    } else {\n      delete this.events[event];\n      delete this.eventsOnce[event];\n    }\n  }\n\n  /**\n   * Get the array of listeners for a given event; excludes once events\n   * @param event (optional) the name of the event, or none for 'any'\n   * @return array of events, or null if none\n   */\n  listeners(event: string) {\n    if (event) {\n      const listeners = this.events[event] || [];\n      if (this.eventsOnce[event]) Array.prototype.push.apply(listeners, this.eventsOnce[event]);\n      return listeners.length ? listeners : null;\n    }\n    return this.any.length ? this.any : null;\n  }\n\n  /**\n   * Emit an event\n   * @param event the event name\n   * @param args the arguments to pass to the listener\n   */\n  emit(event: string, ...args: unknown[] /* , args... */) {\n    const eventThis = { event };\n    const listeners: Function[] = [];\n\n    if (this.anyOnce.length) {\n      Array.prototype.push.apply(listeners, this.anyOnce);\n      this.anyOnce = [];\n    }\n    if (this.any.length) {\n      Array.prototype.push.apply(listeners, this.any);\n    }\n    const eventsOnceListeners = this.eventsOnce[event];\n    if (eventsOnceListeners) {\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\n      delete this.eventsOnce[event];\n    }\n    const eventsListeners = this.events[event];\n    if (eventsListeners) {\n      Array.prototype.push.apply(listeners, eventsListeners);\n    }\n\n    Utils.arrForEach(listeners, function (listener) {\n      callListener(eventThis, listener, args);\n    });\n  }\n\n  /**\n   * Listen for a single occurrence of an event\n   * @param event the name of the event to listen to\n   */\n  once(event: string): Promise<void>;\n\n  /**\n   * Listen for a single occurrence of any event\n   * @param listener the listener to be called\n   */\n  once(listener: Function): void;\n\n  /**\n   * Listen for a single occurrence of an event\n   * @param event the name of the event to listen to\n   * @param listener the listener to be called\n   */\n  once(event?: string | string[] | null, listener?: Function): void;\n\n  once(...args: unknown[]): void | Promise<void> {\n    const argCount = args.length;\n    if (argCount === 0 || (argCount === 1 && typeof args[0] !== 'function')) {\n      const event = args[0];\n      return new Promise((resolve) => {\n        this.once(event as string | string[] | null, resolve);\n      });\n    }\n\n    const [firstArg, secondArg] = args;\n    if (args.length === 1 && typeof firstArg === 'function') {\n      this.anyOnce.push(firstArg);\n    } else if (Utils.isEmptyArg(firstArg)) {\n      if (typeof secondArg !== 'function') {\n        throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\n      }\n      this.anyOnce.push(secondArg);\n    } else if (Utils.isArray(firstArg)) {\n      const self = this;\n      const listenerWrapper = function (this: any) {\n        const innerArgs = Array.prototype.slice.call(arguments);\n        Utils.arrForEach(firstArg, function (eventName) {\n          self.off(eventName, listenerWrapper);\n        });\n        if (typeof secondArg !== 'function') {\n          throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\n        }\n        secondArg.apply(this, innerArgs);\n      };\n      Utils.arrForEach(firstArg, function (eventName) {\n        self.on(eventName, listenerWrapper);\n      });\n    } else {\n      if (typeof firstArg !== 'string') {\n        throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\n      }\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\n      if (secondArg) {\n        if (typeof secondArg !== 'function') {\n          throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\n        }\n        listeners.push(secondArg);\n      }\n    }\n  }\n\n  /**\n   * Private API\n   *\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\n   * @param targetState the name of the state event to listen to\n   * @param currentState the name of the current state of this object\n   * @param listener the listener to be called\n   * @param listenerArgs\n   */\n  whenState(targetState: string, currentState: string, listener: Function, ...listenerArgs: unknown[]) {\n    const eventThis = { event: targetState };\n\n    if (typeof targetState !== 'string' || typeof currentState !== 'string') {\n      throw 'whenState requires a valid event String argument';\n    }\n    if (typeof listener !== 'function') {\n      return new Promise((resolve) => {\n        EventEmitter.prototype.whenState.apply(\n          this,\n          [targetState, currentState, resolve].concat(listenerArgs as any[]) as any\n        );\n      });\n    }\n    if (targetState === currentState) {\n      callListener(eventThis, listener, listenerArgs);\n    } else {\n      this.once(targetState, listener);\n    }\n  }\n}\n\nexport default EventEmitter;\n", "import Platform from 'common/platform';\nimport Logger from '../util/logger';\nimport ErrorInfo from './errorinfo';\nimport { ChannelOptions } from '../../types/channel';\nimport PresenceMessage from './presencemessage';\nimport * as Utils from '../util/utils';\nimport { Bufferlike as BrowserBufferlike } from '../../../platform/web/lib/util/bufferutils';\nimport * as API from '../../../../ably';\n\nexport type CipherOptions = {\n  channelCipher: {\n    encrypt: Function;\n    algorithm: 'aes';\n  };\n  cipher?: {\n    channelCipher: {\n      encrypt: Function;\n      algorithm: 'aes';\n    };\n  };\n};\n\ntype EncodingDecodingContext = {\n  channelOptions: ChannelOptions;\n  plugins: {\n    vcdiff?: {\n      encrypt: Function;\n      decode: Function;\n    };\n  };\n  baseEncodedPreviousPayload?: Buffer | BrowserBufferlike;\n};\n\nfunction normaliseContext(context: CipherOptions | EncodingDecodingContext | ChannelOptions): EncodingDecodingContext {\n  if (!context || !(context as EncodingDecodingContext).channelOptions) {\n    return {\n      channelOptions: context as ChannelOptions,\n      plugins: {},\n      baseEncodedPreviousPayload: undefined,\n    };\n  }\n  return context as EncodingDecodingContext;\n}\n\nfunction normalizeCipherOptions(options: API.Types.ChannelOptions | null): ChannelOptions {\n  if (options && options.cipher) {\n    if (!Platform.Crypto) throw new Error('Encryption not enabled; use ably.encryption.js instead');\n    const cipher = Platform.Crypto.getCipher(options.cipher);\n    return {\n      cipher: cipher.cipherParams,\n      channelCipher: cipher.cipher,\n    };\n  }\n  return options ?? {};\n}\n\nfunction getMessageSize(msg: Message) {\n  let size = 0;\n  if (msg.name) {\n    size += msg.name.length;\n  }\n  if (msg.clientId) {\n    size += msg.clientId.length;\n  }\n  if (msg.extras) {\n    size += JSON.stringify(msg.extras).length;\n  }\n  if (msg.data) {\n    size += Utils.dataSizeBytes(msg.data);\n  }\n  return size;\n}\n\nclass Message {\n  name?: string;\n  id?: string;\n  timestamp?: number;\n  clientId?: string;\n  connectionId?: string;\n  connectionKey?: string;\n  data?: any;\n  encoding?: string | null;\n  extras?: any;\n  size?: number;\n\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON() {\n    /* encode data to base64 if present and we're returning real JSON;\n     * although msgpack calls toJSON(), we know it is a stringify()\n     * call if it has a non-empty arguments list */\n    let encoding = this.encoding;\n    let data = this.data;\n    if (data && Platform.BufferUtils.isBuffer(data)) {\n      if (arguments.length > 0) {\n        /* stringify call */\n        encoding = encoding ? encoding + '/base64' : 'base64';\n        data = Platform.BufferUtils.base64Encode(data);\n      } else {\n        /* Called by msgpack. toBuffer returns a datatype understandable by\n         * that platform's msgpack implementation (Buffer in node, Uint8Array\n         * in browsers) */\n        data = Platform.BufferUtils.toBuffer(data);\n      }\n    }\n    return {\n      name: this.name,\n      id: this.id,\n      clientId: this.clientId,\n      connectionId: this.connectionId,\n      connectionKey: this.connectionKey,\n      extras: this.extras,\n      encoding,\n      data,\n    };\n  }\n\n  toString(): string {\n    let result = '[Message';\n    if (this.name) result += '; name=' + this.name;\n    if (this.id) result += '; id=' + this.id;\n    if (this.timestamp) result += '; timestamp=' + this.timestamp;\n    if (this.clientId) result += '; clientId=' + this.clientId;\n    if (this.connectionId) result += '; connectionId=' + this.connectionId;\n    if (this.encoding) result += '; encoding=' + this.encoding;\n    if (this.extras) result += '; extras =' + JSON.stringify(this.extras);\n    if (this.data) {\n      if (typeof this.data == 'string') result += '; data=' + this.data;\n      else if (Platform.BufferUtils.isBuffer(this.data))\n        result += '; data (buffer)=' + Platform.BufferUtils.base64Encode(this.data);\n      else result += '; data (json)=' + JSON.stringify(this.data);\n    }\n    if (this.extras) result += '; extras=' + JSON.stringify(this.extras);\n    result += ']';\n    return result;\n  }\n\n  static encrypt(msg: Message | PresenceMessage, options: CipherOptions, callback: Function) {\n    let data = msg.data,\n      encoding = msg.encoding,\n      cipher = options.channelCipher;\n\n    encoding = encoding ? encoding + '/' : '';\n    if (!Platform.BufferUtils.isBuffer(data)) {\n      data = Platform.BufferUtils.utf8Encode(String(data));\n      encoding = encoding + 'utf-8/';\n    }\n    cipher.encrypt(data, function (err: Error, data: unknown) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      msg.data = data;\n      msg.encoding = encoding + 'cipher+' + cipher.algorithm;\n      callback(null, msg);\n    });\n  }\n\n  static encode(msg: Message | PresenceMessage, options: CipherOptions, callback: Function): void {\n    const data = msg.data;\n    const nativeDataType =\n      typeof data == 'string' || Platform.BufferUtils.isBuffer(data) || data === null || data === undefined;\n\n    if (!nativeDataType) {\n      if (Utils.isObject(data) || Utils.isArray(data)) {\n        msg.data = JSON.stringify(data);\n        msg.encoding = msg.encoding ? msg.encoding + '/json' : 'json';\n      } else {\n        throw new ErrorInfo('Data type is unsupported', 40013, 400);\n      }\n    }\n\n    if (options != null && options.cipher) {\n      Message.encrypt(msg, options, callback);\n    } else {\n      callback(null, msg);\n    }\n  }\n\n  static encodeArray(messages: Array<Message>, options: CipherOptions, callback: Function): void {\n    let processed = 0;\n    for (let i = 0; i < messages.length; i++) {\n      Message.encode(messages[i], options, function (err: Error) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        processed++;\n        if (processed == messages.length) {\n          callback(null, messages);\n        }\n      });\n    }\n  }\n\n  static serialize = Utils.encodeBody;\n\n  static async decode(\n    message: Message | PresenceMessage,\n    inputContext: CipherOptions | EncodingDecodingContext | ChannelOptions\n  ): Promise<void> {\n    const context = normaliseContext(inputContext);\n\n    let lastPayload = message.data;\n    const encoding = message.encoding;\n    if (encoding) {\n      const xforms = encoding.split('/');\n      let lastProcessedEncodingIndex,\n        encodingsToProcess = xforms.length,\n        data = message.data;\n\n      let xform = '';\n      try {\n        while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\n          // eslint-disable-next-line security/detect-unsafe-regex\n          const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\n          if (!match) break;\n          xform = match[1];\n          switch (xform) {\n            case 'base64':\n              data = Platform.BufferUtils.base64Decode(String(data));\n              if (lastProcessedEncodingIndex == xforms.length) {\n                lastPayload = data;\n              }\n              continue;\n            case 'utf-8':\n              data = Platform.BufferUtils.utf8Decode(data);\n              continue;\n            case 'json':\n              data = JSON.parse(data);\n              continue;\n            case 'cipher':\n              if (\n                context.channelOptions != null &&\n                context.channelOptions.cipher &&\n                context.channelOptions.channelCipher\n              ) {\n                const xformAlgorithm = match[3],\n                  cipher = context.channelOptions.channelCipher;\n                /* don't attempt to decrypt unless the cipher params are compatible */\n                if (xformAlgorithm != cipher.algorithm) {\n                  throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');\n                }\n                data = await cipher.decrypt(data);\n                continue;\n              } else {\n                throw new Error('Unable to decrypt message; not an encrypted channel');\n              }\n            case 'vcdiff':\n              if (!context.plugins || !context.plugins.vcdiff) {\n                throw new ErrorInfo(\n                  'Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)',\n                  40019,\n                  400\n                );\n              }\n              if (typeof Uint8Array === 'undefined') {\n                throw new ErrorInfo(\n                  'Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)',\n                  40020,\n                  400\n                );\n              }\n              try {\n                let deltaBase = context.baseEncodedPreviousPayload;\n                if (typeof deltaBase === 'string') {\n                  deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\n                }\n\n                // vcdiff expects Uint8Arrays, can't copy with ArrayBuffers.\n                deltaBase = Platform.BufferUtils.toBuffer(deltaBase as Buffer);\n                data = Platform.BufferUtils.toBuffer(data);\n\n                data = Platform.BufferUtils.arrayBufferViewToBuffer(context.plugins.vcdiff.decode(data, deltaBase));\n                lastPayload = data;\n              } catch (e) {\n                throw new ErrorInfo('Vcdiff delta decode failed with ' + e, 40018, 400);\n              }\n              continue;\n            default:\n              throw new Error('Unknown encoding');\n          }\n        }\n      } catch (e) {\n        const err = e as ErrorInfo;\n        throw new ErrorInfo(\n          'Error processing the ' + xform + ' encoding, decoder returned \u2018' + err.message + '\u2019',\n          err.code || 40013,\n          400\n        );\n      } finally {\n        message.encoding =\n          (lastProcessedEncodingIndex as number) <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');\n        message.data = data;\n      }\n    }\n    context.baseEncodedPreviousPayload = lastPayload;\n  }\n\n  static async fromResponseBody(\n    body: Array<Message>,\n    options: ChannelOptions | EncodingDecodingContext,\n    format?: Utils.Format\n  ): Promise<Message[]> {\n    if (format) {\n      body = Utils.decodeBody(body, format);\n    }\n\n    for (let i = 0; i < body.length; i++) {\n      const msg = (body[i] = Message.fromValues(body[i]));\n      try {\n        await Message.decode(msg, options);\n      } catch (e) {\n        Logger.logAction(Logger.LOG_ERROR, 'Message.fromResponseBody()', (e as Error).toString());\n      }\n    }\n    return body;\n  }\n\n  static fromValues(values: unknown): Message {\n    return Object.assign(new Message(), values);\n  }\n\n  static fromValuesArray(values: unknown[]): Message[] {\n    const count = values.length,\n      result = new Array(count);\n    for (let i = 0; i < count; i++) result[i] = Message.fromValues(values[i]);\n    return result;\n  }\n\n  static async fromEncoded(encoded: unknown, inputOptions?: API.Types.ChannelOptions): Promise<Message> {\n    const msg = Message.fromValues(encoded);\n    const options = normalizeCipherOptions(inputOptions ?? null);\n    /* if decoding fails at any point, catch and return the message decoded to\n     * the fullest extent possible */\n    try {\n      await Message.decode(msg, options);\n    } catch (e) {\n      Logger.logAction(Logger.LOG_ERROR, 'Message.fromEncoded()', (e as Error).toString());\n    }\n    return msg;\n  }\n\n  static async fromEncodedArray(encodedArray: Array<unknown>, options?: API.Types.ChannelOptions): Promise<Message[]> {\n    return Promise.all(\n      encodedArray.map(function (encoded) {\n        return Message.fromEncoded(encoded, options);\n      })\n    );\n  }\n\n  /* This should be called on encode()d (and encrypt()d) Messages (as it\n   * assumes the data is a string or buffer) */\n  static getMessagesSize(messages: Message[]): number {\n    let msg,\n      total = 0;\n    for (let i = 0; i < messages.length; i++) {\n      msg = messages[i];\n      total += msg.size || (msg.size = getMessageSize(msg));\n    }\n    return total;\n  }\n}\n\nexport default Message;\n", "import Logger from '../util/logger';\nimport Platform from 'common/platform';\nimport Message, { CipherOptions } from './message';\nimport * as Utils from '../util/utils';\nimport * as API from '../../../../ably';\n\nfunction toActionValue(actionString: string) {\n  return PresenceMessage.Actions.indexOf(actionString);\n}\n\nclass PresenceMessage {\n  action?: string | number;\n  id?: string;\n  timestamp?: number;\n  clientId?: string;\n  connectionId?: string;\n  data?: string | Buffer | Uint8Array;\n  encoding?: string;\n  size?: number;\n\n  static Actions = ['absent', 'present', 'enter', 'leave', 'update'];\n\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\n   * sent by the connection (usually means a leave event sent 15s after a\n   * disconnection). This is useful because synthesized messages cannot be\n   * compared for newness by id lexicographically - RTP2b1\n   */\n  isSynthesized(): boolean {\n    if (!this.id || !this.connectionId) {\n      return true;\n    }\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\n  }\n\n  /* RTP2b2 */\n  parseId(): { connectionId: string; msgSerial: number; index: number } {\n    if (!this.id) throw new Error('parseId(): Presence message does not contain an id');\n    const parts = this.id.split(':');\n    return {\n      connectionId: parts[0],\n      msgSerial: parseInt(parts[1], 10),\n      index: parseInt(parts[2], 10),\n    };\n  }\n\n  /**\n   * Overload toJSON() to intercept JSON.stringify()\n   * @return {*}\n   */\n  toJSON(): {\n    id?: string;\n    clientId?: string;\n    action: number;\n    data: string | Buffer | Uint8Array;\n    encoding?: string;\n  } {\n    /* encode data to base64 if present and we're returning real JSON;\n     * although msgpack calls toJSON(), we know it is a stringify()\n     * call if it has a non-empty arguments list */\n    let data = this.data as string | Buffer | Uint8Array;\n    let encoding = this.encoding;\n    if (data && Platform.BufferUtils.isBuffer(data)) {\n      if (arguments.length > 0) {\n        /* stringify call */\n        encoding = encoding ? encoding + '/base64' : 'base64';\n        data = Platform.BufferUtils.base64Encode(data);\n      } else {\n        /* Called by msgpack. toBuffer returns a datatype understandable by\n         * that platform's msgpack implementation (Buffer in node, Uint8Array\n         * in browsers) */\n        data = Platform.BufferUtils.toBuffer(data);\n      }\n    }\n    return {\n      id: this.id,\n      clientId: this.clientId,\n      /* Convert presence action back to an int for sending to Ably */\n      action: toActionValue(this.action as string),\n      data: data,\n      encoding: encoding,\n    };\n  }\n\n  toString(): string {\n    let result = '[PresenceMessage';\n    result += '; action=' + this.action;\n    if (this.id) result += '; id=' + this.id;\n    if (this.timestamp) result += '; timestamp=' + this.timestamp;\n    if (this.clientId) result += '; clientId=' + this.clientId;\n    if (this.connectionId) result += '; connectionId=' + this.connectionId;\n    if (this.encoding) result += '; encoding=' + this.encoding;\n    if (this.data) {\n      if (typeof this.data == 'string') result += '; data=' + this.data;\n      else if (Platform.BufferUtils.isBuffer(this.data))\n        result += '; data (buffer)=' + Platform.BufferUtils.base64Encode(this.data);\n      else result += '; data (json)=' + JSON.stringify(this.data);\n    }\n    result += ']';\n    return result;\n  }\n\n  static encode = Message.encode;\n  static decode = Message.decode;\n\n  static async fromResponseBody(\n    body: Record<string, unknown>[],\n    options: CipherOptions,\n    format?: Utils.Format\n  ): Promise<PresenceMessage[]> {\n    const messages: PresenceMessage[] = [];\n    if (format) {\n      body = Utils.decodeBody(body, format);\n    }\n\n    for (let i = 0; i < body.length; i++) {\n      const msg = (messages[i] = PresenceMessage.fromValues(body[i], true));\n      try {\n        await PresenceMessage.decode(msg, options);\n      } catch (e) {\n        Logger.logAction(Logger.LOG_ERROR, 'PresenceMessage.fromResponseBody()', (e as Error).toString());\n      }\n    }\n    return messages;\n  }\n\n  static fromValues(values: PresenceMessage | Record<string, unknown>, stringifyAction?: boolean): PresenceMessage {\n    if (stringifyAction) {\n      values.action = PresenceMessage.Actions[values.action as number];\n    }\n    return Object.assign(new PresenceMessage(), values);\n  }\n\n  static fromValuesArray(values: unknown[]): PresenceMessage[] {\n    const count = values.length,\n      result = new Array(count);\n    for (let i = 0; i < count; i++) result[i] = PresenceMessage.fromValues(values[i] as Record<string, unknown>);\n    return result;\n  }\n\n  static async fromEncoded(encoded: unknown, options?: API.Types.ChannelOptions): Promise<PresenceMessage> {\n    const msg = PresenceMessage.fromValues(encoded as PresenceMessage | Record<string, unknown>, true);\n    /* if decoding fails at any point, catch and return the message decoded to\n     * the fullest extent possible */\n    try {\n      await PresenceMessage.decode(msg, options ?? {});\n    } catch (e) {\n      Logger.logAction(Logger.LOG_ERROR, 'PresenceMessage.fromEncoded()', (e as Error).toString());\n    }\n    return msg;\n  }\n\n  static async fromEncodedArray(\n    encodedArray: unknown[],\n    options?: API.Types.ChannelOptions\n  ): Promise<PresenceMessage[]> {\n    return Promise.all(\n      encodedArray.map(function (encoded) {\n        return PresenceMessage.fromEncoded(encoded, options);\n      })\n    );\n  }\n\n  static getMessagesSize = Message.getMessagesSize;\n}\n\nexport default PresenceMessage;\n", "import * as Utils from '../util/utils';\nimport EventEmitter from '../util/eventemitter';\nimport Logger from '../util/logger';\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\nimport PresenceMessage from '../types/presencemessage';\nimport { CipherOptions } from '../types/message';\nimport { PaginatedResultCallback } from '../../types/utils';\nimport Channel from './channel';\nimport RealtimeChannel from './realtimechannel';\nimport Defaults from '../util/defaults';\n\nclass Presence extends EventEmitter {\n  channel: RealtimeChannel | Channel;\n  basePath: string;\n\n  constructor(channel: RealtimeChannel | Channel) {\n    super();\n    this.channel = channel;\n    this.basePath = channel.basePath + '/presence';\n  }\n\n  get(params: any, callback: PaginatedResultCallback<PresenceMessage>): void | Promise<PresenceMessage> {\n    Logger.logAction(Logger.LOG_MICRO, 'Presence.get()', 'channel = ' + this.channel.name);\n    /* params and callback are optional; see if params contains the callback */\n    if (callback === undefined) {\n      if (typeof params == 'function') {\n        callback = params;\n        params = null;\n      } else {\n        return Utils.promisify(this, 'get', arguments);\n      }\n    }\n    const client = this.channel.client,\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.channel.client.http.supportsLinkHeaders ? undefined : format,\n      headers = Defaults.defaultGetHeaders(client.options, { format });\n\n    Utils.mixin(headers, client.options.headers);\n\n    const options = this.channel.channelOptions;\n    new PaginatedResource(client, this.basePath, headers, envelope, async function (\n      body: any,\n      headers: Record<string, string>,\n      unpacked?: boolean\n    ) {\n      return await PresenceMessage.fromResponseBody(body, options as CipherOptions, unpacked ? undefined : format);\n    }).get(params, callback);\n  }\n\n  history(\n    params: any,\n    callback: PaginatedResultCallback<PresenceMessage>\n  ): void | Promise<PaginatedResult<PresenceMessage>> {\n    Logger.logAction(Logger.LOG_MICRO, 'Presence.history()', 'channel = ' + this.channel.name);\n    return this._history(params, callback);\n  }\n\n  _history(\n    params: any,\n    callback: PaginatedResultCallback<PresenceMessage>\n  ): void | Promise<PaginatedResult<PresenceMessage>> {\n    /* params and callback are optional; see if params contains the callback */\n    if (callback === undefined) {\n      if (typeof params == 'function') {\n        callback = params;\n        params = null;\n      } else {\n        return Utils.promisify(this, '_history', [params]);\n      }\n    }\n\n    const rest = this.channel.client,\n      format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.channel.client.http.supportsLinkHeaders ? undefined : format,\n      headers = Defaults.defaultGetHeaders(rest.options, { format });\n\n    Utils.mixin(headers, rest.options.headers);\n\n    const options = this.channel.channelOptions;\n    new PaginatedResource(rest, this.basePath + '/history', headers, envelope, async function (\n      body: any,\n      headers: Record<string, string>,\n      unpacked?: boolean\n    ) {\n      return await PresenceMessage.fromResponseBody(body, options as CipherOptions, unpacked ? undefined : format);\n    }).get(params, callback);\n  }\n}\n\nexport default Presence;\n", "import * as Utils from '../util/utils';\nimport EventEmitter from '../util/eventemitter';\nimport Logger from '../util/logger';\nimport Presence from './presence';\nimport Message, { CipherOptions } from '../types/message';\nimport ErrorInfo from '../types/errorinfo';\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\nimport Resource, { ResourceCallback } from './resource';\nimport { ChannelOptions } from '../../types/channel';\nimport { PaginatedResultCallback, StandardCallback } from '../../types/utils';\nimport * as API from '../../../../ably';\nimport Platform from 'common/platform';\nimport { BaseClient } from './baseclient';\nimport Defaults from '../util/defaults';\n\ninterface RestHistoryParams {\n  start?: number;\n  end?: number;\n  direction?: string;\n  limit?: number;\n}\n\nfunction noop() {}\n\nconst MSG_ID_ENTROPY_BYTES = 9;\n\nfunction allEmptyIds(messages: Array<Message>) {\n  return Utils.arrEvery(messages, function (message: Message) {\n    return !message.id;\n  });\n}\n\nfunction normaliseChannelOptions(options?: ChannelOptions) {\n  const channelOptions = options || {};\n  if (channelOptions.cipher) {\n    if (!Platform.Crypto) throw new Error('Encryption not enabled; use ably.encryption.js instead');\n    const cipher = Platform.Crypto.getCipher(channelOptions.cipher);\n    channelOptions.cipher = cipher.cipherParams;\n    channelOptions.channelCipher = cipher.cipher;\n  } else if ('cipher' in channelOptions) {\n    /* Don't deactivate an existing cipher unless options\n     * has a 'cipher' key that's falsey */\n    channelOptions.cipher = undefined;\n    channelOptions.channelCipher = null;\n  }\n  return channelOptions;\n}\n\nclass Channel extends EventEmitter {\n  client: BaseClient;\n  name: string;\n  basePath: string;\n  presence: Presence;\n  channelOptions: ChannelOptions;\n\n  constructor(client: BaseClient, name: string, channelOptions?: ChannelOptions) {\n    super();\n    Logger.logAction(Logger.LOG_MINOR, 'Channel()', 'started; name = ' + name);\n    this.client = client;\n    this.name = name;\n    this.basePath = '/channels/' + encodeURIComponent(name);\n    this.presence = new Presence(this);\n    this.channelOptions = normaliseChannelOptions(channelOptions);\n  }\n\n  setOptions(options?: ChannelOptions): void {\n    this.channelOptions = normaliseChannelOptions(options);\n  }\n\n  history(\n    params: RestHistoryParams | null,\n    callback: PaginatedResultCallback<Message>\n  ): Promise<PaginatedResult<Message>> | void {\n    Logger.logAction(Logger.LOG_MICRO, 'Channel.history()', 'channel = ' + this.name);\n    /* params and callback are optional; see if params contains the callback */\n    if (callback === undefined) {\n      if (typeof params == 'function') {\n        callback = params;\n        params = null;\n      } else {\n        return Utils.promisify(this, 'history', arguments);\n      }\n    }\n\n    this._history(params, callback);\n  }\n\n  _history(params: RestHistoryParams | null, callback: PaginatedResultCallback<Message>): void {\n    const client = this.client,\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\n      headers = Defaults.defaultGetHeaders(client.options, { format });\n\n    Utils.mixin(headers, client.options.headers);\n\n    const options = this.channelOptions;\n    new PaginatedResource(client, this.basePath + '/messages', headers, envelope, async function (\n      body: any,\n      headers: Record<string, string>,\n      unpacked?: boolean\n    ) {\n      return await Message.fromResponseBody(body, options, unpacked ? undefined : format);\n    }).get(params as Record<string, unknown>, callback);\n  }\n\n  publish(): void | Promise<void> {\n    const argCount = arguments.length,\n      first = arguments[0],\n      second = arguments[1];\n    let callback = arguments[argCount - 1];\n    let messages: Array<Message>;\n    let params: any;\n\n    if (typeof callback !== 'function') {\n      return Utils.promisify(this, 'publish', arguments);\n    }\n\n    if (typeof first === 'string' || first === null) {\n      /* (name, data, ...) */\n      messages = [Message.fromValues({ name: first, data: second })];\n      params = arguments[2];\n    } else if (Utils.isObject(first)) {\n      messages = [Message.fromValues(first)];\n      params = arguments[1];\n    } else if (Utils.isArray(first)) {\n      messages = Message.fromValuesArray(first);\n      params = arguments[1];\n    } else {\n      throw new ErrorInfo(\n        'The single-argument form of publish() expects a message object or an array of message objects',\n        40013,\n        400\n      );\n    }\n\n    if (typeof params !== 'object' || !params) {\n      /* No params supplied (so after-message argument is just the callback or undefined) */\n      params = {};\n    }\n\n    const client = this.client,\n      options = client.options,\n      format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      idempotentRestPublishing = client.options.idempotentRestPublishing,\n      headers = Defaults.defaultPostHeaders(client.options, { format });\n\n    Utils.mixin(headers, options.headers);\n\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\n      const msgIdBase = Utils.randomString(MSG_ID_ENTROPY_BYTES);\n      Utils.arrForEach(messages, function (message, index) {\n        message.id = msgIdBase + ':' + index.toString();\n      });\n    }\n\n    Message.encodeArray(messages, this.channelOptions as CipherOptions, (err: Error) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      /* RSL1i */\n      const size = Message.getMessagesSize(messages),\n        maxMessageSize = options.maxMessageSize;\n      if (size > maxMessageSize) {\n        callback(\n          new ErrorInfo(\n            'Maximum size of messages that can be published at once exceeded ( was ' +\n              size +\n              ' bytes; limit is ' +\n              maxMessageSize +\n              ' bytes)',\n            40009,\n            400\n          )\n        );\n        return;\n      }\n\n      this._publish(Message.serialize(messages, format), headers, params, callback);\n    });\n  }\n\n  _publish(requestBody: unknown, headers: Record<string, string>, params: any, callback: ResourceCallback): void {\n    Resource.post(this.client, this.basePath + '/messages', requestBody, headers, params, null, callback);\n  }\n\n  status(callback?: StandardCallback<API.Types.ChannelDetails>): void | Promise<API.Types.ChannelDetails> {\n    if (typeof callback !== 'function') {\n      return Utils.promisify(this, 'status', []);\n    }\n\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\n    const headers = Defaults.defaultPostHeaders(this.client.options, { format });\n\n    Resource.get<API.Types.ChannelDetails>(this.client, this.basePath, headers, {}, format, callback || noop);\n  }\n}\n\nexport default Channel;\n", "import * as Utils from '../util/utils';\n\ntype MessageValues = {\n  count?: number;\n  data?: number;\n  uncompressedData?: number;\n  failed?: number;\n  refused?: number;\n  category?: Record<string, MessageValues>;\n};\n\ntype ResourceValues = {\n  peak?: number;\n  min?: number;\n  mean?: number;\n  opened?: number;\n  refused?: number;\n};\n\ntype RequestValues = {\n  succeeded?: number;\n  failed?: number;\n  refused?: number;\n};\n\ntype ConnectionTypesValues = {\n  plain?: ResourceValues;\n  tls?: ResourceValues;\n  all?: ResourceValues;\n};\n\ntype MessageTypesValues = {\n  messages?: MessageValues;\n  presence?: MessageValues;\n  all?: MessageValues;\n};\n\ntype MessageTrafficValues = {\n  realtime?: MessageTypesValues;\n  rest?: MessageTypesValues;\n  webhook?: MessageTypesValues;\n  sharedQueue?: MessageTypesValues;\n  externalQueue?: MessageTypesValues;\n  httpEvent?: MessageTypesValues;\n  push?: MessageTypesValues;\n  all?: MessageTypesValues;\n};\n\ntype MessageDirectionsValues = {\n  all?: MessageTypesValues;\n  inbound?: MessageTrafficValues;\n  outbound?: MessageTrafficValues;\n};\n\ntype XchgMessagesValues = {\n  all?: MessageTypesValues;\n  producerPaid?: MessageDirectionsValues;\n  consumerPaid?: MessageDirectionsValues;\n};\n\ntype NotificationsValues = {\n  invalid?: number;\n  attempted?: number;\n  successful?: number;\n  failed?: number;\n};\n\ntype PushValues = {\n  messages?: number;\n  notifications?: NotificationsValues;\n  directPublishes?: number;\n};\n\ntype ProcessedCountValues = {\n  succeeded?: number;\n  skipped?: number;\n  failed?: number;\n};\n\ntype ProcessedMessagesValues = {\n  delta?: Record<string, ProcessedCountValues>;\n};\n\ntype StatsValues = {\n  all?: MessageTypesValues;\n  inbound?: MessageTrafficValues;\n  outbound?: MessageTrafficValues;\n  persisted?: MessageTypesValues;\n  connections?: ConnectionTypesValues;\n  channels?: ResourceValues;\n  apiRequests?: RequestValues;\n  tokenRequests?: RequestValues;\n  xchgProducer?: XchgMessagesValues;\n  xchgConsumer?: XchgMessagesValues;\n  pushStats?: PushValues;\n  processed?: ProcessedMessagesValues;\n  inProgress?: never;\n  unit?: never;\n  intervalId?: never;\n};\n\nclass MessageCount {\n  count?: number;\n  data?: number;\n  uncompressedData?: number;\n  failed?: number;\n  refused?: number;\n\n  constructor(values?: MessageValues) {\n    this.count = (values && values.count) || 0;\n    this.data = (values && values.data) || 0;\n    this.uncompressedData = (values && values.uncompressedData) || 0;\n    this.failed = (values && values.failed) || 0;\n    this.refused = (values && values.refused) || 0;\n  }\n}\n\nclass MessageCategory extends MessageCount {\n  category?: Record<string, MessageCount>;\n  constructor(values?: MessageValues) {\n    super(values);\n    if (values && values.category) {\n      this.category = {};\n      Utils.forInOwnNonNullProperties(values.category, (prop: string) => {\n        (this.category as Record<string, MessageCount>)[prop] = new MessageCount(\n          (values.category as Record<string, MessageCount>)[prop]\n        );\n      });\n    }\n  }\n}\n\nclass ResourceCount {\n  peak?: number;\n  min?: number;\n  mean?: number;\n  opened?: number;\n  refused?: number;\n\n  constructor(values?: ResourceValues) {\n    this.peak = (values && values.peak) || 0;\n    this.min = (values && values.min) || 0;\n    this.mean = (values && values.mean) || 0;\n    this.opened = (values && values.opened) || 0;\n    this.refused = (values && values.refused) || 0;\n  }\n}\n\nclass RequestCount {\n  succeeded?: number;\n  failed?: number;\n  refused?: number;\n\n  constructor(values?: RequestValues) {\n    this.succeeded = (values && values.succeeded) || 0;\n    this.failed = (values && values.failed) || 0;\n    this.refused = (values && values.refused) || 0;\n  }\n}\n\nclass ConnectionTypes {\n  plain?: ResourceCount;\n  tls?: ResourceCount;\n  all?: ResourceCount;\n\n  constructor(values?: ConnectionTypesValues) {\n    this.plain = new ResourceCount(values && values.plain);\n    this.tls = new ResourceCount(values && values.tls);\n    this.all = new ResourceCount(values && values.all);\n  }\n}\n\nclass MessageTypes {\n  messages?: MessageCategory;\n  presence?: MessageCategory;\n  all?: MessageCategory;\n\n  constructor(values?: MessageTypesValues) {\n    this.messages = new MessageCategory(values && values.messages);\n    this.presence = new MessageCategory(values && values.presence);\n    this.all = new MessageCategory(values && values.all);\n  }\n}\n\nclass MessageTraffic {\n  realtime?: MessageTypes;\n  rest?: MessageTypes;\n  webhook?: MessageTypes;\n  sharedQueue?: MessageTypes;\n  externalQueue?: MessageTypes;\n  httpEvent?: MessageTypes;\n  push?: MessageTypes;\n  all?: MessageTypes;\n\n  constructor(values?: MessageTrafficValues) {\n    this.realtime = new MessageTypes(values && values.realtime);\n    this.rest = new MessageTypes(values && values.rest);\n    this.webhook = new MessageTypes(values && values.webhook);\n    this.sharedQueue = new MessageTypes(values && values.sharedQueue);\n    this.externalQueue = new MessageTypes(values && values.externalQueue);\n    this.httpEvent = new MessageTypes(values && values.httpEvent);\n    this.push = new MessageTypes(values && values.push);\n    this.all = new MessageTypes(values && values.all);\n  }\n}\n\nclass MessageDirections {\n  all?: MessageTypes;\n  inbound?: MessageTraffic;\n  outbound?: MessageTraffic;\n\n  constructor(values?: MessageDirectionsValues) {\n    this.all = new MessageTypes(values && values.all);\n    this.inbound = new MessageTraffic(values && values.inbound);\n    this.outbound = new MessageTraffic(values && values.outbound);\n  }\n}\n\nclass XchgMessages {\n  all?: MessageTypes;\n  producerPaid?: MessageDirections;\n  consumerPaid?: MessageDirections;\n\n  constructor(values?: XchgMessagesValues) {\n    this.all = new MessageTypes(values && values.all);\n    this.producerPaid = new MessageDirections(values && values.producerPaid);\n    this.consumerPaid = new MessageDirections(values && values.consumerPaid);\n  }\n}\n\nclass PushStats {\n  messages?: number;\n  notifications?: NotificationsValues;\n  directPublishes?: number;\n\n  constructor(values?: PushValues) {\n    this.messages = (values && values.messages) || 0;\n    const notifications = values && values.notifications;\n    this.notifications = {\n      invalid: (notifications && notifications.invalid) || 0,\n      attempted: (notifications && notifications.attempted) || 0,\n      successful: (notifications && notifications.successful) || 0,\n      failed: (notifications && notifications.failed) || 0,\n    };\n    this.directPublishes = (values && values.directPublishes) || 0;\n  }\n}\n\nclass ProcessedCount {\n  succeeded?: number;\n  skipped?: number;\n  failed?: number;\n\n  constructor(values: ProcessedCountValues) {\n    this.succeeded = (values && values.succeeded) || 0;\n    this.skipped = (values && values.skipped) || 0;\n    this.failed = (values && values.failed) || 0;\n  }\n}\n\nclass ProcessedMessages {\n  delta?: Record<string, ProcessedCount>;\n\n  constructor(values?: ProcessedMessagesValues) {\n    this.delta = undefined;\n    if (values && values.delta) {\n      this.delta = {};\n      Utils.forInOwnNonNullProperties(values.delta, (prop: string) => {\n        (this.delta as Record<string, ProcessedCount>)[prop] = new ProcessedCount(\n          (values.delta as Record<string, ProcessedCountValues>)[prop]\n        );\n      });\n    }\n  }\n}\n\nclass Stats extends MessageDirections {\n  persisted?: MessageTypes;\n  connections?: ConnectionTypes;\n  channels?: ResourceCount;\n  apiRequests?: RequestCount;\n  tokenRequests?: RequestCount;\n  xchgProducer?: XchgMessages;\n  xchgConsumer?: XchgMessages;\n  push?: PushStats;\n  processed?: ProcessedMessages;\n  inProgress?: never;\n  unit?: never;\n  intervalId?: never;\n\n  constructor(values?: StatsValues) {\n    super(values as MessageDirectionsValues);\n    this.persisted = new MessageTypes(values && values.persisted);\n    this.connections = new ConnectionTypes(values && values.connections);\n    this.channels = new ResourceCount(values && values.channels);\n    this.apiRequests = new RequestCount(values && values.apiRequests);\n    this.tokenRequests = new RequestCount(values && values.tokenRequests);\n    this.xchgProducer = new XchgMessages(values && values.xchgProducer);\n    this.xchgConsumer = new XchgMessages(values && values.xchgConsumer);\n    this.push = new PushStats(values && values.pushStats);\n    this.processed = new ProcessedMessages(values && values.processed);\n    this.inProgress = (values && values.inProgress) || undefined;\n    this.unit = (values && values.unit) || undefined;\n    this.intervalId = (values && values.intervalId) || undefined;\n  }\n\n  static fromValues(values: StatsValues): Stats {\n    return new Stats(values);\n  }\n}\n\nexport default Stats;\n", "import * as Utils from '../util/utils';\nimport Logger, { LoggerOptions } from '../util/logger';\nimport Push from './push';\nimport PaginatedResource, { HttpPaginatedResponse, PaginatedResult } from './paginatedresource';\nimport Channel from './channel';\nimport ErrorInfo from '../types/errorinfo';\nimport Stats from '../types/stats';\nimport HttpMethods from '../../constants/HttpMethods';\nimport { ChannelOptions } from '../../types/channel';\nimport { PaginatedResultCallback, StandardCallback } from '../../types/utils';\nimport { ErrnoException, IHttp, RequestParams } from '../../types/http';\nimport { NormalisedClientOptions } from '../../types/ClientOptions';\n\nimport Platform from '../../platform';\nimport { BaseClient } from './baseclient';\nimport Defaults from '../util/defaults';\n\nconst noop = function () {};\n\nclass Rest {\n  channels: Channels;\n  push: Push;\n  client: BaseClient;\n  http: IHttp;\n  options: NormalisedClientOptions;\n\n  constructor(client: BaseClient) {\n    this.client = client;\n    this.http = client.http;\n    this.options = client.options;\n    this.channels = new Channels(this.client);\n    this.push = new Push(this);\n  }\n\n  stats(\n    params: RequestParams,\n    callback: StandardCallback<PaginatedResult<Stats>>\n  ): Promise<PaginatedResult<Stats>> | void {\n    /* params and callback are optional; see if params contains the callback */\n    if (callback === undefined) {\n      if (typeof params == 'function') {\n        callback = params;\n        params = null;\n      } else {\n        return Utils.promisify(this, 'stats', [params]) as Promise<PaginatedResult<Stats>>;\n      }\n    }\n    const headers = Defaults.defaultGetHeaders(this.options),\n      format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.http.supportsLinkHeaders ? undefined : format;\n\n    Utils.mixin(headers, this.options.headers);\n\n    new PaginatedResource(this.client, '/stats', headers, envelope, function (\n      body: unknown,\n      headers: Record<string, string>,\n      unpacked?: boolean\n    ) {\n      const statsValues = unpacked ? body : JSON.parse(body as string);\n      for (let i = 0; i < statsValues.length; i++) statsValues[i] = Stats.fromValues(statsValues[i]);\n      return statsValues;\n    }).get(params as Record<string, string>, callback);\n  }\n\n  time(params?: RequestParams | StandardCallback<number>, callback?: StandardCallback<number>): Promise<number> | void {\n    /* params and callback are optional; see if params contains the callback */\n    if (callback === undefined) {\n      if (typeof params == 'function') {\n        callback = params;\n        params = null;\n      } else {\n        return Utils.promisify(this, 'time', [params]) as Promise<number>;\n      }\n    }\n\n    const _callback = callback || noop;\n\n    const headers = Defaults.defaultGetHeaders(this.options);\n    if (this.options.headers) Utils.mixin(headers, this.options.headers);\n    const timeUri = (host: string) => {\n      return this.client.authority(host) + '/time';\n    };\n    this.http.do(\n      HttpMethods.Get,\n      this.client,\n      timeUri,\n      headers,\n      null,\n      params as RequestParams,\n      (\n        err?: ErrorInfo | ErrnoException | null,\n        res?: unknown,\n        headers?: Record<string, string>,\n        unpacked?: boolean\n      ) => {\n        if (err) {\n          _callback(err);\n          return;\n        }\n        if (!unpacked) res = JSON.parse(res as string);\n        const time = (res as number[])[0];\n        if (!time) {\n          _callback(new ErrorInfo('Internal error (unexpected result type from GET /time)', 50000, 500));\n          return;\n        }\n        /* calculate time offset only once for this device by adding to the prototype */\n        this.client.serverTimeOffset = time - Utils.now();\n        _callback(null, time);\n      }\n    );\n  }\n\n  request(\n    method: string,\n    path: string,\n    version: number,\n    params: RequestParams,\n    body: unknown,\n    customHeaders: Record<string, string>,\n    callback: StandardCallback<HttpPaginatedResponse<unknown>>\n  ): Promise<HttpPaginatedResponse<unknown>> | void {\n    const useBinary = this.options.useBinaryProtocol,\n      encoder = useBinary ? Platform.Config.msgpack.encode : JSON.stringify,\n      decoder = useBinary ? Platform.Config.msgpack.decode : JSON.parse,\n      format = useBinary ? Utils.Format.msgpack : Utils.Format.json,\n      envelope = this.http.supportsLinkHeaders ? undefined : format;\n    params = params || {};\n    const _method = method.toLowerCase() as HttpMethods;\n    const headers =\n      _method == 'get'\n        ? Defaults.defaultGetHeaders(this.options, { format, protocolVersion: version })\n        : Defaults.defaultPostHeaders(this.options, { format, protocolVersion: version });\n\n    if (callback === undefined) {\n      return Utils.promisify(this, 'request', [method, path, version, params, body, customHeaders]) as Promise<\n        HttpPaginatedResponse<unknown>\n      >;\n    }\n\n    if (typeof body !== 'string') {\n      body = encoder(body);\n    }\n    Utils.mixin(headers, this.options.headers);\n    if (customHeaders) {\n      Utils.mixin(headers, customHeaders);\n    }\n    const paginatedResource = new PaginatedResource(\n      this.client,\n      path,\n      headers,\n      envelope,\n      async function (resbody: unknown, headers: Record<string, string>, unpacked?: boolean) {\n        return Utils.ensureArray(unpacked ? resbody : decoder(resbody as string & Buffer));\n      },\n      /* useHttpPaginatedResponse: */ true\n    );\n\n    if (!Utils.arrIn(Platform.Http.methods, _method)) {\n      throw new ErrorInfo('Unsupported method ' + _method, 40500, 405);\n    }\n\n    if (Utils.arrIn(Platform.Http.methodsWithBody, _method)) {\n      paginatedResource[_method as HttpMethods.Post](params, body, callback as PaginatedResultCallback<unknown>);\n    } else {\n      paginatedResource[_method as HttpMethods.Get | HttpMethods.Delete](\n        params,\n        callback as PaginatedResultCallback<unknown>\n      );\n    }\n  }\n\n  setLog(logOptions: LoggerOptions): void {\n    Logger.setLog(logOptions.level, logOptions.handler);\n  }\n}\n\nclass Channels {\n  client: BaseClient;\n  all: Record<string, Channel>;\n\n  constructor(client: BaseClient) {\n    this.client = client;\n    this.all = Object.create(null);\n  }\n\n  get(name: string, channelOptions?: ChannelOptions) {\n    name = String(name);\n    let channel = this.all[name];\n    if (!channel) {\n      this.all[name] = channel = new Channel(this.client, name, channelOptions);\n    } else if (channelOptions) {\n      channel.setOptions(channelOptions);\n    }\n\n    return channel;\n  }\n\n  /* Included to support certain niche use-cases; most users should ignore this.\n   * Please do not use this unless you know what you're doing */\n  release(name: string) {\n    delete this.all[String(name)];\n  }\n}\n\nexport default Rest;\n", "/**\n * Copied from https://gist.github.com/stevendesu/2d52f7b5e1f1184af3b667c0b5e054b8\n *\n * \"A simple, open-source, HMAC-SHA256 implementation in pure JavaScript. Designed for efficient minification.\"\n *\n * I asked about licensing, and the author said:\n *\n * > Feel free to use it however you'd like \uD83D\uDE04 As the gist title indicates,\n * > this is \"a simple open source implementation\". Feel free to choose whatever\n * > license you find most permissible, but I offer no warranty for the code.\n * > It's 100% free to do with as you please.\n */\n\n// To ensure cross-browser support even without a proper SubtleCrypto\n// impelmentation (or without access to the impelmentation, as is the case with\n// Chrome loaded over HTTP instead of HTTPS), this library can create SHA-256\n// HMAC signatures using nothing but raw JavaScript\n\n/* eslint-disable no-magic-numbers, id-length, no-param-reassign, new-cap */\n\n// By giving internal functions names that we can mangle, future calls to\n// them are reduced to a single byte (minor space savings in minified file)\nvar uint8Array = Uint8Array;\nvar uint32Array = Uint32Array;\nvar pow = Math.pow;\n\n// Will be initialized below\n// Using a Uint32Array instead of a simple array makes the minified code\n// a bit bigger (we lose our `unshift()` hack), but comes with huge\n// performance gains\nvar DEFAULT_STATE = new uint32Array(8);\nvar ROUND_CONSTANTS: number[] = [];\n\n// Reusable object for expanded message\n// Using a Uint32Array instead of a simple array makes the minified code\n// 7 bytes larger, but comes with huge performance gains\nvar M = new uint32Array(64);\n\n// After minification the code to compute the default state and round\n// constants is smaller than the output. More importantly, this serves as a\n// good educational aide for anyone wondering where the magic numbers come\n// from. No magic numbers FTW!\nfunction getFractionalBits(n: number) {\n  return ((n - (n | 0)) * pow(2, 32)) | 0;\n}\n\nvar n = 2,\n  nPrime = 0;\nwhile (nPrime < 64) {\n  // isPrime() was in-lined from its original function form to save\n  // a few bytes\n  var isPrime = true;\n  // Math.sqrt() was replaced with pow(n, 1/2) to save a few bytes\n  // var sqrtN = pow(n, 1 / 2);\n  // So technically to determine if a number is prime you only need to\n  // check numbers up to the square root. However this function only runs\n  // once and we're only computing the first 64 primes (up to 311), so on\n  // any modern CPU this whole function runs in a couple milliseconds.\n  // By going to n / 2 instead of sqrt(n) we net 8 byte savings and no\n  // scaling performance cost\n  for (var factor = 2; factor <= n / 2; factor++) {\n    if (n % factor === 0) {\n      isPrime = false;\n    }\n  }\n  if (isPrime) {\n    if (nPrime < 8) {\n      DEFAULT_STATE[nPrime] = getFractionalBits(pow(n, 1 / 2));\n    }\n    ROUND_CONSTANTS[nPrime] = getFractionalBits(pow(n, 1 / 3));\n\n    nPrime++;\n  }\n\n  n++;\n}\n\n// For cross-platform support we need to ensure that all 32-bit words are\n// in the same endianness. A UTF-8 TextEncoder will return BigEndian data,\n// so upon reading or writing to our ArrayBuffer we'll only swap the bytes\n// if our system is LittleEndian (which is about 99% of CPUs)\nvar LittleEndian = !!new uint8Array(new uint32Array([1]).buffer)[0];\n\nfunction convertEndian(word: number) {\n  if (LittleEndian) {\n    return (\n      // byte 1 -> byte 4\n      (word >>> 24) |\n      // byte 2 -> byte 3\n      (((word >>> 16) & 0xff) << 8) |\n      // byte 3 -> byte 2\n      ((word & 0xff00) << 8) |\n      // byte 4 -> byte 1\n      (word << 24)\n    );\n  } else {\n    return word;\n  }\n}\n\nfunction rightRotate(word: number, bits: number) {\n  return (word >>> bits) | (word << (32 - bits));\n}\n\nfunction sha256(data: Uint8Array) {\n  // Copy default state\n  var STATE = DEFAULT_STATE.slice();\n\n  // Caching this reduces occurrences of \".length\" in minified JavaScript\n  // 3 more byte savings! :D\n  var legth = data.length;\n\n  // Pad data\n  var bitLength = legth * 8;\n  var newBitLength = 512 - ((bitLength + 64) % 512) - 1 + bitLength + 65;\n\n  // \"bytes\" and \"words\" are stored BigEndian\n  var bytes = new uint8Array(newBitLength / 8);\n  var words = new uint32Array(bytes.buffer);\n\n  bytes.set(data, 0);\n  // Append a 1\n  bytes[legth] = 0b10000000;\n  // Store length in BigEndian\n  words[words.length - 1] = convertEndian(bitLength);\n\n  // Loop iterator (avoid two instances of \"var\") -- saves 2 bytes\n  var round;\n\n  // Process blocks (512 bits / 64 bytes / 16 words at a time)\n  for (var block = 0; block < newBitLength / 32; block += 16) {\n    var workingState = STATE.slice();\n\n    // Rounds\n    for (round = 0; round < 64; round++) {\n      var MRound;\n      // Expand message\n      if (round < 16) {\n        // Convert to platform Endianness for later math\n        MRound = convertEndian(words[block + round]);\n      } else {\n        var gamma0x = M[round - 15];\n        var gamma1x = M[round - 2];\n        MRound =\n          M[round - 7] +\n          M[round - 16] +\n          (rightRotate(gamma0x, 7) ^ rightRotate(gamma0x, 18) ^ (gamma0x >>> 3)) +\n          (rightRotate(gamma1x, 17) ^ rightRotate(gamma1x, 19) ^ (gamma1x >>> 10));\n      }\n\n      // M array matches platform endianness\n      M[round] = MRound |= 0;\n\n      // Computation\n      var t1 =\n        (rightRotate(workingState[4], 6) ^ rightRotate(workingState[4], 11) ^ rightRotate(workingState[4], 25)) +\n        ((workingState[4] & workingState[5]) ^ (~workingState[4] & workingState[6])) +\n        workingState[7] +\n        MRound +\n        ROUND_CONSTANTS[round];\n      var t2 =\n        (rightRotate(workingState[0], 2) ^ rightRotate(workingState[0], 13) ^ rightRotate(workingState[0], 22)) +\n        ((workingState[0] & workingState[1]) ^ (workingState[2] & (workingState[0] ^ workingState[1])));\n      for (var i = 7; i > 0; i--) {\n        workingState[i] = workingState[i - 1];\n      }\n      workingState[0] = (t1 + t2) | 0;\n      workingState[4] = (workingState[4] + t1) | 0;\n    }\n\n    // Update state\n    for (round = 0; round < 8; round++) {\n      STATE[round] = (STATE[round] + workingState[round]) | 0;\n    }\n  }\n\n  // Finally the state needs to be converted to BigEndian for output\n  // And we want to return a Uint8Array, not a Uint32Array\n  return new uint8Array(\n    new uint32Array(\n      STATE.map(function (val) {\n        return convertEndian(val);\n      })\n    ).buffer\n  );\n}\n\nexport function hmac(key: Uint8Array, data: Uint8Array) {\n  if (key.length > 64) key = sha256(key);\n\n  if (key.length < 64) {\n    const tmp = new Uint8Array(64);\n    tmp.set(key, 0);\n    key = tmp;\n  }\n\n  // Generate inner and outer keys\n  var innerKey = new Uint8Array(64);\n  var outerKey = new Uint8Array(64);\n  for (var i = 0; i < 64; i++) {\n    innerKey[i] = 0x36 ^ key[i];\n    outerKey[i] = 0x5c ^ key[i];\n  }\n\n  // Append the innerKey\n  var msg = new Uint8Array(data.length + 64);\n  msg.set(innerKey, 0);\n  msg.set(data, 64);\n\n  // Has the previous message and append the outerKey\n  var result = new Uint8Array(64 + 32);\n  result.set(outerKey, 0);\n  result.set(sha256(msg), 64);\n\n  // Hash the previous message\n  return sha256(result);\n}\n", "import Platform from 'common/platform';\nimport IBufferUtils from 'common/types/IBufferUtils';\nimport { hmac as hmacSha256 } from './hmac-sha256';\n\n/* Most BufferUtils methods that return a binary object return an ArrayBuffer\n * The exception is toBuffer, which returns a Uint8Array (and won't work on\n * browsers too old to support it) */\n\nexport type Bufferlike = BufferSource;\nexport type Output = Bufferlike;\nexport type ToBufferOutput = Uint8Array;\n\nclass BufferUtils implements IBufferUtils<Bufferlike, Output, ToBufferOutput> {\n  base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  hexCharSet = '0123456789abcdef';\n\n  // // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js\n  uint8ViewToBase64(bytes: Uint8Array) {\n    let base64 = '';\n    const encodings = this.base64CharSet;\n\n    const byteLength = bytes.byteLength;\n    const byteRemainder = byteLength % 3;\n    const mainLength = byteLength - byteRemainder;\n\n    let a, b, c, d;\n    let chunk;\n\n    // Main loop deals with bytes in chunks of 3\n    for (let i = 0; i < mainLength; i = i + 3) {\n      // Combine the three bytes into a single integer\n      chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n\n      // Use bitmasks to extract 6-bit segments from the triplet\n      a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n      b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n      c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n      d = chunk & 63; // 63       = 2^6 - 1\n\n      // Convert the raw binary segments to the appropriate ASCII encoding\n      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n    }\n\n    // Deal with the remaining bytes and padding\n    if (byteRemainder == 1) {\n      chunk = bytes[mainLength];\n\n      a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n\n      // Set the 4 least significant bits to zero\n      b = (chunk & 3) << 4; // 3   = 2^2 - 1\n\n      base64 += encodings[a] + encodings[b] + '==';\n    } else if (byteRemainder == 2) {\n      chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\n\n      a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n      b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n\n      // Set the 2 least significant bits to zero\n      c = (chunk & 15) << 2; // 15    = 2^4 - 1\n\n      base64 += encodings[a] + encodings[b] + encodings[c] + '=';\n    }\n\n    return base64;\n  }\n\n  base64ToArrayBuffer(base64: string) {\n    const binary_string = atob?.(base64) as string; // this will always be defined in browser so it's safe to cast\n    const len = binary_string.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n      const ascii = binary_string.charCodeAt(i);\n      bytes[i] = ascii;\n    }\n    return bytes.buffer;\n  }\n\n  isBuffer(buffer: unknown): buffer is Bufferlike {\n    return buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\n  }\n\n  /* In browsers, returns a Uint8Array */\n  toBuffer(buffer: Bufferlike): ToBufferOutput {\n    if (!ArrayBuffer) {\n      throw new Error(\"Can't convert to Buffer: browser does not support the necessary types\");\n    }\n\n    if (buffer instanceof ArrayBuffer) {\n      return new Uint8Array(buffer);\n    }\n\n    if (ArrayBuffer.isView(buffer)) {\n      return new Uint8Array(buffer.buffer);\n    }\n\n    throw new Error('BufferUtils.toBuffer expected an ArrayBuffer or a view onto one');\n  }\n\n  toArrayBuffer(buffer: Bufferlike): ArrayBuffer {\n    if (buffer instanceof ArrayBuffer) {\n      return buffer;\n    }\n    return this.toBuffer(buffer).buffer;\n  }\n\n  base64Encode(buffer: Bufferlike) {\n    return this.uint8ViewToBase64(this.toBuffer(buffer));\n  }\n\n  base64Decode(str: string): Output {\n    if (ArrayBuffer && Platform.Config.atob) {\n      return this.base64ToArrayBuffer(str);\n    } else {\n      throw new Error('Expected ArrayBuffer to exist and Platform.Config.atob to be configured');\n    }\n  }\n\n  hexEncode(buffer: Bufferlike) {\n    const arrayBuffer =\n      buffer instanceof ArrayBuffer\n        ? buffer\n        : buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n    const uint8Array = new Uint8Array(arrayBuffer);\n    return uint8Array.reduce((accum, byte) => accum + byte.toString(16).padStart(2, '0'), '');\n  }\n\n  hexDecode(hexEncodedBytes: string) {\n    if (hexEncodedBytes.length % 2 !== 0) {\n      throw new Error(\"Can't create a byte array from a hex string of odd length\");\n    }\n\n    const uint8Array = new Uint8Array(hexEncodedBytes.length / 2);\n\n    for (let i = 0; i < uint8Array.length; i++) {\n      uint8Array[i] = parseInt(hexEncodedBytes.slice(2 * i, 2 * (i + 1)), 16);\n    }\n\n    return uint8Array.buffer.slice(uint8Array.byteOffset, uint8Array.byteOffset + uint8Array.byteLength);\n  }\n\n  utf8Encode(string: string) {\n    if (Platform.Config.TextEncoder) {\n      return new Platform.Config.TextEncoder().encode(string).buffer;\n    } else {\n      throw new Error('Expected TextEncoder to be configured');\n    }\n  }\n\n  /* For utf8 decoding we apply slightly stricter input validation than to\n   * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from\n   * can take (in particular allowing strings, which are just interpreted as\n   * binary); here we ensure that the input is actually a buffer since trying\n   * to utf8-decode a string to another string is almost certainly a mistake */\n  utf8Decode(buffer: Bufferlike) {\n    if (!this.isBuffer(buffer)) {\n      throw new Error('Expected input of utf8decode to be an arraybuffer or typed array');\n    }\n    if (TextDecoder) {\n      return new TextDecoder().decode(buffer);\n    } else {\n      throw new Error('Expected TextDecoder to be configured');\n    }\n  }\n\n  areBuffersEqual(buffer1: Bufferlike, buffer2: Bufferlike) {\n    if (!buffer1 || !buffer2) return false;\n    const arrayBuffer1 = this.toArrayBuffer(buffer1);\n    const arrayBuffer2 = this.toArrayBuffer(buffer2);\n\n    if (arrayBuffer1.byteLength != arrayBuffer2.byteLength) return false;\n\n    const bytes1 = new Uint8Array(arrayBuffer1);\n    const bytes2 = new Uint8Array(arrayBuffer2);\n\n    for (var i = 0; i < bytes1.length; i++) {\n      if (bytes1[i] != bytes2[i]) return false;\n    }\n    return true;\n  }\n\n  byteLength(buffer: Bufferlike) {\n    if (buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)) {\n      return buffer.byteLength;\n    }\n    return -1;\n  }\n\n  /* Returns ArrayBuffer on browser and Buffer on Node.js */\n  arrayBufferViewToBuffer(arrayBufferView: ArrayBufferView) {\n    return arrayBufferView.buffer;\n  }\n\n  hmacSha256(message: Bufferlike, key: Bufferlike): Output {\n    return hmacSha256(this.toBuffer(key), this.toBuffer(message));\n  }\n}\n\nexport default new BufferUtils();\n", "import Logger from '../../../../common/lib/util/logger';\nimport ErrorInfo from 'common/lib/types/errorinfo';\nimport * as API from '../../../../../ably';\nimport ICryptoStatic, { IGetCipherParams } from '../../../../common/types/ICryptoStatic';\nimport ICipher from '../../../../common/types/ICipher';\nimport { CryptoDataTypes } from '../../../../common/types/cryptoDataTypes';\nimport BufferUtils, { Bufferlike, Output as BufferUtilsOutput } from './bufferutils';\nimport { IPlatformConfig } from 'common/types/IPlatformConfig';\n\n// The type to which ./msgpack.ts deserializes elements of the `bin` or `ext` type\ntype MessagePackBinaryType = ArrayBuffer;\n\ntype IV = CryptoDataTypes.IV<BufferUtilsOutput>;\ntype InputPlaintext = CryptoDataTypes.InputPlaintext<Bufferlike, BufferUtilsOutput>;\ntype OutputCiphertext = ArrayBuffer;\ntype InputCiphertext = CryptoDataTypes.InputCiphertext<MessagePackBinaryType, BufferUtilsOutput>;\ntype OutputPlaintext = ArrayBuffer;\n\nvar CryptoFactory = function (config: IPlatformConfig, bufferUtils: typeof BufferUtils) {\n  var DEFAULT_ALGORITHM = 'aes';\n  var DEFAULT_KEYLENGTH = 256; // bits\n  var DEFAULT_MODE = 'cbc';\n  var DEFAULT_BLOCKLENGTH = 16; // bytes\n  var DEFAULT_BLOCKLENGTH_WORDS = 4; // 32-bit words\n  var UINT32_SUP = 0x100000000;\n\n  /**\n   * Internal: generate an array of secure random data corresponding to the given length of bytes\n   * @param bytes\n   * @param callback\n   */\n  var generateRandom: (byteLength: number, callback: (error: Error | null, result: ArrayBuffer | null) => void) => void;\n  if (config.getRandomArrayBuffer) {\n    generateRandom = config.getRandomArrayBuffer;\n  } else if (typeof Uint32Array !== 'undefined' && config.getRandomValues) {\n    var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);\n    generateRandom = function (bytes, callback) {\n      var words = bytes / 4,\n        nativeArray = words == DEFAULT_BLOCKLENGTH_WORDS ? blockRandomArray : new Uint32Array(words);\n      config.getRandomValues!(nativeArray, function (err) {\n        if (typeof callback !== 'undefined') {\n          callback(err, bufferUtils.toArrayBuffer(nativeArray));\n        }\n      });\n    };\n  } else {\n    generateRandom = function (bytes, callback) {\n      Logger.logAction(\n        Logger.LOG_MAJOR,\n        'Ably.Crypto.generateRandom()',\n        'Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()'\n      );\n      var words = bytes / 4,\n        array = new Uint32Array(words);\n      for (var i = 0; i < words; i++) {\n        array[i] = Math.floor(Math.random() * UINT32_SUP);\n      }\n\n      callback(null, bufferUtils.toArrayBuffer(array));\n    };\n  }\n\n  /**\n   * Internal: checks that the cipherParams are a valid combination. Currently\n   * just checks that the calculated keyLength is a valid one for aes-cbc\n   */\n  function validateCipherParams(params: API.Types.CipherParams) {\n    if (params.algorithm === 'aes' && params.mode === 'cbc') {\n      if (params.keyLength === 128 || params.keyLength === 256) {\n        return;\n      }\n      throw new Error(\n        'Unsupported key length ' +\n          params.keyLength +\n          ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)'\n      );\n    }\n  }\n\n  function normaliseBase64(string: string) {\n    /* url-safe base64 strings use _ and - instread of / and + */\n    return string.replace('_', '/').replace('-', '+');\n  }\n\n  function isCipherParams(\n    params: API.Types.CipherParams | API.Types.CipherParamOptions\n  ): params is API.Types.CipherParams {\n    // Although API.Types.CipherParams is an interface, the documentation for its `key` property makes it clear that the only valid way to form one is by using getDefaultParams. The implementation of getDefaultParams returns an instance of CipherParams.\n    return params instanceof CipherParams;\n  }\n\n  /**\n   * A class encapsulating the client-specifiable parameters for\n   * the cipher.\n   *\n   * algorithm is the name of the algorithm in the default system provider,\n   * or the lower-cased version of it; eg \"aes\" or \"AES\".\n   *\n   * Clients are recommended to not call this directly, but instead to use the\n   * Crypto.getDefaultParams helper, which will fill in any fields not supplied\n   * with default values and validation the result.\n   */\n  class CipherParams implements API.Types.CipherParams {\n    algorithm: string;\n    keyLength: number;\n    mode: string;\n    key: ArrayBuffer;\n\n    constructor(algorithm: string, keyLength: number, mode: string, key: ArrayBuffer) {\n      this.algorithm = algorithm;\n      this.keyLength = keyLength;\n      this.mode = mode;\n      this.key = key;\n    }\n  }\n\n  /**\n   * Utility classes and interfaces for message payload encryption.\n   *\n   * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits\n   * but supporting other keylengths. Other algorithms and chaining modes are\n   * not supported directly, but supportable by extending/implementing the base\n   * classes and interfaces here.\n   *-\n   * Secure random data for creation of Initialization Vectors (IVs) and keys\n   * is obtained from window.crypto.getRandomValues if available, or from\n   * Math.random() if not. Clients who do not want to depend on Math.random()\n   * should polyfill window.crypto.getRandomValues with a library that seeds\n   * a PRNG with real entropy.\n   *\n   * Each message payload is encrypted with an IV in CBC mode, and the IV is\n   * concatenated with the resulting raw ciphertext to construct the \"ciphertext\"\n   * data passed to the recipient.\n   */\n  class Crypto {\n    static CipherParams = CipherParams;\n\n    /**\n     * Obtain a complete CipherParams instance from the provided params, filling\n     * in any not provided with default values, calculating a keyLength from\n     * the supplied key, and validating the result.\n     * @param params an object containing at a minimum a `key` key with value the\n     * key, as either a binary or a base64-encoded string.\n     * May optionally also contain: algorithm (defaults to AES),\n     * mode (defaults to 'cbc')\n     */\n    static getDefaultParams(params: API.Types.CipherParamOptions) {\n      var key: ArrayBuffer;\n\n      if (!params.key) {\n        throw new Error('Crypto.getDefaultParams: a key is required');\n      }\n\n      if (typeof params.key === 'string') {\n        key = bufferUtils.toArrayBuffer(bufferUtils.base64Decode(normaliseBase64(params.key)));\n      } else if (params.key instanceof ArrayBuffer) {\n        key = params.key;\n      } else {\n        key = bufferUtils.toArrayBuffer(params.key);\n      }\n\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\n      var keyLength = key.byteLength * 8;\n      var mode = params.mode || DEFAULT_MODE;\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\n\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\n        throw new Error(\n          'Crypto.getDefaultParams: a keyLength of ' +\n            params.keyLength +\n            ' was specified, but the key actually has length ' +\n            cipherParams.keyLength\n        );\n      }\n\n      validateCipherParams(cipherParams);\n      return cipherParams;\n    }\n\n    /**\n     * Generate a random encryption key from the supplied keylength (or the\n     * default keyLength if none supplied) as an ArrayBuffer\n     * @param keyLength (optional) the required keyLength in bits\n     */\n    static async generateRandomKey(keyLength?: number): Promise<API.Types.CipherKey> {\n      return new Promise((resolve, reject) => {\n        generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, function (err, buf) {\n          if (err) {\n            const errorInfo = new ErrorInfo('Failed to generate random key: ' + err.message, 400, 50000, err);\n            reject(errorInfo);\n          } else {\n            resolve(buf!);\n          }\n        });\n      });\n    }\n\n    /**\n     * Internal; get a ChannelCipher instance based on the given cipherParams\n     * @param params either a CipherParams instance or some subset of its\n     * fields that includes a key\n     */\n    static getCipher(params: IGetCipherParams<IV>) {\n      var cipherParams = isCipherParams(params) ? (params as CipherParams) : this.getDefaultParams(params);\n\n      return {\n        cipherParams: cipherParams,\n        cipher: new CBCCipher(cipherParams, params.iv ?? null),\n      };\n    }\n  }\n\n  Crypto satisfies ICryptoStatic<IV, InputPlaintext, OutputCiphertext, InputCiphertext, OutputPlaintext>;\n\n  class CBCCipher implements ICipher<InputPlaintext, OutputCiphertext, InputCiphertext, OutputPlaintext> {\n    algorithm: string;\n    webCryptoAlgorithm: string;\n    key: ArrayBuffer;\n    iv: ArrayBuffer | null;\n\n    constructor(params: CipherParams, iv: IV | null) {\n      if (!crypto.subtle) {\n        if (isSecureContext) {\n          throw new Error(\n            'Crypto operations are not possible since the browser\u2019s SubtleCrypto class is unavailable (reason unknown).'\n          );\n        } else {\n          throw new Error(\n            'Crypto operations are is not possible since the current environment is a non-secure context and hence the browser\u2019s SubtleCrypto class is not available.'\n          );\n        }\n      }\n\n      this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;\n      this.webCryptoAlgorithm = params.algorithm + '-' + params.mode;\n      this.key = bufferUtils.toArrayBuffer(params.key);\n      this.iv = iv ? bufferUtils.toArrayBuffer(iv) : null;\n    }\n\n    private concat(buffer1: Bufferlike, buffer2: Bufferlike) {\n      const output = new ArrayBuffer(buffer1.byteLength + buffer2.byteLength);\n      const outputView = new DataView(output);\n\n      const buffer1View = new DataView(bufferUtils.toArrayBuffer(buffer1));\n      for (let i = 0; i < buffer1View.byteLength; i++) {\n        outputView.setInt8(i, buffer1View.getInt8(i));\n      }\n\n      const buffer2View = new DataView(bufferUtils.toArrayBuffer(buffer2));\n      for (let i = 0; i < buffer2View.byteLength; i++) {\n        outputView.setInt8(buffer1View.byteLength + i, buffer2View.getInt8(i));\n      }\n\n      return output;\n    }\n\n    encrypt(plaintext: InputPlaintext, callback: (error: Error | null, data: OutputCiphertext | null) => void) {\n      Logger.logAction(Logger.LOG_MICRO, 'CBCCipher.encrypt()', '');\n\n      const encryptAsync = async () => {\n        const iv = await new Promise((resolve: (iv: IV) => void, reject: (error: Error) => void) => {\n          this.getIv((error, iv) => {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(iv!);\n            }\n          });\n        });\n\n        const cryptoKey = await crypto.subtle.importKey('raw', this.key, this.webCryptoAlgorithm, false, ['encrypt']);\n        const ciphertext = await crypto.subtle.encrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, plaintext);\n\n        return this.concat(iv, ciphertext);\n      };\n\n      encryptAsync()\n        .then((ciphertext) => {\n          callback(null, ciphertext);\n        })\n        .catch((error) => {\n          callback(error, null);\n        });\n    }\n\n    async decrypt(ciphertext: InputCiphertext): Promise<OutputPlaintext> {\n      Logger.logAction(Logger.LOG_MICRO, 'CBCCipher.decrypt()', '');\n\n      const ciphertextArrayBuffer = bufferUtils.toArrayBuffer(ciphertext);\n      const iv = ciphertextArrayBuffer.slice(0, DEFAULT_BLOCKLENGTH);\n      const ciphertextBody = ciphertextArrayBuffer.slice(DEFAULT_BLOCKLENGTH);\n\n      const cryptoKey = await crypto.subtle.importKey('raw', this.key, this.webCryptoAlgorithm, false, ['decrypt']);\n      return crypto.subtle.decrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, ciphertextBody);\n    }\n\n    getIv(callback: (error: Error | null, iv: ArrayBuffer | null) => void) {\n      if (this.iv) {\n        var iv = this.iv;\n        this.iv = null;\n        callback(null, iv);\n        return;\n      }\n\n      /* Since the iv for a new block is the ciphertext of the last, this\n       * sets a new iv (= aes(randomBlock XOR lastCipherText)) as well as\n       * returning it */\n      generateRandom(DEFAULT_BLOCKLENGTH, function (err, randomBlock) {\n        if (err) {\n          callback(err, null);\n          return;\n        }\n        callback(null, bufferUtils.toArrayBuffer(randomBlock!));\n      });\n    }\n  }\n\n  return Crypto;\n};\n\nexport default CryptoFactory;\n", "enum XHRStates {\n  REQ_SEND = 0,\n  REQ_RECV = 1,\n  REQ_RECV_POLL = 2,\n  REQ_RECV_STREAM = 3,\n}\n\nexport default XHRStates;\n", "import * as Utils from 'common/lib/util/utils';\nimport EventEmitter from 'common/lib/util/eventemitter';\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from 'common/lib/types/errorinfo';\nimport Logger from 'common/lib/util/logger';\nimport Defaults from 'common/lib/util/defaults';\nimport HttpMethods from 'common/constants/HttpMethods';\nimport IXHRRequest from 'common/types/IXHRRequest';\nimport { RequestParams } from 'common/types/http';\nimport XHRStates from 'common/constants/XHRStates';\nimport Platform from 'common/platform';\n\nfunction isAblyError(responseBody: unknown, headers: Record<string, string>): responseBody is { error?: ErrorInfo } {\n  return Utils.arrIn(Utils.allToLowerCase(Utils.keysArray(headers)), 'x-ably-errorcode');\n}\n\nfunction getAblyError(responseBody: unknown, headers: Record<string, string>) {\n  if (isAblyError(responseBody, headers)) {\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\n  }\n}\n\ndeclare const global: {\n  XDomainRequest: unknown;\n};\n\nconst noop = function () {};\nlet idCounter = 0;\nconst pendingRequests: Record<string, XHRRequest> = {};\n\nconst isIE = typeof global !== 'undefined' && global.XDomainRequest;\n\nfunction ieVersion() {\n  const match = navigator.userAgent.toString().match(/MSIE\\s([\\d.]+)/);\n  return match && Number(match[1]);\n}\n\nfunction needJsonEnvelope() {\n  /* IE 10 xhr bug: http://stackoverflow.com/a/16320339 */\n  let version;\n  return isIE && (version = ieVersion()) && version === 10;\n}\n\nfunction getHeader(xhr: XMLHttpRequest, header: string) {\n  return xhr.getResponseHeader && xhr.getResponseHeader(header);\n}\n\n/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact\n * it is 'chunked'. So instead, decide that it is chunked when\n * transfer-encoding is present or content-length is absent.  ('or' because\n * when using http2 streaming, there's no transfer-encoding header, but can\n * still deduce streaming from lack of content-length) */\nfunction isEncodingChunked(xhr: XMLHttpRequest) {\n  return (\n    xhr.getResponseHeader && (xhr.getResponseHeader('transfer-encoding') || !xhr.getResponseHeader('content-length'))\n  );\n}\n\nfunction getHeadersAsObject(xhr: XMLHttpRequest) {\n  const headerPairs = Utils.trim(xhr.getAllResponseHeaders()).split('\\r\\n');\n  const headers: Record<string, string> = {};\n  for (let i = 0; i < headerPairs.length; i++) {\n    const parts = headerPairs[i].split(':').map(Utils.trim);\n    headers[parts[0].toLowerCase()] = parts[1];\n  }\n  return headers;\n}\n\nclass XHRRequest extends EventEmitter implements IXHRRequest {\n  uri: string;\n  headers: Record<string, string>;\n  body: unknown;\n  method: string;\n  requestMode: number;\n  timeouts: Record<string, number>;\n  timedOut: boolean;\n  requestComplete: boolean;\n  id: string;\n  streamComplete?: boolean;\n  xhr?: XMLHttpRequest | null;\n  timer?: NodeJS.Timeout | number | null;\n\n  constructor(\n    uri: string,\n    headers: Record<string, string> | null,\n    params: Record<string, string>,\n    body: unknown,\n    requestMode: number,\n    timeouts: Record<string, number>,\n    method?: HttpMethods\n  ) {\n    super();\n    params = params || {};\n    params.rnd = Utils.cheapRandStr();\n    if (needJsonEnvelope() && !params.envelope) params.envelope = 'json';\n    this.uri = uri + Utils.toQueryString(params);\n    this.headers = headers || {};\n    this.body = body;\n    this.method = method ? method.toUpperCase() : Utils.isEmptyArg(body) ? 'GET' : 'POST';\n    this.requestMode = requestMode;\n    this.timeouts = timeouts;\n    this.timedOut = false;\n    this.requestComplete = false;\n    this.id = String(++idCounter);\n    pendingRequests[this.id] = this;\n  }\n\n  static createRequest(\n    uri: string,\n    headers: Record<string, string> | null,\n    params: RequestParams,\n    body: unknown,\n    requestMode: number,\n    timeouts: Record<string, number> | null,\n    method?: HttpMethods\n  ): XHRRequest {\n    /* XHR requests are used either with the context being a realtime\n     * transport, or with timeouts passed in (for when used by a rest client),\n     * or completely standalone.  Use the appropriate timeouts in each case */\n    const _timeouts = timeouts || Defaults.TIMEOUTS;\n    return new XHRRequest(\n      uri,\n      headers,\n      Utils.copy(params) as Record<string, string>,\n      body,\n      requestMode,\n      _timeouts,\n      method\n    );\n  }\n\n  complete(\n    err?: IPartialErrorInfo | null,\n    body?: unknown,\n    headers?: Record<string, string> | null,\n    unpacked?: boolean | null,\n    statusCode?: number\n  ): void {\n    if (!this.requestComplete) {\n      this.requestComplete = true;\n      if (!err && body) {\n        this.emit('data', body);\n      }\n      this.emit('complete', err, body, headers, unpacked, statusCode);\n      this.dispose();\n    }\n  }\n\n  abort(): void {\n    this.dispose();\n  }\n\n  exec(): void {\n    let headers = this.headers;\n    const timeout =\n        this.requestMode == XHRStates.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,\n      timer = (this.timer = setTimeout(() => {\n        this.timedOut = true;\n        xhr.abort();\n      }, timeout)),\n      method = this.method,\n      xhr = (this.xhr = new XMLHttpRequest()),\n      accept = headers['accept'];\n    let body = this.body;\n    let responseType: XMLHttpRequestResponseType = 'text';\n\n    if (!accept) {\n      // Default to JSON\n      headers['accept'] = 'application/json';\n    } else if (accept.indexOf('application/x-msgpack') === 0) {\n      // Msgpack responses will be typed as ArrayBuffer\n      responseType = 'arraybuffer';\n    }\n\n    if (body) {\n      const contentType = headers['content-type'] || (headers['content-type'] = 'application/json');\n      if (contentType.indexOf('application/json') > -1 && typeof body != 'string') body = JSON.stringify(body);\n    }\n\n    // Can probably remove this directive if https://github.com/nodesecurity/eslint-plugin-security/issues/26 is resolved\n    // eslint-disable-next-line security/detect-non-literal-fs-filename\n    xhr.open(method, this.uri, true);\n    xhr.responseType = responseType;\n\n    if ('authorization' in headers) {\n      xhr.withCredentials = true;\n    }\n\n    for (const h in headers) xhr.setRequestHeader(h, headers[h]);\n\n    const errorHandler = (\n      errorEvent: ProgressEvent<EventTarget>,\n      message: string,\n      code: number | null,\n      statusCode: number\n    ) => {\n      let errorMessage = message + ' (event type: ' + errorEvent.type + ')';\n      if (this?.xhr?.statusText) errorMessage += ', current statusText is ' + this.xhr.statusText;\n      Logger.logAction(Logger.LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);\n      this.complete(new PartialErrorInfo(errorMessage, code, statusCode));\n    };\n    xhr.onerror = function (errorEvent) {\n      errorHandler(errorEvent, 'XHR error occurred', null, 400);\n    };\n    xhr.onabort = (errorEvent) => {\n      if (this.timedOut) {\n        errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);\n      } else {\n        errorHandler(errorEvent, 'Request cancelled', null, 400);\n      }\n    };\n    xhr.ontimeout = function (errorEvent) {\n      errorHandler(errorEvent, 'Request timed out', null, 408);\n    };\n\n    let streaming: boolean | string;\n    let statusCode: number;\n    let successResponse: boolean;\n    let streamPos = 0;\n    let unpacked = false;\n\n    const onResponse = () => {\n      clearTimeout(timer);\n      successResponse = statusCode < 400;\n      if (statusCode == 204) {\n        this.complete(null, null, null, null, statusCode);\n        return;\n      }\n      streaming = this.requestMode == XHRStates.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);\n    };\n\n    const onEnd = () => {\n      let parsedResponse: any;\n      try {\n        const contentType = getHeader(xhr, 'content-type');\n        /* Be liberal in what we accept; buggy auth servers may respond\n         * without the correct contenttype, but assume they're still\n         * responding with json */\n        const json = contentType ? contentType.indexOf('application/json') >= 0 : xhr.responseType == 'text';\n\n        if (json) {\n          /* If we requested msgpack but server responded with json, then since\n           * we set the responseType expecting msgpack, the response will be\n           * an ArrayBuffer containing json */\n          const jsonResponseBody =\n            xhr.responseType === 'arraybuffer'\n              ? Platform.BufferUtils.utf8Decode(xhr.response)\n              : String(xhr.responseText);\n          if (jsonResponseBody.length) {\n            parsedResponse = JSON.parse(jsonResponseBody);\n          } else {\n            parsedResponse = jsonResponseBody;\n          }\n          unpacked = true;\n        } else {\n          parsedResponse = xhr.response;\n        }\n\n        if (parsedResponse.response !== undefined) {\n          /* unwrap JSON envelope */\n          statusCode = parsedResponse.statusCode;\n          successResponse = statusCode < 400;\n          headers = parsedResponse.headers;\n          parsedResponse = parsedResponse.response;\n        } else {\n          headers = getHeadersAsObject(xhr);\n        }\n      } catch (e) {\n        this.complete(new PartialErrorInfo('Malformed response body from server: ' + (e as Error).message, null, 400));\n        return;\n      }\n\n      /* If response is an array, it's an array of protocol messages -- even if\n       * is contains an error action (hence the nonsuccess statuscode), we can\n       * consider the request to have succeeded, just pass it on to\n       * onProtocolMessage to decide what to do */\n      if (successResponse || Utils.isArray(parsedResponse)) {\n        this.complete(null, parsedResponse, headers, unpacked, statusCode);\n        return;\n      }\n\n      let err: IPartialErrorInfo | undefined = getAblyError(parsedResponse, headers);\n      if (!err) {\n        err = new PartialErrorInfo(\n          'Error response received from server: ' +\n            statusCode +\n            ' body was: ' +\n            Platform.Config.inspect(parsedResponse),\n          null,\n          statusCode\n        );\n      }\n      this.complete(err, parsedResponse, headers, unpacked, statusCode);\n    };\n\n    function onProgress() {\n      const responseText = xhr.responseText;\n      const bodyEnd = responseText.length - 1;\n      let idx, chunk;\n      while (streamPos < bodyEnd && (idx = responseText.indexOf('\\n', streamPos)) > -1) {\n        chunk = responseText.slice(streamPos, idx);\n        streamPos = idx + 1;\n        onChunk(chunk);\n      }\n    }\n\n    const onChunk = (chunk: string) => {\n      try {\n        chunk = JSON.parse(chunk);\n      } catch (e) {\n        this.complete(new PartialErrorInfo('Malformed response body from server: ' + (e as Error).message, null, 400));\n        return;\n      }\n      this.emit('data', chunk);\n    };\n\n    const onStreamEnd = () => {\n      onProgress();\n      this.streamComplete = true;\n      Platform.Config.nextTick(() => {\n        this.complete();\n      });\n    };\n\n    xhr.onreadystatechange = function () {\n      const readyState = xhr.readyState;\n      if (readyState < 3) return;\n      if (xhr.status !== 0) {\n        if (statusCode === undefined) {\n          statusCode = xhr.status;\n          /* IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450 */\n          if (statusCode === 1223) statusCode = 204;\n          onResponse();\n        }\n        if (readyState == 3 && streaming) {\n          onProgress();\n        } else if (readyState == 4) {\n          if (streaming) onStreamEnd();\n          else onEnd();\n        }\n      }\n    };\n    xhr.send(body as any);\n  }\n\n  dispose(): void {\n    const xhr = this.xhr;\n    if (xhr) {\n      xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;\n      this.xhr = null;\n      const timer = this.timer;\n      if (timer) {\n        clearTimeout(timer as NodeJS.Timeout);\n        this.timer = null;\n      }\n      if (!this.requestComplete) xhr.abort();\n    }\n    delete pendingRequests[this.id];\n  }\n}\n\nexport default XHRRequest;\n", "import HttpMethods from 'common/constants/HttpMethods';\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\nimport { RequestCallback, RequestParams } from 'common/types/http';\nimport Platform from 'common/platform';\nimport Defaults from 'common/lib/util/defaults';\nimport * as Utils from 'common/lib/util/utils';\nimport { getGlobalObject } from 'common/lib/util/utils';\nimport { BaseClient } from 'common/lib/client/baseclient';\n\nfunction isAblyError(responseBody: unknown, headers: Headers): responseBody is { error?: ErrorInfo } {\n  return !!headers.get('x-ably-errorcode');\n}\n\nfunction getAblyError(responseBody: unknown, headers: Headers) {\n  if (isAblyError(responseBody, headers)) {\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\n  }\n}\n\nexport default function fetchRequest(\n  method: HttpMethods,\n  client: BaseClient | null,\n  uri: string,\n  headers: Record<string, string> | null,\n  params: RequestParams,\n  body: unknown,\n  callback: RequestCallback\n) {\n  const fetchHeaders = new Headers(headers || {});\n  const _method = method ? method.toUpperCase() : Utils.isEmptyArg(body) ? 'GET' : 'POST';\n\n  const controller = new AbortController();\n\n  const timeout = setTimeout(\n    () => {\n      controller.abort();\n      callback(new PartialErrorInfo('Request timed out', null, 408));\n    },\n    client ? client.options.timeouts.httpRequestTimeout : Defaults.TIMEOUTS.httpRequestTimeout\n  );\n\n  const requestInit: RequestInit = {\n    method: _method,\n    headers: fetchHeaders,\n    body: body as any,\n  };\n\n  if (!Platform.Config.isWebworker) {\n    requestInit.credentials = fetchHeaders.has('authorization') ? 'include' : 'same-origin';\n  }\n\n  getGlobalObject()\n    .fetch(uri + '?' + new URLSearchParams(params || {}), requestInit)\n    .then((res) => {\n      clearTimeout(timeout);\n      const contentType = res.headers.get('Content-Type');\n      let prom;\n      if (contentType && contentType.indexOf('application/x-msgpack') > -1) {\n        prom = res.arrayBuffer();\n      } else if (contentType && contentType.indexOf('application/json') > -1) {\n        prom = res.json();\n      } else {\n        prom = res.text();\n      }\n      prom.then((body) => {\n        const packed = !!contentType && contentType.indexOf('application/x-msgpack') === -1;\n        if (!res.ok) {\n          const err =\n            getAblyError(body, res.headers) ||\n            new PartialErrorInfo(\n              'Error response received from server: ' + res.status + ' body was: ' + Platform.Config.inspect(body),\n              null,\n              res.status\n            );\n          callback(err, body, res.headers, packed, res.status);\n        } else {\n          callback(null, body, res.headers, packed, res.status);\n        }\n      });\n    })\n    .catch((err) => {\n      clearTimeout(timeout);\n      callback(err);\n    });\n}\n", "enum HttpStatusCodes {\n  Success = 200,\n  NoContent = 204,\n  BadRequest = 400,\n  Unauthorized = 401,\n  Forbidden = 403,\n  RequestTimeout = 408,\n  InternalServerError = 500,\n}\n\nexport function isSuccessCode(statusCode: number) {\n  return statusCode >= HttpStatusCodes.Success && statusCode < HttpStatusCodes.BadRequest;\n}\n\nexport default HttpStatusCodes;\n", "import Platform from 'common/platform';\nimport * as Utils from 'common/lib/util/utils';\nimport Defaults from 'common/lib/util/defaults';\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\nimport { ErrnoException, IHttp, RequestCallback, RequestParams } from 'common/types/http';\nimport HttpMethods from 'common/constants/HttpMethods';\nimport XHRRequest from '../transport/xhrrequest';\nimport XHRStates from 'common/constants/XHRStates';\nimport Logger from 'common/lib/util/logger';\nimport { StandardCallback } from 'common/types/utils';\nimport fetchRequest from '../transport/fetchrequest';\nimport { NormalisedClientOptions } from 'common/types/ClientOptions';\nimport { isSuccessCode } from 'common/constants/HttpStatusCodes';\nimport { BaseClient } from 'common/lib/client/baseclient';\n\nfunction shouldFallback(errorInfo: ErrorInfo) {\n  const statusCode = errorInfo.statusCode as number;\n  /* 400 + no code = a generic xhr onerror. Browser doesn't give us enough\n   * detail to know whether it's fallback-fixable, but it may be (eg if a\n   * network issue), so try just in case */\n  return (\n    (statusCode === 408 && !errorInfo.code) ||\n    (statusCode === 400 && !errorInfo.code) ||\n    (statusCode >= 500 && statusCode <= 504)\n  );\n}\n\nfunction getHosts(client: BaseClient): string[] {\n  /* If we're a connected realtime client, try the endpoint we're connected\n   * to first -- but still have fallbacks, being connected is not an absolute\n   * guarantee that a datacenter has free capacity to service REST requests. */\n  if (Utils.isRealtime(client)) {\n    const connectionHost = client.connection.connectionManager.host;\n    if (connectionHost) {\n      return [connectionHost].concat(Defaults.getFallbackHosts(client.options));\n    }\n  }\n\n  return Defaults.getHosts(client.options);\n}\n\nconst Http: typeof IHttp = class {\n  static methods = [HttpMethods.Get, HttpMethods.Delete, HttpMethods.Post, HttpMethods.Put, HttpMethods.Patch];\n  static methodsWithoutBody = [HttpMethods.Get, HttpMethods.Delete];\n  static methodsWithBody = [HttpMethods.Post, HttpMethods.Put, HttpMethods.Patch];\n  checksInProgress: Array<StandardCallback<boolean>> | null = null;\n  options: NormalisedClientOptions;\n\n  constructor(options: NormalisedClientOptions) {\n    this.options = options || {};\n\n    const connectivityCheckUrl = this.options.connectivityCheckUrl || Defaults.connectivityCheckUrl;\n    const connectivityCheckParams = this.options.connectivityCheckParams;\n    const connectivityUrlIsDefault = !this.options.connectivityCheckUrl;\n    if (Platform.Config.xhrSupported) {\n      this.supportsAuthHeaders = true;\n      this.Request = function (\n        method: HttpMethods,\n        client: BaseClient | null,\n        uri: string,\n        headers: Record<string, string> | null,\n        params: RequestParams,\n        body: unknown,\n        callback: RequestCallback\n      ) {\n        const req = XHRRequest.createRequest(\n          uri,\n          headers,\n          params,\n          body,\n          XHRStates.REQ_SEND,\n          client && client.options.timeouts,\n          method\n        );\n        req.once('complete', callback);\n        req.exec();\n        return req;\n      };\n      if (this.options.disableConnectivityCheck) {\n        this.checkConnectivity = function (callback: (err: null, connectivity: true) => void) {\n          callback(null, true);\n        };\n      } else {\n        this.checkConnectivity = function (callback: (err: ErrorInfo | null, connectivity: boolean) => void) {\n          Logger.logAction(\n            Logger.LOG_MICRO,\n            '(XHRRequest)Http.checkConnectivity()',\n            'Sending; ' + connectivityCheckUrl\n          );\n          this.doUri(\n            HttpMethods.Get,\n            null as any,\n            connectivityCheckUrl,\n            null,\n            null,\n            connectivityCheckParams,\n            function (\n              err?: ErrorInfo | ErrnoException | null,\n              responseText?: unknown,\n              headers?: any,\n              packed?: boolean,\n              statusCode?: number\n            ) {\n              let result = false;\n              if (!connectivityUrlIsDefault) {\n                result = !err && isSuccessCode(statusCode as number);\n              } else {\n                result = !err && (responseText as string)?.replace(/\\n/, '') == 'yes';\n              }\n              Logger.logAction(Logger.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);\n              callback(null, result);\n            }\n          );\n        };\n      }\n    } else if (Platform.Config.fetchSupported) {\n      this.supportsAuthHeaders = true;\n      this.Request = fetchRequest;\n      this.checkConnectivity = function (callback: (err: ErrorInfo | null, connectivity: boolean) => void) {\n        Logger.logAction(Logger.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Sending; ' + connectivityCheckUrl);\n        this.doUri(\n          HttpMethods.Get,\n          null as any,\n          connectivityCheckUrl,\n          null,\n          null,\n          null,\n          function (err?: ErrorInfo | ErrnoException | null, responseText?: unknown) {\n            const result = !err && (responseText as string)?.replace(/\\n/, '') == 'yes';\n            Logger.logAction(Logger.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Result: ' + result);\n            callback(null, result);\n          }\n        );\n      };\n    } else {\n      this.Request = (method, rest, uri, headers, params, body, callback) => {\n        callback(new PartialErrorInfo('no supported HTTP transports available', null, 400), null);\n      };\n    }\n  }\n\n  /* Unlike for doUri, the 'rest' param here is mandatory, as it's used to generate the hosts */\n  do(\n    method: HttpMethods,\n    client: BaseClient,\n    path: string,\n    headers: Record<string, string> | null,\n    body: unknown,\n    params: RequestParams,\n    callback?: RequestCallback\n  ): void {\n    const uriFromHost =\n      typeof path == 'function'\n        ? path\n        : function (host: string) {\n            return client.baseUri(host) + path;\n          };\n\n    const currentFallback = client._currentFallback;\n    if (currentFallback) {\n      if (currentFallback.validUntil > Utils.now()) {\n        /* Use stored fallback */\n        if (!this.Request) {\n          callback?.(new PartialErrorInfo('Request invoked before assigned to', null, 500));\n          return;\n        }\n        this.Request(\n          method,\n          client,\n          uriFromHost(currentFallback.host),\n          headers,\n          params,\n          body,\n          (err?: ErrnoException | ErrorInfo | null, ...args: unknown[]) => {\n            // This typecast is safe because ErrnoExceptions are only thrown in NodeJS\n            if (err && shouldFallback(err as ErrorInfo)) {\n              /* unstore the fallback and start from the top with the default sequence */\n              client._currentFallback = null;\n              this.do(method, client, path, headers, body, params, callback);\n              return;\n            }\n            callback?.(err, ...args);\n          }\n        );\n        return;\n      } else {\n        /* Fallback expired; remove it and fallthrough to normal sequence */\n        client._currentFallback = null;\n      }\n    }\n\n    const hosts = getHosts(client);\n\n    /* if there is only one host do it */\n    if (hosts.length === 1) {\n      this.doUri(method, client, uriFromHost(hosts[0]), headers, body, params, callback as RequestCallback);\n      return;\n    }\n\n    /* hosts is an array with preferred host plus at least one fallback */\n    const tryAHost = (candidateHosts: Array<string>, persistOnSuccess?: boolean) => {\n      const host = candidateHosts.shift();\n      this.doUri(\n        method,\n        client,\n        uriFromHost(host as string),\n        headers,\n        body,\n        params,\n        function (err?: ErrnoException | ErrorInfo | null, ...args: unknown[]) {\n          // This typecast is safe because ErrnoExceptions are only thrown in NodeJS\n          if (err && shouldFallback(err as ErrorInfo) && candidateHosts.length) {\n            tryAHost(candidateHosts, true);\n            return;\n          }\n          if (persistOnSuccess) {\n            /* RSC15f */\n            client._currentFallback = {\n              host: host as string,\n              validUntil: Utils.now() + client.options.timeouts.fallbackRetryTimeout,\n            };\n          }\n          callback?.(err, ...args);\n        }\n      );\n    };\n    tryAHost(hosts);\n  }\n\n  doUri(\n    method: HttpMethods,\n    client: BaseClient | null,\n    uri: string,\n    headers: Record<string, string> | null,\n    body: unknown,\n    params: RequestParams,\n    callback: RequestCallback\n  ): void {\n    if (!this.Request) {\n      callback(new PartialErrorInfo('Request invoked before assigned to', null, 500));\n      return;\n    }\n    this.Request(method, client, uri, headers, params, body, callback);\n  }\n\n  Request?: (\n    method: HttpMethods,\n    client: BaseClient | null,\n    uri: string,\n    headers: Record<string, string> | null,\n    params: RequestParams,\n    body: unknown,\n    callback: RequestCallback\n  ) => void;\n\n  checkConnectivity?: (callback: (err: ErrorInfo | null, connectivity?: boolean) => void) => void = undefined;\n\n  supportsAuthHeaders = false;\n  supportsLinkHeaders = false;\n\n  _getHosts = getHosts;\n};\n\nexport default Http;\n", "function inspect(buffer: undefined | ArrayBuffer | DataView) {\n  if (buffer === undefined) return 'undefined';\n  let view;\n  let type;\n  if (buffer instanceof ArrayBuffer) {\n    type = 'ArrayBuffer';\n    view = new DataView(buffer);\n  } else if (buffer instanceof DataView) {\n    type = 'DataView';\n    view = buffer;\n  }\n  if (!view) return JSON.stringify(buffer);\n  const bytes = [];\n  for (let i = 0; i < buffer.byteLength; i++) {\n    if (i > 20) {\n      bytes.push('...');\n      break;\n    }\n    let byte_ = view.getUint8(i).toString(16);\n    if (byte_.length === 1) byte_ = '0' + byte_;\n    bytes.push(byte_);\n  }\n  return '<' + type + ' ' + bytes.join(' ') + '>';\n}\n\n// Encode string as utf8 into dataview at offset\nfunction utf8Write(view: DataView, offset: number, string: string) {\n  for (let i = 0, l = string.length; i < l; i++) {\n    const codePoint = string.charCodeAt(i);\n\n    // One byte of UTF-8\n    if (codePoint < 0x80) {\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x7f) | 0x00);\n      continue;\n    }\n\n    // Two bytes of UTF-8\n    if (codePoint < 0x800) {\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x1f) | 0xc0);\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\n      continue;\n    }\n\n    // Three bytes of UTF-8.\n    if (codePoint < 0x10000) {\n      view.setUint8(offset++, ((codePoint >>> 12) & 0x0f) | 0xe0);\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\n      continue;\n    }\n\n    // Four bytes of UTF-8\n    if (codePoint < 0x110000) {\n      view.setUint8(offset++, ((codePoint >>> 18) & 0x07) | 0xf0);\n      view.setUint8(offset++, ((codePoint >>> 12) & 0x3f) | 0x80);\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\n      continue;\n    }\n    throw new Error('bad codepoint ' + codePoint);\n  }\n}\n\nfunction utf8Read(view: DataView, offset: number, length: number) {\n  let string = '';\n  for (let i = offset, end = offset + length; i < end; i++) {\n    const byte_ = view.getUint8(i);\n    // One byte character\n    if ((byte_ & 0x80) === 0x00) {\n      string += String.fromCharCode(byte_);\n      continue;\n    }\n    // Two byte character\n    if ((byte_ & 0xe0) === 0xc0) {\n      string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));\n      continue;\n    }\n    // Three byte character\n    if ((byte_ & 0xf0) === 0xe0) {\n      string += String.fromCharCode(\n        ((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0)\n      );\n      continue;\n    }\n    // Four byte character\n    if ((byte_ & 0xf8) === 0xf0) {\n      string += String.fromCharCode(\n        ((byte_ & 0x07) << 18) |\n          ((view.getUint8(++i) & 0x3f) << 12) |\n          ((view.getUint8(++i) & 0x3f) << 6) |\n          ((view.getUint8(++i) & 0x3f) << 0)\n      );\n      continue;\n    }\n    throw new Error('Invalid byte ' + byte_.toString(16));\n  }\n  return string;\n}\n\nfunction utf8ByteCount(string: string) {\n  let count = 0;\n  for (let i = 0, l = string.length; i < l; i++) {\n    const codePoint = string.charCodeAt(i);\n    if (codePoint < 0x80) {\n      count += 1;\n      continue;\n    }\n    if (codePoint < 0x800) {\n      count += 2;\n      continue;\n    }\n    if (codePoint < 0x10000) {\n      count += 3;\n      continue;\n    }\n    if (codePoint < 0x110000) {\n      count += 4;\n      continue;\n    }\n    throw new Error('bad codepoint ' + codePoint);\n  }\n  return count;\n}\n\nfunction encode(value: unknown, sparse?: boolean) {\n  const size = sizeof(value, sparse);\n  if (size === 0) return undefined;\n  const buffer = new ArrayBuffer(size);\n  const view = new DataView(buffer);\n  _encode(value, view, 0, sparse);\n  return buffer;\n}\n\nconst SH_L_32 = (1 << 16) * (1 << 16),\n  SH_R_32 = 1 / SH_L_32;\nfunction getInt64(view: DataView, offset: number) {\n  offset = offset || 0;\n  return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);\n}\n\nfunction getUint64(view: DataView, offset: number) {\n  offset = offset || 0;\n  return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);\n}\n\nfunction setInt64(view: DataView, offset: number, val: number) {\n  if (val < 0x8000000000000000) {\n    view.setInt32(offset, Math.floor(val * SH_R_32));\n    view.setInt32(offset + 4, val & -1);\n  } else {\n    view.setUint32(offset, 0x7fffffff);\n    view.setUint32(offset + 4, 0x7fffffff);\n  }\n}\n\nfunction setUint64(view: DataView, offset: number, val: number) {\n  if (val < 0x10000000000000000) {\n    view.setUint32(offset, Math.floor(val * SH_R_32));\n    view.setInt32(offset + 4, val & -1);\n  } else {\n    view.setUint32(offset, 0xffffffff);\n    view.setUint32(offset + 4, 0xffffffff);\n  }\n}\n\n// https://gist.github.com/frsyuki/5432559 - v5 spec\n//\n// I've used one extension point from `fixext 1` to store `undefined`. On the wire this\n// should translate to exactly 0xd40000\n//\n// +--------+--------+--------+\n// |  0xd4  |  0x00  |  0x00  |\n// +--------+--------+--------+\n//    ^ fixext |        ^ value part unused (fixed to be 0)\n//             ^ indicates undefined value\n//\n\nclass Decoder {\n  offset: number;\n  view: DataView;\n\n  constructor(view: DataView, offset?: number) {\n    this.offset = offset || 0;\n    this.view = view;\n  }\n\n  map = (length: number) => {\n    const value: { [key: string]: ArrayBuffer } = {};\n    for (let i = 0; i < length; i++) {\n      const key = this.parse();\n      value[key as string] = this.parse() as ArrayBuffer;\n    }\n    return value;\n  };\n\n  bin = (length: number) => {\n    const value = new ArrayBuffer(length);\n    new Uint8Array(value).set(new Uint8Array(this.view.buffer, this.offset, length), 0);\n    this.offset += length;\n    return value;\n  };\n\n  buf = this.bin;\n\n  str = (length: number) => {\n    const value = utf8Read(this.view, this.offset, length);\n    this.offset += length;\n    return value;\n  };\n\n  array = (length: number) => {\n    const value = new Array(length);\n    for (let i = 0; i < length; i++) {\n      value[i] = this.parse();\n    }\n    return value;\n  };\n\n  ext = (length: number) => {\n    this.offset += length;\n    return {\n      type: this.view.getInt8(this.offset),\n      data: this.buf(length),\n    };\n  };\n\n  parse = (): unknown => {\n    const type = this.view.getUint8(this.offset);\n    let value, length;\n\n    // Positive FixInt - 0xxxxxxx\n    if ((type & 0x80) === 0x00) {\n      this.offset++;\n      return type;\n    }\n\n    // FixMap - 1000xxxx\n    if ((type & 0xf0) === 0x80) {\n      length = type & 0x0f;\n      this.offset++;\n      return this.map(length);\n    }\n\n    // FixArray - 1001xxxx\n    if ((type & 0xf0) === 0x90) {\n      length = type & 0x0f;\n      this.offset++;\n      return this.array(length);\n    }\n\n    // FixStr - 101xxxxx\n    if ((type & 0xe0) === 0xa0) {\n      length = type & 0x1f;\n      this.offset++;\n      return this.str(length);\n    }\n\n    // Negative FixInt - 111xxxxx\n    if ((type & 0xe0) === 0xe0) {\n      value = this.view.getInt8(this.offset);\n      this.offset++;\n      return value;\n    }\n\n    switch (type) {\n      // nil\n      case 0xc0:\n        this.offset++;\n        return null;\n\n      // 0xc1 never used - use for undefined (NON-STANDARD)\n      case 0xc1:\n        this.offset++;\n        return undefined;\n\n      // false\n      case 0xc2:\n        this.offset++;\n        return false;\n\n      // true\n      case 0xc3:\n        this.offset++;\n        return true;\n\n      // bin 8\n      case 0xc4:\n        length = this.view.getUint8(this.offset + 1);\n        this.offset += 2;\n        return this.bin(length);\n\n      // bin 16\n      case 0xc5:\n        length = this.view.getUint16(this.offset + 1);\n        this.offset += 3;\n        return this.bin(length);\n\n      // bin 32\n      case 0xc6:\n        length = this.view.getUint32(this.offset + 1);\n        this.offset += 5;\n        return this.bin(length);\n\n      // ext 8\n      case 0xc7:\n        length = this.view.getUint8(this.offset + 1);\n        this.offset += 2;\n        return this.ext(length);\n\n      // ext 16\n      case 0xc8:\n        length = this.view.getUint16(this.offset + 1);\n        this.offset += 3;\n        return this.ext(length);\n\n      // ext 32\n      case 0xc9:\n        length = this.view.getUint32(this.offset + 1);\n        this.offset += 5;\n        return this.ext(length);\n\n      // float 32\n      case 0xca:\n        value = this.view.getFloat32(this.offset + 1);\n        this.offset += 5;\n        return value;\n\n      // float 64\n      case 0xcb:\n        value = this.view.getFloat64(this.offset + 1);\n        this.offset += 9;\n        return value;\n\n      // uint8\n      case 0xcc:\n        value = this.view.getUint8(this.offset + 1);\n        this.offset += 2;\n        return value;\n\n      // uint 16\n      case 0xcd:\n        value = this.view.getUint16(this.offset + 1);\n        this.offset += 3;\n        return value;\n\n      // uint 32\n      case 0xce:\n        value = this.view.getUint32(this.offset + 1);\n        this.offset += 5;\n        return value;\n\n      // uint 64\n      case 0xcf:\n        value = getUint64(this.view, this.offset + 1);\n        this.offset += 9;\n        return value;\n\n      // int 8\n      case 0xd0:\n        value = this.view.getInt8(this.offset + 1);\n        this.offset += 2;\n        return value;\n\n      // int 16\n      case 0xd1:\n        value = this.view.getInt16(this.offset + 1);\n        this.offset += 3;\n        return value;\n\n      // int 32\n      case 0xd2:\n        value = this.view.getInt32(this.offset + 1);\n        this.offset += 5;\n        return value;\n\n      // int 64\n      case 0xd3:\n        value = getInt64(this.view, this.offset + 1);\n        this.offset += 9;\n        return value;\n\n      // fixext 1\n      case 0xd4:\n        length = 1;\n        this.offset++;\n        return this.ext(length);\n\n      // fixext 2\n      case 0xd5:\n        length = 2;\n        this.offset++;\n        return this.ext(length);\n\n      // fixext 4\n      case 0xd6:\n        length = 4;\n        this.offset++;\n        return this.ext(length);\n\n      // fixext 8\n      case 0xd7:\n        length = 8;\n        this.offset++;\n        return this.ext(length);\n\n      // fixext 16\n      case 0xd8:\n        length = 16;\n        this.offset++;\n        return this.ext(length);\n\n      // str8\n      case 0xd9:\n        length = this.view.getUint8(this.offset + 1);\n        this.offset += 2;\n        return this.str(length);\n\n      // str 16\n      case 0xda:\n        length = this.view.getUint16(this.offset + 1);\n        this.offset += 3;\n        return this.str(length);\n\n      // str 32\n      case 0xdb:\n        length = this.view.getUint32(this.offset + 1);\n        this.offset += 5;\n        return this.str(length);\n\n      // array 16\n      case 0xdc:\n        length = this.view.getUint16(this.offset + 1);\n        this.offset += 3;\n        return this.array(length);\n\n      // array 32\n      case 0xdd:\n        length = this.view.getUint32(this.offset + 1);\n        this.offset += 5;\n        return this.array(length);\n\n      // map 16\n      case 0xde:\n        length = this.view.getUint16(this.offset + 1);\n        this.offset += 3;\n        return this.map(length);\n\n      // map 32\n      case 0xdf:\n        length = this.view.getUint32(this.offset + 1);\n        this.offset += 5;\n        return this.map(length);\n    }\n    throw new Error('Unknown type 0x' + type.toString(16));\n  };\n}\n\nfunction decode(buffer: ArrayBuffer) {\n  const view = new DataView(buffer);\n  const decoder = new Decoder(view);\n  const value = decoder.parse();\n  if (decoder.offset !== buffer.byteLength) throw new Error(buffer.byteLength - decoder.offset + ' trailing bytes');\n  return value;\n}\n\nfunction encodeableKeys(value: { [key: string]: unknown }, sparse?: boolean) {\n  return Object.keys(value).filter(function (e) {\n    const val = value[e],\n      type = typeof val;\n    return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!(val as Date).toJSON);\n  });\n}\n\nfunction _encode(value: unknown, view: DataView, offset: number, sparse?: boolean): number {\n  const type = typeof value;\n\n  // Strings Bytes\n  // There are four string types: fixstr/str8/str16/str32\n  if (typeof value === 'string') {\n    const length = utf8ByteCount(value);\n\n    // fixstr\n    if (length < 0x20) {\n      view.setUint8(offset, length | 0xa0);\n      utf8Write(view, offset + 1, value);\n      return 1 + length;\n    }\n\n    // str8\n    if (length < 0x100) {\n      view.setUint8(offset, 0xd9);\n      view.setUint8(offset + 1, length);\n      utf8Write(view, offset + 2, value);\n      return 2 + length;\n    }\n\n    // str16\n    if (length < 0x10000) {\n      view.setUint8(offset, 0xda);\n      view.setUint16(offset + 1, length);\n      utf8Write(view, offset + 3, value);\n      return 3 + length;\n    }\n    // str32\n    if (length < 0x100000000) {\n      view.setUint8(offset, 0xdb);\n      view.setUint32(offset + 1, length);\n      utf8Write(view, offset + 5, value);\n      return 5 + length;\n    }\n  }\n\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n    // extract the arraybuffer and fallthrough\n    value = value.buffer;\n  }\n\n  // There are three bin types: bin8/bin16/bin32\n  if (value instanceof ArrayBuffer) {\n    const length = value.byteLength;\n\n    // bin8\n    if (length < 0x100) {\n      view.setUint8(offset, 0xc4);\n      view.setUint8(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);\n      return 2 + length;\n    }\n\n    // bin16\n    if (length < 0x10000) {\n      view.setUint8(offset, 0xc5);\n      view.setUint16(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);\n      return 3 + length;\n    }\n\n    // bin 32\n    if (length < 0x100000000) {\n      view.setUint8(offset, 0xc6);\n      view.setUint32(offset + 1, length);\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (typeof value === 'number') {\n    // Floating Point\n    // NOTE: We're always using float64\n    if (Math.floor(value) !== value) {\n      view.setUint8(offset, 0xcb);\n      view.setFloat64(offset + 1, value);\n      return 9;\n    }\n\n    // Integers\n    if (value >= 0) {\n      // positive fixnum\n      if (value < 0x80) {\n        view.setUint8(offset, value);\n        return 1;\n      }\n      // uint 8\n      if (value < 0x100) {\n        view.setUint8(offset, 0xcc);\n        view.setUint8(offset + 1, value);\n        return 2;\n      }\n      // uint 16\n      if (value < 0x10000) {\n        view.setUint8(offset, 0xcd);\n        view.setUint16(offset + 1, value);\n        return 3;\n      }\n      // uint 32\n      if (value < 0x100000000) {\n        view.setUint8(offset, 0xce);\n        view.setUint32(offset + 1, value);\n        return 5;\n      }\n      // uint 64\n      if (value < 0x10000000000000000) {\n        view.setUint8(offset, 0xcf);\n        setUint64(view, offset + 1, value);\n        return 9;\n      }\n      throw new Error('Number too big 0x' + value.toString(16));\n    }\n\n    // negative fixnum\n    if (value >= -0x20) {\n      view.setInt8(offset, value);\n      return 1;\n    }\n    // int 8\n    if (value >= -0x80) {\n      view.setUint8(offset, 0xd0);\n      view.setInt8(offset + 1, value);\n      return 2;\n    }\n    // int 16\n    if (value >= -0x8000) {\n      view.setUint8(offset, 0xd1);\n      view.setInt16(offset + 1, value);\n      return 3;\n    }\n    // int 32\n    if (value >= -0x80000000) {\n      view.setUint8(offset, 0xd2);\n      view.setInt32(offset + 1, value);\n      return 5;\n    }\n    // int 64\n    if (value >= -0x8000000000000000) {\n      view.setUint8(offset, 0xd3);\n      setInt64(view, offset + 1, value);\n      return 9;\n    }\n    throw new Error('Number too small -0x' + (-value).toString(16).substr(1));\n  }\n\n  // undefined - use d4 (NON-STANDARD)\n  if (type === 'undefined') {\n    if (sparse) return 0;\n    view.setUint8(offset, 0xd4);\n    view.setUint8(offset + 1, 0x00);\n    view.setUint8(offset + 2, 0x00);\n    return 3;\n  }\n\n  // null\n  if (value === null) {\n    if (sparse) return 0;\n    view.setUint8(offset, 0xc0);\n    return 1;\n  }\n\n  // Boolean\n  if (type === 'boolean') {\n    view.setUint8(offset, value ? 0xc3 : 0xc2);\n    return 1;\n  }\n\n  if ('function' === typeof (value as Date).toJSON) return _encode((value as Date).toJSON(), view, offset, sparse);\n\n  // Container Types\n  if (type === 'object') {\n    let length: number,\n      size = 0;\n    let keys: string[] | undefined;\n    const isArray = Array.isArray(value);\n\n    if (isArray) {\n      length = (value as unknown[]).length;\n    } else {\n      keys = encodeableKeys(value as { [key: string]: unknown }, sparse);\n      length = keys.length;\n    }\n\n    if (length < 0x10) {\n      view.setUint8(offset, length | (isArray ? 0x90 : 0x80));\n      size = 1;\n    } else if (length < 0x10000) {\n      view.setUint8(offset, isArray ? 0xdc : 0xde);\n      view.setUint16(offset + 1, length);\n      size = 3;\n    } else if (length < 0x100000000) {\n      view.setUint8(offset, isArray ? 0xdd : 0xdf);\n      view.setUint32(offset + 1, length);\n      size = 5;\n    }\n\n    if (isArray) {\n      for (let i = 0; i < length; i++) {\n        size += _encode((value as unknown[])[i], view, offset + size, sparse);\n      }\n    } else if (keys) {\n      for (let i = 0; i < length; i++) {\n        const key = keys[i];\n        size += _encode(key, view, offset + size);\n        size += _encode((value as { [key: string]: unknown })[key], view, offset + size, sparse);\n      }\n    }\n\n    return size;\n  }\n  if (type === 'function') return 0;\n\n  throw new Error('Unknown type ' + type);\n}\n\nfunction sizeof(value: unknown, sparse?: boolean): number {\n  const type = typeof value;\n\n  // fixstr or str8 or str16 or str32\n  if (type === 'string') {\n    const length = utf8ByteCount(value as string);\n    if (length < 0x20) {\n      return 1 + length;\n    }\n    if (length < 0x100) {\n      return 2 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n    // extract the arraybuffer and fallthrough\n    value = value.buffer;\n  }\n\n  // bin8 or bin16 or bin32\n  if (value instanceof ArrayBuffer) {\n    const length = value.byteLength;\n    if (length < 0x100) {\n      return 2 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n\n  if (typeof value === 'number') {\n    // Floating Point (32 bits)\n    // double\n    if (Math.floor(value) !== value) return 9;\n\n    // Integers\n    if (value >= 0) {\n      // positive fixint\n      if (value < 0x80) return 1;\n      // uint 8\n      if (value < 0x100) return 2;\n      // uint 16\n      if (value < 0x10000) return 3;\n      // uint 32\n      if (value < 0x100000000) return 5;\n      // uint 64\n      if (value < 0x10000000000000000) return 9;\n      // Too big\n      throw new Error('Number too big 0x' + value.toString(16));\n    }\n    // negative fixint\n    if (value >= -0x20) return 1;\n    // int 8\n    if (value >= -0x80) return 2;\n    // int 16\n    if (value >= -0x8000) return 3;\n    // int 32\n    if (value >= -0x80000000) return 5;\n    // int 64\n    if (value >= -0x8000000000000000) return 9;\n    // Too small\n    throw new Error('Number too small -0x' + value.toString(16).substr(1));\n  }\n\n  // Boolean\n  if (type === 'boolean') return 1;\n\n  // undefined, null\n  if (value === null) return sparse ? 0 : 1;\n  if (value === undefined) return sparse ? 0 : 3;\n\n  if ('function' === typeof (value as Date).toJSON) return sizeof((value as Date).toJSON(), sparse);\n\n  // Container Types\n  if (type === 'object') {\n    let length: number,\n      size = 0;\n    if (Array.isArray(value)) {\n      length = value.length;\n      for (let i = 0; i < length; i++) {\n        size += sizeof(value[i], sparse);\n      }\n    } else {\n      const keys = encodeableKeys(value as { [key: string]: unknown }, sparse);\n      length = keys.length;\n      for (let i = 0; i < length; i++) {\n        const key = keys[i];\n        size += sizeof(key) + sizeof((value as { [key: string]: unknown })[key], sparse);\n      }\n    }\n    if (length < 0x10) {\n      return 1 + size;\n    }\n    if (length < 0x10000) {\n      return 3 + size;\n    }\n    if (length < 0x100000000) {\n      return 5 + size;\n    }\n    throw new Error('Array or object too long 0x' + length.toString(16));\n  }\n  if (type === 'function') return 0;\n\n  throw new Error('Unknown type ' + type);\n}\n\nexport default {\n  encode,\n  decode,\n  inspect,\n  utf8Write,\n  utf8Read,\n  utf8ByteCount,\n};\n", "import msgpack from './lib/util/msgpack';\nimport { IPlatformConfig } from '../../common/types/IPlatformConfig';\nimport * as Utils from 'common/lib/util/utils';\n\n// Workaround for salesforce lightning locker compat\nconst globalObject = Utils.getGlobalObject();\n\ndeclare var msCrypto: typeof crypto; // for IE11\n\nif (typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') {\n  console.log(\n    \"Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm\"\n  );\n}\n\nfunction allowComet() {\n  /* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg\n   * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask\n   * So if websockets are supported, then just forget about comet transports and use that */\n  const loc = globalObject.location;\n  return !globalObject.WebSocket || !loc || !loc.origin || loc.origin.indexOf('http') > -1;\n}\n\nconst userAgent = globalObject.navigator && globalObject.navigator.userAgent.toString();\nconst currentUrl = globalObject.location && globalObject.location.href;\n\nconst Config: IPlatformConfig = {\n  agent: 'browser',\n  logTimestamps: true,\n  userAgent: userAgent,\n  currentUrl: currentUrl,\n  noUpgrade: userAgent && !!userAgent.match(/MSIE\\s8\\.0/),\n  binaryType: 'arraybuffer',\n  WebSocket: globalObject.WebSocket,\n  fetchSupported: !!globalObject.fetch,\n  xhrSupported: globalObject.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),\n  allowComet: allowComet(),\n  streamingSupported: true,\n  useProtocolHeartbeats: true,\n  msgpack: msgpack,\n  supportsBinary: !!globalObject.TextDecoder,\n  preferBinary: false,\n  ArrayBuffer: globalObject.ArrayBuffer,\n  atob: globalObject.atob,\n  nextTick:\n    typeof globalObject.setImmediate !== 'undefined'\n      ? globalObject.setImmediate.bind(globalObject)\n      : function (f: () => void) {\n          setTimeout(f, 0);\n        },\n  addEventListener: globalObject.addEventListener,\n  inspect: JSON.stringify,\n  stringByteSize: function (str: string) {\n    /* str.length will be an underestimate for non-ascii strings. But if we're\n     * in a browser too old to support TextDecoder, not much we can do. Better\n     * to underestimate, so if we do go over-size, the server will reject the\n     * message */\n    return (globalObject.TextDecoder && new globalObject.TextEncoder().encode(str).length) || str.length;\n  },\n  TextEncoder: globalObject.TextEncoder,\n  TextDecoder: globalObject.TextDecoder,\n  getRandomValues: (function (crypto) {\n    if (crypto === undefined) {\n      return undefined;\n    }\n    return function (arr: ArrayBufferView, callback?: (error: Error | null) => void) {\n      crypto.getRandomValues(arr);\n      if (callback) {\n        callback(null);\n      }\n    };\n  })(globalObject.crypto || msCrypto),\n};\n\nexport default Config;\n", "import * as Utils from 'common/lib/util/utils';\nimport IWebStorage from 'common/types/IWebStorage';\n\nconst test = 'ablyjs-storage-test';\n\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\n\nclass Webstorage implements IWebStorage {\n  sessionSupported: boolean;\n  localSupported: boolean;\n\n  constructor() {\n    /* Even just accessing the session/localStorage object can throw a\n     * security exception in some circumstances with some browsers. In\n     * others, calling setItem will throw. So have to check in this\n     * somewhat roundabout way. (If unsupported or no global object,\n     * will throw on accessing a property of undefined) */\n    try {\n      globalObject.sessionStorage.setItem(test, test);\n      globalObject.sessionStorage.removeItem(test);\n      this.sessionSupported = true;\n    } catch (e) {\n      this.sessionSupported = false;\n    }\n\n    try {\n      globalObject.localStorage.setItem(test, test);\n      globalObject.localStorage.removeItem(test);\n      this.localSupported = true;\n    } catch (e) {\n      this.localSupported = false;\n    }\n  }\n\n  get(name: string): any {\n    return this._get(name, false);\n  }\n\n  getSession(name: string): any {\n    return this._get(name, true);\n  }\n\n  remove(name: string): void {\n    return this._remove(name, false);\n  }\n\n  removeSession(name: string): void {\n    return this._remove(name, true);\n  }\n\n  set(name: string, value: string, ttl?: number): void {\n    return this._set(name, value, ttl, false);\n  }\n\n  setSession(name: string, value: string, ttl?: number): void {\n    return this._set(name, value, ttl, true);\n  }\n\n  private _set(name: string, value: string, ttl: number | undefined, session: any) {\n    const wrappedValue: Record<string, any> = { value: value };\n    if (ttl) {\n      wrappedValue.expires = Utils.now() + ttl;\n    }\n    return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));\n  }\n\n  private _get(name: string, session?: boolean) {\n    if (session && !this.sessionSupported) throw new Error('Session Storage not supported');\n    if (!session && !this.localSupported) throw new Error('Local Storage not supported');\n    const rawItem = this.storageInterface(session).getItem(name);\n    if (!rawItem) return null;\n    const wrappedValue = JSON.parse(rawItem);\n    if (wrappedValue.expires && wrappedValue.expires < Utils.now()) {\n      this.storageInterface(session).removeItem(name);\n      return null;\n    }\n    return wrappedValue.value;\n  }\n\n  private _remove(name: string, session?: boolean) {\n    return this.storageInterface(session).removeItem(name);\n  }\n\n  private storageInterface(session?: boolean) {\n    return session ? globalObject.sessionStorage : globalObject.localStorage;\n  }\n}\n\nexport default new Webstorage();\n", "enum TransportNames {\n  WebSocket = 'web_socket',\n  Comet = 'comet',\n  XhrStreaming = 'xhr_streaming',\n  XhrPolling = 'xhr_polling',\n}\n\nexport default TransportNames;\n", "import IDefaults from 'common/types/IDefaults';\nimport TransportNames from 'common/constants/TransportNames';\n\nconst Defaults: IDefaults = {\n  connectivityCheckUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',\n  /* Order matters here: the base transport is the leftmost one in the\n   * intersection of baseTransportOrder and the transports clientOption that's\n   * supported. */\n  defaultTransports: [TransportNames.XhrPolling, TransportNames.XhrStreaming, TransportNames.WebSocket],\n  baseTransportOrder: [TransportNames.XhrPolling, TransportNames.XhrStreaming, TransportNames.WebSocket],\n  transportPreferenceOrder: [TransportNames.XhrPolling, TransportNames.XhrStreaming, TransportNames.WebSocket],\n  upgradeTransports: [TransportNames.XhrStreaming, TransportNames.WebSocket],\n};\n\nexport default Defaults;\n", "// Common\nimport { BaseClient } from '../../common/lib/client/baseclient';\nimport Rest from '../../common/lib/client/rest';\nimport Platform from '../../common/platform';\n\n// Platform Specific\nimport BufferUtils from './lib/util/bufferutils';\n// @ts-ignore\nimport CryptoFactory from './lib/util/crypto';\nimport Http from './lib/util/http';\nimport Config from './config';\n// @ts-ignore\nimport Logger from '../../common/lib/util/logger';\nimport { getDefaults } from '../../common/lib/util/defaults';\nimport WebStorage from './lib/util/webstorage';\nimport PlatformDefaults from './lib/util/defaults';\n\nconst Crypto = CryptoFactory(Config, BufferUtils);\n\nPlatform.Crypto = Crypto;\nPlatform.BufferUtils = BufferUtils;\nPlatform.Http = Http;\nPlatform.Config = Config;\nPlatform.WebStorage = WebStorage;\n\nLogger.initLogHandlers();\n\nPlatform.Defaults = getDefaults(PlatformDefaults);\n\nif (Platform.Config.agent) {\n  // @ts-ignore\n  Platform.Defaults.agent += ' ' + Platform.Config.agent;\n}\n\n/* If using IE8, don't attempt to upgrade from xhr_polling to xhr_streaming -\n * while it can do streaming, the low max http-connections-per-host limit means\n * that the polling transport is crippled during the upgrade process. So just\n * leave it at the base transport */\nif (Platform.Config.noUpgrade) {\n  Platform.Defaults.upgradeTransports = [];\n}\n\nexport { BaseClient, Rest, Crypto };\n"],
  "mappings": "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",
  "names": ["_a", "_a", "n", "agent", "_a", "HttpMethods", "err", "version", "_a", "headers", "params", "_a", "err", "err", "self", "_a", "body", "headers", "self", "data", "headers", "noop", "headers", "noop", "headers", "version", "n", "hmac", "uint8Array", "hmac", "Crypto", "_a", "iv", "XHRStates", "noop", "version", "statusCode", "_a", "isAblyError", "getAblyError", "body", "getHosts", "isArray", "globalObject", "crypto", "globalObject", "TransportNames", "Defaults", "defaults_default", "defaults_default"]
}
